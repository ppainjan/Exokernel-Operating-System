
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 bd e2 00 00       	call   80e2ee <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	55                   	push   %ebp
  800034:	89 e5                	mov    %esp,%ebp
  800036:	83 ec 14             	sub    $0x14,%esp
  800039:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  80003c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800042:	50                   	push   %eax
  800043:	e8 b1 a3 00 00       	call   80a3f9 <thread_wakeup>
}
  800048:	83 c4 10             	add    $0x10,%esp
  80004b:	c9                   	leave  
  80004c:	c3                   	ret    

0080004d <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  80004d:	55                   	push   %ebp
  80004e:	89 e5                	mov    %esp,%ebp
  800050:	53                   	push   %ebx
  800051:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800057:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800059:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  80005c:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80005f:	50                   	push   %eax
  800060:	68 94 00 80 00       	push   $0x800094
  800065:	51                   	push   %ecx
  800066:	6a 00                	push   $0x0
  800068:	e8 fa a3 00 00       	call   80a467 <thread_create>
	if (r < 0)
  80006d:	83 c4 10             	add    $0x10,%esp
  800070:	85 c0                	test   %eax,%eax
  800072:	79 1b                	jns    80008f <start_timer+0x42>
		panic("cannot create timer thread: %s", e2s(r));
  800074:	83 ec 0c             	sub    $0xc,%esp
  800077:	50                   	push   %eax
  800078:	e8 1c a7 00 00       	call   80a799 <e2s>
  80007d:	50                   	push   %eax
  80007e:	68 40 0b 81 00       	push   $0x810b40
  800083:	6a 7a                	push   $0x7a
  800085:	68 75 0c 81 00       	push   $0x810c75
  80008a:	e8 c9 e2 00 00       	call   80e358 <_panic>
}
  80008f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800092:	c9                   	leave  
  800093:	c3                   	ret    

00800094 <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  800094:	55                   	push   %ebp
  800095:	89 e5                	mov    %esp,%ebp
  800097:	56                   	push   %esi
  800098:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  800099:	8b 75 08             	mov    0x8(%ebp),%esi

	for (;;) {
		uint32_t cur = sys_time_msec();
  80009c:	e8 09 ef 00 00       	call   80efaa <sys_time_msec>
  8000a1:	89 c3                	mov    %eax,%ebx

		lwip_core_lock();
  8000a3:	e8 18 a3 00 00       	call   80a3c0 <lwip_core_lock>
		t->func();
  8000a8:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000ab:	e8 15 a3 00 00       	call   80a3c5 <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  8000b0:	83 ec 04             	sub    $0x4,%esp
  8000b3:	03 1e                	add    (%esi),%ebx
  8000b5:	53                   	push   %ebx
  8000b6:	6a 00                	push   $0x0
  8000b8:	6a 00                	push   $0x0
  8000ba:	e8 51 a5 00 00       	call   80a610 <thread_wait>
  8000bf:	83 c4 10             	add    $0x10,%esp
  8000c2:	eb d8                	jmp    80009c <net_timer+0x8>

008000c4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000c4:	55                   	push   %ebp
  8000c5:	89 e5                	mov    %esp,%ebp
  8000c7:	57                   	push   %edi
  8000c8:	56                   	push   %esi
  8000c9:	53                   	push   %ebx
  8000ca:	83 ec 7c             	sub    $0x7c,%esp
  8000cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000d0:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  8000d3:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000d6:	0f 87 0b 01 00 00    	ja     8001e7 <serve_thread+0x123>
  8000dc:	8b 03                	mov    (%ebx),%eax
  8000de:	ff 24 85 20 0d 81 00 	jmp    *0x810d20(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000e5:	8b 46 04             	mov    0x4(%esi),%eax
  8000e8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000eb:	83 ec 04             	sub    $0x4,%esp
  8000ee:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000f1:	50                   	push   %eax
  8000f2:	8d 45 84             	lea    -0x7c(%ebp),%eax
  8000f5:	50                   	push   %eax
  8000f6:	ff 36                	pushl  (%esi)
  8000f8:	e8 e4 0c 00 00       	call   800de1 <lwip_accept>
  8000fd:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  8000ff:	83 c4 0c             	add    $0xc,%esp
  800102:	6a 14                	push   $0x14
  800104:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800107:	50                   	push   %eax
  800108:	56                   	push   %esi
  800109:	e8 3a ea 00 00       	call   80eb48 <memmove>
  80010e:	83 c4 10             	add    $0x10,%esp
  800111:	e9 ec 00 00 00       	jmp    800202 <serve_thread+0x13e>
		break;
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800116:	83 ec 04             	sub    $0x4,%esp
  800119:	ff 76 14             	pushl  0x14(%esi)
  80011c:	8d 46 04             	lea    0x4(%esi),%eax
  80011f:	50                   	push   %eax
  800120:	ff 36                	pushl  (%esi)
  800122:	e8 69 0e 00 00       	call   800f90 <lwip_bind>
  800127:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  800129:	83 c4 10             	add    $0x10,%esp
  80012c:	e9 d1 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800131:	83 ec 08             	sub    $0x8,%esp
  800134:	ff 76 04             	pushl  0x4(%esi)
  800137:	ff 36                	pushl  (%esi)
  800139:	e8 55 19 00 00       	call   801a93 <lwip_shutdown>
  80013e:	89 c7                	mov    %eax,%edi
		break;
  800140:	83 c4 10             	add    $0x10,%esp
  800143:	e9 ba 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  800148:	83 ec 0c             	sub    $0xc,%esp
  80014b:	ff 36                	pushl  (%esi)
  80014d:	e8 f4 0e 00 00       	call   801046 <lwip_close>
  800152:	89 c7                	mov    %eax,%edi
		break;
  800154:	83 c4 10             	add    $0x10,%esp
  800157:	e9 a6 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80015c:	83 ec 04             	sub    $0x4,%esp
  80015f:	ff 76 14             	pushl  0x14(%esi)
  800162:	8d 46 04             	lea    0x4(%esi),%eax
  800165:	50                   	push   %eax
  800166:	ff 36                	pushl  (%esi)
  800168:	e8 62 0f 00 00       	call   8010cf <lwip_connect>
  80016d:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  80016f:	83 c4 10             	add    $0x10,%esp
  800172:	e9 8b 00 00 00       	jmp    800202 <serve_thread+0x13e>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  800177:	83 ec 08             	sub    $0x8,%esp
  80017a:	ff 76 04             	pushl  0x4(%esi)
  80017d:	ff 36                	pushl  (%esi)
  80017f:	e8 01 10 00 00       	call   801185 <lwip_listen>
  800184:	89 c7                	mov    %eax,%edi
		break;
  800186:	83 c4 10             	add    $0x10,%esp
  800189:	eb 77                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  80018b:	ff 76 08             	pushl  0x8(%esi)
  80018e:	ff 76 04             	pushl  0x4(%esi)
  800191:	56                   	push   %esi
  800192:	ff 36                	pushl  (%esi)
  800194:	e8 c2 12 00 00       	call   80145b <lwip_recv>
  800199:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  80019b:	83 c4 10             	add    $0x10,%esp
  80019e:	eb 62                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001a0:	ff 76 08             	pushl  0x8(%esi)
  8001a3:	ff 76 04             	pushl  0x4(%esi)
  8001a6:	8d 46 0c             	lea    0xc(%esi),%eax
  8001a9:	50                   	push   %eax
  8001aa:	ff 36                	pushl  (%esi)
  8001ac:	e8 14 14 00 00       	call   8015c5 <lwip_send>
  8001b1:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  8001b3:	83 c4 10             	add    $0x10,%esp
  8001b6:	eb 4a                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8001b8:	83 ec 04             	sub    $0x4,%esp
  8001bb:	ff 76 08             	pushl  0x8(%esi)
  8001be:	ff 76 04             	pushl  0x4(%esi)
  8001c1:	ff 36                	pushl  (%esi)
  8001c3:	e8 90 14 00 00       	call   801658 <lwip_socket>
  8001c8:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  8001ca:	83 c4 10             	add    $0x10,%esp
  8001cd:	eb 33                	jmp    800202 <serve_thread+0x13e>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  8001cf:	83 ec 08             	sub    $0x8,%esp
  8001d2:	56                   	push   %esi
  8001d3:	68 00 b2 b3 00       	push   $0xb3b200
  8001d8:	e8 ab a6 00 00       	call   80a888 <jif_input>
		r = 0;
		break;
  8001dd:	83 c4 10             	add    $0x10,%esp
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
				req->socket.req_protocol);
		break;
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
		r = 0;
  8001e0:	bf 00 00 00 00       	mov    $0x0,%edi
		break;
  8001e5:	eb 3d                	jmp    800224 <serve_thread+0x160>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  8001e7:	83 ec 04             	sub    $0x4,%esp
  8001ea:	56                   	push   %esi
  8001eb:	ff 73 04             	pushl  0x4(%ebx)
  8001ee:	68 60 0b 81 00       	push   $0x810b60
  8001f3:	e8 39 e2 00 00       	call   80e431 <cprintf>
		r = -E_INVAL;
		break;
  8001f8:	83 c4 10             	add    $0x10,%esp
		jif_input(&nif, (void *)&req->pkt);
		r = 0;
		break;
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
  8001fb:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		break;
  800200:	eb 22                	jmp    800224 <serve_thread+0x160>
	}

	if (r == -1) {
  800202:	83 ff ff             	cmp    $0xffffffff,%edi
  800205:	75 1d                	jne    800224 <serve_thread+0x160>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800207:	ff 33                	pushl  (%ebx)
  800209:	68 80 0c 81 00       	push   $0x810c80
  80020e:	6a 64                	push   $0x64
  800210:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800213:	56                   	push   %esi
  800214:	e8 4a e7 00 00       	call   80e963 <snprintf>
		perror(buf);
  800219:	89 34 24             	mov    %esi,(%esp)
  80021c:	e8 54 a5 00 00       	call   80a775 <perror>
  800221:	83 c4 10             	add    $0x10,%esp
	}

	if (args->reqno != NSREQ_INPUT)
  800224:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800227:	74 10                	je     800239 <serve_thread+0x175>
		ipc_send(args->whom, r, 0, 0);
  800229:	6a 00                	push   $0x0
  80022b:	6a 00                	push   $0x0
  80022d:	57                   	push   %edi
  80022e:	ff 73 04             	pushl  0x4(%ebx)
  800231:	e8 30 f1 00 00       	call   80f366 <ipc_send>
  800236:	83 c4 10             	add    $0x10,%esp

	put_buffer(args->req);
  800239:	8b 53 08             	mov    0x8(%ebx),%edx
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  80023c:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  800242:	c1 e8 0c             	shr    $0xc,%eax
  800245:	c6 80 00 50 81 00 00 	movb   $0x0,0x815000(%eax)

	if (args->reqno != NSREQ_INPUT)
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
	sys_page_unmap(0, (void*) args->req);
  80024c:	83 ec 08             	sub    $0x8,%esp
  80024f:	52                   	push   %edx
  800250:	6a 00                	push   $0x0
  800252:	e8 e7 eb 00 00       	call   80ee3e <sys_page_unmap>
	free(args);
  800257:	89 1c 24             	mov    %ebx,(%esp)
  80025a:	e8 0a fe 00 00       	call   810069 <free>
}
  80025f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800262:	5b                   	pop    %ebx
  800263:	5e                   	pop    %esi
  800264:	5f                   	pop    %edi
  800265:	5d                   	pop    %ebp
  800266:	c3                   	ret    

00800267 <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800267:	55                   	push   %ebp
  800268:	89 e5                	mov    %esp,%ebp
  80026a:	56                   	push   %esi
  80026b:	53                   	push   %ebx
  80026c:	83 ec 10             	sub    $0x10,%esp
  80026f:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  800272:	e8 49 a1 00 00       	call   80a3c0 <lwip_core_lock>

	uint32_t done = 0;
  800277:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  80027e:	83 ec 08             	sub    $0x8,%esp
  800281:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  800284:	53                   	push   %ebx
  800285:	68 33 00 80 00       	push   $0x800033
  80028a:	e8 c2 20 00 00       	call   802351 <tcpip_init>
	lwip_core_unlock();
  80028f:	e8 31 a1 00 00       	call   80a3c5 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  800294:	83 c4 0c             	add    $0xc,%esp
  800297:	6a ff                	push   $0xffffffff
  800299:	6a 00                	push   $0x0
  80029b:	53                   	push   %ebx
  80029c:	e8 6f a3 00 00       	call   80a610 <thread_wait>
	lwip_core_lock();
  8002a1:	e8 1a a1 00 00       	call   80a3c0 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  8002a6:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002af:	8b 45 10             	mov    0x10(%ebp),%eax
  8002b2:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002b5:	83 c4 0c             	add    $0xc,%esp
  8002b8:	68 77 64 80 00       	push   $0x806477
  8002bd:	68 7c a9 80 00       	push   $0x80a97c
  8002c2:	68 14 50 81 00       	push   $0x815014
  8002c7:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002ca:	50                   	push   %eax
  8002cb:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002ce:	50                   	push   %eax
  8002cf:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002d2:	50                   	push   %eax
  8002d3:	68 00 b2 b3 00       	push   $0xb3b200
  8002d8:	e8 5c 42 00 00       	call   804539 <netif_add>
  8002dd:	83 c4 20             	add    $0x20,%esp
  8002e0:	85 c0                	test   %eax,%eax
  8002e2:	75 14                	jne    8002f8 <serve_init+0x91>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  8002e4:	83 ec 04             	sub    $0x4,%esp
  8002e7:	68 84 0b 81 00       	push   $0x810b84
  8002ec:	6a 5c                	push   $0x5c
  8002ee:	68 75 0c 81 00       	push   $0x810c75
  8002f3:	e8 60 e0 00 00       	call   80e358 <_panic>

	netif_set_default(nif);
  8002f8:	83 ec 0c             	sub    $0xc,%esp
  8002fb:	68 00 b2 b3 00       	push   $0xb3b200
  800300:	e8 ea 42 00 00       	call   8045ef <netif_set_default>
	netif_set_up(nif);
  800305:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  80030c:	e8 eb 42 00 00       	call   8045fc <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  800311:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800318:	b9 8f 0c 81 00       	mov    $0x810c8f,%ecx
  80031d:	ba 44 93 80 00       	mov    $0x809344,%edx
  800322:	b8 34 50 81 00       	mov    $0x815034,%eax
  800327:	e8 21 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80032c:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  800333:	b9 99 0c 81 00       	mov    $0x810c99,%ecx
  800338:	ba f5 55 80 00       	mov    $0x8055f5,%edx
  80033d:	b8 28 50 81 00       	mov    $0x815028,%eax
  800342:	e8 06 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800347:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  80034e:	b9 a5 0c 81 00       	mov    $0x810ca5,%ecx
  800353:	ba ef 5b 80 00       	mov    $0x805bef,%edx
  800358:	b8 1c 50 81 00       	mov    $0x81501c,%eax
  80035d:	e8 eb fc ff ff       	call   80004d <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800362:	89 34 24             	mov    %esi,(%esp)
  800365:	e8 d2 71 00 00       	call   80753c <inet_ntoa>
  80036a:	50                   	push   %eax
  80036b:	0f b6 05 2a b2 b3 00 	movzbl 0xb3b22a,%eax
  800372:	50                   	push   %eax
  800373:	0f b6 05 29 b2 b3 00 	movzbl 0xb3b229,%eax
  80037a:	50                   	push   %eax
  80037b:	0f b6 05 28 b2 b3 00 	movzbl 0xb3b228,%eax
  800382:	50                   	push   %eax
  800383:	0f b6 05 27 b2 b3 00 	movzbl 0xb3b227,%eax
  80038a:	50                   	push   %eax
  80038b:	0f b6 05 26 b2 b3 00 	movzbl 0xb3b226,%eax
  800392:	50                   	push   %eax
  800393:	0f b6 05 25 b2 b3 00 	movzbl 0xb3b225,%eax
  80039a:	50                   	push   %eax
  80039b:	68 a4 0b 81 00       	push   $0x810ba4
  8003a0:	e8 8c e0 00 00       	call   80e431 <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  8003a5:	83 c4 30             	add    $0x30,%esp
  8003a8:	e8 18 a0 00 00       	call   80a3c5 <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  8003ad:	83 ec 0c             	sub    $0xc,%esp
  8003b0:	68 b1 0c 81 00       	push   $0x810cb1
  8003b5:	e8 77 e0 00 00       	call   80e431 <cprintf>
}
  8003ba:	83 c4 10             	add    $0x10,%esp
  8003bd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003c0:	5b                   	pop    %ebx
  8003c1:	5e                   	pop    %esi
  8003c2:	5d                   	pop    %ebp
  8003c3:	c3                   	ret    

008003c4 <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  8003c4:	55                   	push   %ebp
  8003c5:	89 e5                	mov    %esp,%ebp
  8003c7:	57                   	push   %edi
  8003c8:	56                   	push   %esi
  8003c9:	53                   	push   %ebx
  8003ca:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003cd:	8d 7d e0             	lea    -0x20(%ebp),%edi

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8003d0:	bb 00 00 00 00       	mov    $0x0,%ebx
  8003d5:	eb 08                	jmp    8003df <serve+0x1b>
			thread_yield();
  8003d7:	e8 b1 a1 00 00       	call   80a58d <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8003dc:	83 c3 01             	add    $0x1,%ebx
  8003df:	e8 34 a0 00 00       	call   80a418 <thread_wakeups_pending>
  8003e4:	85 c0                	test   %eax,%eax
  8003e6:	74 05                	je     8003ed <serve+0x29>
  8003e8:	83 fb 1f             	cmp    $0x1f,%ebx
  8003eb:	7e ea                	jle    8003d7 <serve+0x13>
			thread_yield();

		perm = 0;
  8003ed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8003f4:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8003f9:	80 b8 00 50 81 00 00 	cmpb   $0x0,0x815000(%eax)
  800400:	74 0a                	je     80040c <serve+0x48>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  800402:	83 c0 01             	add    $0x1,%eax
  800405:	83 f8 14             	cmp    $0x14,%eax
  800408:	75 ef                	jne    8003f9 <serve+0x35>
  80040a:	eb 05                	jmp    800411 <serve+0x4d>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  80040c:	83 f8 14             	cmp    $0x14,%eax
  80040f:	75 14                	jne    800425 <serve+0x61>
		panic("NS: buffer overflow");
  800411:	83 ec 04             	sub    $0x4,%esp
  800414:	68 ca 0c 81 00       	push   $0x810cca
  800419:	6a 3f                	push   $0x3f
  80041b:	68 75 0c 81 00       	push   $0x810c75
  800420:	e8 33 df 00 00       	call   80e358 <_panic>
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  800425:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  80042b:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  80042e:	c6 80 00 50 81 00 01 	movb   $0x1,0x815000(%eax)
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800435:	83 ec 04             	sub    $0x4,%esp
  800438:	57                   	push   %edi
  800439:	53                   	push   %ebx
  80043a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80043d:	50                   	push   %eax
  80043e:	e8 b6 ee 00 00       	call   80f2f9 <ipc_recv>
  800443:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800445:	83 c4 10             	add    $0x10,%esp
  800448:	83 f8 0c             	cmp    $0xc,%eax
  80044b:	75 5e                	jne    8004ab <serve+0xe7>
			process_timer(whom);
  80044d:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800450:	3b 35 18 50 81 00    	cmp    0x815018,%esi
  800456:	74 13                	je     80046b <serve+0xa7>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800458:	83 ec 08             	sub    $0x8,%esp
  80045b:	56                   	push   %esi
  80045c:	68 e0 0b 81 00       	push   $0x810be0
  800461:	e8 cb df 00 00       	call   80e431 <cprintf>
  800466:	83 c4 10             	add    $0x10,%esp
  800469:	eb 2b                	jmp    800496 <serve+0xd2>
		return;
	}

	start = sys_time_msec();
  80046b:	e8 3a eb 00 00       	call   80efaa <sys_time_msec>
  800470:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800473:	e8 15 a1 00 00       	call   80a58d <thread_yield>
	now = sys_time_msec();
  800478:	e8 2d eb 00 00       	call   80efaa <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  80047d:	6a 00                	push   $0x0
  80047f:	6a 00                	push   $0x0
  800481:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800484:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  80048a:	29 c2                	sub    %eax,%edx
  80048c:	52                   	push   %edx
  80048d:	56                   	push   %esi
  80048e:	e8 d3 ee 00 00       	call   80f366 <ipc_send>
  800493:	83 c4 10             	add    $0x10,%esp
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  800496:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  80049c:	c1 eb 0c             	shr    $0xc,%ebx
  80049f:	c6 83 00 50 81 00 00 	movb   $0x0,0x815000(%ebx)

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
			continue;
  8004a6:	e9 25 ff ff ff       	jmp    8003d0 <serve+0xc>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  8004ab:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  8004af:	75 18                	jne    8004c9 <serve+0x105>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  8004b1:	83 ec 08             	sub    $0x8,%esp
  8004b4:	ff 75 e4             	pushl  -0x1c(%ebp)
  8004b7:	68 1c 0c 81 00       	push   $0x810c1c
  8004bc:	e8 70 df 00 00       	call   80e431 <cprintf>
			continue; // just leave it hanging...
  8004c1:	83 c4 10             	add    $0x10,%esp
  8004c4:	e9 07 ff ff ff       	jmp    8003d0 <serve+0xc>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  8004c9:	83 ec 0c             	sub    $0xc,%esp
  8004cc:	6a 0c                	push   $0xc
  8004ce:	e8 44 fc 00 00       	call   810117 <malloc>
		if (!args)
  8004d3:	83 c4 10             	add    $0x10,%esp
  8004d6:	85 c0                	test   %eax,%eax
  8004d8:	75 17                	jne    8004f1 <serve+0x12d>
			panic("could not allocate thread args structure");
  8004da:	83 ec 04             	sub    $0x4,%esp
  8004dd:	68 4c 0c 81 00       	push   $0x810c4c
  8004e2:	68 27 01 00 00       	push   $0x127
  8004e7:	68 75 0c 81 00       	push   $0x810c75
  8004ec:	e8 67 de 00 00       	call   80e358 <_panic>

		args->reqno = reqno;
  8004f1:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8004f3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8004f6:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8004f9:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8004fc:	50                   	push   %eax
  8004fd:	68 c4 00 80 00       	push   $0x8000c4
  800502:	68 de 0c 81 00       	push   $0x810cde
  800507:	6a 00                	push   $0x0
  800509:	e8 59 9f 00 00       	call   80a467 <thread_create>
		thread_yield(); // let the thread created run
  80050e:	e8 7a a0 00 00       	call   80a58d <thread_yield>
  800513:	83 c4 10             	add    $0x10,%esp
  800516:	e9 b5 fe ff ff       	jmp    8003d0 <serve+0xc>

0080051b <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  80051b:	55                   	push   %ebp
  80051c:	89 e5                	mov    %esp,%ebp
  80051e:	56                   	push   %esi
  80051f:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  800520:	83 ec 0c             	sub    $0xc,%esp
  800523:	68 eb 0c 81 00       	push   $0x810ceb
  800528:	e8 c1 72 00 00       	call   8077ee <inet_addr>
  80052d:	89 c6                	mov    %eax,%esi
  80052f:	c7 04 24 f4 0c 81 00 	movl   $0x810cf4,(%esp)
  800536:	e8 b3 72 00 00       	call   8077ee <inet_addr>
  80053b:	89 c3                	mov    %eax,%ebx
  80053d:	c7 04 24 02 0d 81 00 	movl   $0x810d02,(%esp)
  800544:	e8 a5 72 00 00       	call   8077ee <inet_addr>
  800549:	83 c4 0c             	add    $0xc,%esp
  80054c:	56                   	push   %esi
  80054d:	53                   	push   %ebx
  80054e:	50                   	push   %eax
  80054f:	e8 13 fd ff ff       	call   800267 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800554:	e8 6b fe ff ff       	call   8003c4 <serve>

00800559 <umain>:
}

void
umain(int argc, char **argv)
{
  800559:	55                   	push   %ebp
  80055a:	89 e5                	mov    %esp,%ebp
  80055c:	53                   	push   %ebx
  80055d:	83 ec 04             	sub    $0x4,%esp
	envid_t ns_envid = sys_getenvid();
  800560:	e8 16 e8 00 00       	call   80ed7b <sys_getenvid>
  800565:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800567:	c7 05 e8 42 81 00 2b 	movl   $0x81372b,0x8142e8
  80056e:	37 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800571:	e8 6e eb 00 00       	call   80f0e4 <fork>
  800576:	a3 18 50 81 00       	mov    %eax,0x815018
	if (timer_envid < 0)
  80057b:	85 c0                	test   %eax,%eax
  80057d:	79 17                	jns    800596 <umain+0x3d>
		panic("error forking");
  80057f:	83 ec 04             	sub    $0x4,%esp
  800582:	68 0c 0d 81 00       	push   $0x810d0c
  800587:	68 44 01 00 00       	push   $0x144
  80058c:	68 75 0c 81 00       	push   $0x810c75
  800591:	e8 c2 dd 00 00       	call   80e358 <_panic>
	else if (timer_envid == 0) {
  800596:	85 c0                	test   %eax,%eax
  800598:	75 16                	jne    8005b0 <umain+0x57>
		timer(ns_envid, TIMER_INTERVAL);
  80059a:	83 ec 08             	sub    $0x8,%esp
  80059d:	68 fa 00 00 00       	push   $0xfa
  8005a2:	53                   	push   %ebx
  8005a3:	e8 96 00 00 00       	call   80063e <timer>
		return;
  8005a8:	83 c4 10             	add    $0x10,%esp
  8005ab:	e9 89 00 00 00       	jmp    800639 <umain+0xe0>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8005b0:	e8 2f eb 00 00       	call   80f0e4 <fork>
	if (input_envid < 0)
  8005b5:	85 c0                	test   %eax,%eax
  8005b7:	79 17                	jns    8005d0 <umain+0x77>
		panic("error forking");
  8005b9:	83 ec 04             	sub    $0x4,%esp
  8005bc:	68 0c 0d 81 00       	push   $0x810d0c
  8005c1:	68 4e 01 00 00       	push   $0x14e
  8005c6:	68 75 0c 81 00       	push   $0x810c75
  8005cb:	e8 88 dd 00 00       	call   80e358 <_panic>
	else if (input_envid == 0) {
  8005d0:	85 c0                	test   %eax,%eax
  8005d2:	75 0e                	jne    8005e2 <umain+0x89>
		input(ns_envid);
  8005d4:	83 ec 0c             	sub    $0xc,%esp
  8005d7:	53                   	push   %ebx
  8005d8:	e8 f4 00 00 00       	call   8006d1 <input>
		return;
  8005dd:	83 c4 10             	add    $0x10,%esp
  8005e0:	eb 57                	jmp    800639 <umain+0xe0>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005e2:	e8 fd ea 00 00       	call   80f0e4 <fork>
  8005e7:	a3 14 50 81 00       	mov    %eax,0x815014
	if (output_envid < 0)
  8005ec:	85 c0                	test   %eax,%eax
  8005ee:	79 17                	jns    800607 <umain+0xae>
		panic("error forking");
  8005f0:	83 ec 04             	sub    $0x4,%esp
  8005f3:	68 0c 0d 81 00       	push   $0x810d0c
  8005f8:	68 58 01 00 00       	push   $0x158
  8005fd:	68 75 0c 81 00       	push   $0x810c75
  800602:	e8 51 dd 00 00       	call   80e358 <_panic>
	else if (output_envid == 0) {
  800607:	85 c0                	test   %eax,%eax
  800609:	75 0e                	jne    800619 <umain+0xc0>
		output(ns_envid);
  80060b:	83 ec 0c             	sub    $0xc,%esp
  80060e:	53                   	push   %ebx
  80060f:	e8 cc 00 00 00       	call   8006e0 <output>
		return;
  800614:	83 c4 10             	add    $0x10,%esp
  800617:	eb 20                	jmp    800639 <umain+0xe0>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  800619:	e8 ac 9d 00 00       	call   80a3ca <thread_init>
	thread_create(0, "main", tmain, 0);
  80061e:	6a 00                	push   $0x0
  800620:	68 1b 05 80 00       	push   $0x80051b
  800625:	68 1a 0d 81 00       	push   $0x810d1a
  80062a:	6a 00                	push   $0x0
  80062c:	e8 36 9e 00 00       	call   80a467 <thread_create>
	thread_yield();
  800631:	e8 57 9f 00 00       	call   80a58d <thread_yield>
  800636:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  800639:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80063c:	c9                   	leave  
  80063d:	c3                   	ret    

0080063e <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  80063e:	55                   	push   %ebp
  80063f:	89 e5                	mov    %esp,%ebp
  800641:	57                   	push   %edi
  800642:	56                   	push   %esi
  800643:	53                   	push   %ebx
  800644:	83 ec 1c             	sub    $0x1c,%esp
  800647:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80064a:	e8 5b e9 00 00       	call   80efaa <sys_time_msec>
  80064f:	03 45 0c             	add    0xc(%ebp),%eax
  800652:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  800654:	c7 05 e8 42 81 00 4c 	movl   $0x810d4c,0x8142e8
  80065b:	0d 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80065e:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  800661:	eb 05                	jmp    800668 <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  800663:	e8 32 e7 00 00       	call   80ed9a <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  800668:	e8 3d e9 00 00       	call   80efaa <sys_time_msec>
  80066d:	89 c2                	mov    %eax,%edx
  80066f:	85 c0                	test   %eax,%eax
  800671:	78 04                	js     800677 <timer+0x39>
  800673:	39 c3                	cmp    %eax,%ebx
  800675:	77 ec                	ja     800663 <timer+0x25>
			sys_yield();
		}
		if (r < 0)
  800677:	85 c0                	test   %eax,%eax
  800679:	79 12                	jns    80068d <timer+0x4f>
			panic("sys_time_msec: %e", r);
  80067b:	52                   	push   %edx
  80067c:	68 55 0d 81 00       	push   $0x810d55
  800681:	6a 0f                	push   $0xf
  800683:	68 67 0d 81 00       	push   $0x810d67
  800688:	e8 cb dc 00 00       	call   80e358 <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  80068d:	6a 00                	push   $0x0
  80068f:	6a 00                	push   $0x0
  800691:	6a 0c                	push   $0xc
  800693:	56                   	push   %esi
  800694:	e8 cd ec 00 00       	call   80f366 <ipc_send>
  800699:	83 c4 10             	add    $0x10,%esp

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80069c:	83 ec 04             	sub    $0x4,%esp
  80069f:	6a 00                	push   $0x0
  8006a1:	6a 00                	push   $0x0
  8006a3:	57                   	push   %edi
  8006a4:	e8 50 ec 00 00       	call   80f2f9 <ipc_recv>
  8006a9:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006ae:	83 c4 10             	add    $0x10,%esp
  8006b1:	39 f0                	cmp    %esi,%eax
  8006b3:	74 13                	je     8006c8 <timer+0x8a>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8006b5:	83 ec 08             	sub    $0x8,%esp
  8006b8:	50                   	push   %eax
  8006b9:	68 74 0d 81 00       	push   $0x810d74
  8006be:	e8 6e dd 00 00       	call   80e431 <cprintf>
				continue;
  8006c3:	83 c4 10             	add    $0x10,%esp
  8006c6:	eb d4                	jmp    80069c <timer+0x5e>
			}

			stop = sys_time_msec() + to;
  8006c8:	e8 dd e8 00 00       	call   80efaa <sys_time_msec>
  8006cd:	01 c3                	add    %eax,%ebx
  8006cf:	eb 97                	jmp    800668 <timer+0x2a>

008006d1 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  8006d1:	55                   	push   %ebp
  8006d2:	89 e5                	mov    %esp,%ebp
	binaryname = "ns_input";
  8006d4:	c7 05 e8 42 81 00 af 	movl   $0x810daf,0x8142e8
  8006db:	0d 81 00 
	// 	- read a packet from the device driver
	//	- send it to the network server
	// Hint: When you IPC a page to the network server, it will be
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
}
  8006de:	5d                   	pop    %ebp
  8006df:	c3                   	ret    

008006e0 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  8006e0:	55                   	push   %ebp
  8006e1:	89 e5                	mov    %esp,%ebp
	binaryname = "ns_output";
  8006e3:	c7 05 e8 42 81 00 b8 	movl   $0x810db8,0x8142e8
  8006ea:	0d 81 00 

	// LAB 6: Your code here:
	// 	- read a packet from the network server
	//	- send the packet to the device driver
}
  8006ed:	5d                   	pop    %ebp
  8006ee:	c3                   	ret    

008006ef <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  8006ef:	55                   	push   %ebp
  8006f0:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  8006f2:	83 f8 1f             	cmp    $0x1f,%eax
  8006f5:	76 11                	jbe    800708 <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  8006f7:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  8006fe:	00 00 00 
    return NULL;
  800701:	b8 00 00 00 00       	mov    $0x0,%eax
  800706:	eb 30                	jmp    800738 <get_socket+0x49>
  }

  sock = &sockets[s];
  800708:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80070f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  800712:	8d 0c 8d 60 50 81 00 	lea    0x815060(,%ecx,4),%ecx

  if (!sock->conn) {
  800719:	01 c2                	add    %eax,%edx
  80071b:	83 3c 95 60 50 81 00 	cmpl   $0x0,0x815060(,%edx,4)
  800722:	00 
  800723:	75 11                	jne    800736 <get_socket+0x47>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  800725:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  80072c:	00 00 00 
    return NULL;
  80072f:	b8 00 00 00 00       	mov    $0x0,%eax
  800734:	eb 02                	jmp    800738 <get_socket+0x49>
  }

  return sock;
  800736:	89 c8                	mov    %ecx,%eax
}
  800738:	5d                   	pop    %ebp
  800739:	c3                   	ret    

0080073a <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  80073a:	55                   	push   %ebp
  80073b:	89 e5                	mov    %esp,%ebp
  80073d:	57                   	push   %edi
  80073e:	56                   	push   %esi
  80073f:	53                   	push   %ebx
  800740:	83 ec 40             	sub    $0x40,%esp
  800743:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800746:	89 55 cc             	mov    %edx,-0x34(%ebp)
  800749:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  80074c:	6a 04                	push   $0x4
  80074e:	6a 00                	push   $0x0
  800750:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800753:	50                   	push   %eax
  800754:	e8 a2 e3 00 00       	call   80eafb <memset>
  FD_ZERO(&lwriteset);
  800759:	83 c4 0c             	add    $0xc,%esp
  80075c:	6a 04                	push   $0x4
  80075e:	6a 00                	push   $0x0
  800760:	8d 45 e0             	lea    -0x20(%ebp),%eax
  800763:	50                   	push   %eax
  800764:	e8 92 e3 00 00       	call   80eafb <memset>
  FD_ZERO(&lexceptset);
  800769:	83 c4 0c             	add    $0xc,%esp
  80076c:	6a 04                	push   $0x4
  80076e:	6a 00                	push   $0x0
  800770:	8d 45 dc             	lea    -0x24(%ebp),%eax
  800773:	50                   	push   %eax
  800774:	e8 82 e3 00 00       	call   80eafb <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800779:	83 c4 10             	add    $0x10,%esp
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  int i, nready = 0;
  80077c:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800783:	bf 00 00 00 00       	mov    $0x0,%edi
  800788:	e9 80 00 00 00       	jmp    80080d <lwip_selscan+0xd3>
    if (FD_ISSET(i, readset)) {
  80078d:	8d 5f 07             	lea    0x7(%edi),%ebx
  800790:	85 ff                	test   %edi,%edi
  800792:	0f 49 df             	cmovns %edi,%ebx
  800795:	c1 fb 03             	sar    $0x3,%ebx
  800798:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  80079b:	89 fe                	mov    %edi,%esi
  80079d:	83 e6 07             	and    $0x7,%esi
  8007a0:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8007a3:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8007a7:	0f a3 f0             	bt     %esi,%eax
  8007aa:	73 2c                	jae    8007d8 <lwip_selscan+0x9e>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  8007ac:	89 f8                	mov    %edi,%eax
  8007ae:	e8 3c ff ff ff       	call   8006ef <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8007b3:	85 c0                	test   %eax,%eax
  8007b5:	74 21                	je     8007d8 <lwip_selscan+0x9e>
  8007b7:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8007bb:	75 07                	jne    8007c4 <lwip_selscan+0x8a>
  8007bd:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8007c2:	74 14                	je     8007d8 <lwip_selscan+0x9e>
        FD_SET(i, &lreadset);
  8007c4:	b8 01 00 00 00       	mov    $0x1,%eax
  8007c9:	89 f1                	mov    %esi,%ecx
  8007cb:	d3 e0                	shl    %cl,%eax
  8007cd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8007d0:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  8007d4:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  8007d8:	8b 45 c8             	mov    -0x38(%ebp),%eax
  8007db:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8007df:	0f a3 f0             	bt     %esi,%eax
  8007e2:	73 26                	jae    80080a <lwip_selscan+0xd0>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  8007e4:	89 f8                	mov    %edi,%eax
  8007e6:	e8 04 ff ff ff       	call   8006ef <get_socket>
      if (p_sock && p_sock->sendevent) {
  8007eb:	85 c0                	test   %eax,%eax
  8007ed:	74 1b                	je     80080a <lwip_selscan+0xd0>
  8007ef:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  8007f4:	74 14                	je     80080a <lwip_selscan+0xd0>
        FD_SET(i, &lwriteset);
  8007f6:	b8 01 00 00 00       	mov    $0x1,%eax
  8007fb:	89 f1                	mov    %esi,%ecx
  8007fd:	d3 e0                	shl    %cl,%eax
  8007ff:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800802:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800806:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  80080a:	83 c7 01             	add    $0x1,%edi
  80080d:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  800810:	0f 8c 77 ff ff ff    	jl     80078d <lwip_selscan+0x53>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  800816:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800819:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80081c:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  80081e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800821:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  800824:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  800826:	83 ec 04             	sub    $0x4,%esp
  800829:	6a 04                	push   $0x4
  80082b:	6a 00                	push   $0x0
  80082d:	ff 75 08             	pushl  0x8(%ebp)
  800830:	e8 c6 e2 00 00       	call   80eafb <memset>
  
  return nready;
}
  800835:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  800838:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80083b:	5b                   	pop    %ebx
  80083c:	5e                   	pop    %esi
  80083d:	5f                   	pop    %edi
  80083e:	5d                   	pop    %ebp
  80083f:	c3                   	ret    

00800840 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800840:	55                   	push   %ebp
  800841:	89 e5                	mov    %esp,%ebp
  800843:	57                   	push   %edi
  800844:	56                   	push   %esi
  800845:	53                   	push   %ebx
  800846:	83 ec 3c             	sub    $0x3c,%esp
  800849:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  80084c:	89 cf                	mov    %ecx,%edi
  80084e:	8b 75 08             	mov    0x8(%ebp),%esi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800851:	e8 99 fe ff ff       	call   8006ef <get_socket>
  if (!sock)
  800856:	85 c0                	test   %eax,%eax
  800858:	0f 84 80 00 00 00    	je     8008de <lwip_getaddrname+0x9e>
  80085e:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  800860:	83 ec 04             	sub    $0x4,%esp
  800863:	6a 10                	push   $0x10
  800865:	6a 00                	push   $0x0
  800867:	8d 45 d8             	lea    -0x28(%ebp),%eax
  80086a:	50                   	push   %eax
  80086b:	e8 8b e2 00 00       	call   80eafb <memset>
  sin.sin_len = sizeof(sin);
  800870:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  800874:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  800878:	89 f0                	mov    %esi,%eax
  80087a:	0f b6 f0             	movzbl %al,%esi
  80087d:	56                   	push   %esi
  80087e:	8d 45 da             	lea    -0x26(%ebp),%eax
  800881:	50                   	push   %eax
  800882:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  800885:	50                   	push   %eax
  800886:	ff 33                	pushl  (%ebx)
  800888:	e8 f1 a2 00 00       	call   80ab7e <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  80088d:	83 c4 14             	add    $0x14,%esp
  800890:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  800894:	50                   	push   %eax
  800895:	e8 3b 6d 00 00       	call   8075d5 <htons>
  80089a:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  80089e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8008a1:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  8008a4:	83 c4 10             	add    $0x10,%esp
  8008a7:	83 3f 10             	cmpl   $0x10,(%edi)
  8008aa:	76 06                	jbe    8008b2 <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  8008ac:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(name, &sin, *namelen);
  8008b2:	83 ec 04             	sub    $0x4,%esp
  8008b5:	ff 37                	pushl  (%edi)
  8008b7:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8008ba:	50                   	push   %eax
  8008bb:	ff 75 c4             	pushl  -0x3c(%ebp)
  8008be:	e8 ed e2 00 00       	call   80ebb0 <memcpy>
  sock_set_errno(sock, 0);
  8008c3:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8008ca:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8008d1:	00 00 00 
  return 0;
  8008d4:	83 c4 10             	add    $0x10,%esp
  8008d7:	b8 00 00 00 00       	mov    $0x0,%eax
  8008dc:	eb 05                	jmp    8008e3 <lwip_getaddrname+0xa3>
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  if (!sock)
    return -1;
  8008de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    *namelen = sizeof(sin);

  SMEMCPY(name, &sin, *namelen);
  sock_set_errno(sock, 0);
  return 0;
}
  8008e3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8008e6:	5b                   	pop    %ebx
  8008e7:	5e                   	pop    %esi
  8008e8:	5f                   	pop    %edi
  8008e9:	5d                   	pop    %ebp
  8008ea:	c3                   	ret    

008008eb <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  8008eb:	55                   	push   %ebp
  8008ec:	89 e5                	mov    %esp,%ebp
  8008ee:	57                   	push   %edi
  8008ef:	56                   	push   %esi
  8008f0:	53                   	push   %ebx
  8008f1:	83 ec 1c             	sub    $0x1c,%esp
  8008f4:	8b 7d 08             	mov    0x8(%ebp),%edi
  8008f7:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  8008fa:	85 ff                	test   %edi,%edi
  8008fc:	0f 84 81 01 00 00    	je     800a83 <event_callback+0x198>
    s = conn->socket;
  800902:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  800905:	85 db                	test   %ebx,%ebx
  800907:	79 49                	jns    800952 <event_callback+0x67>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  800909:	83 ec 0c             	sub    $0xc,%esp
  80090c:	ff 35 44 50 81 00    	pushl  0x815044
  800912:	e8 ca 46 00 00       	call   804fe1 <sys_sem_wait>
      if (conn->socket < 0) {
  800917:	8b 47 1c             	mov    0x1c(%edi),%eax
  80091a:	83 c4 10             	add    $0x10,%esp
  80091d:	85 c0                	test   %eax,%eax
  80091f:	79 20                	jns    800941 <event_callback+0x56>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800921:	85 f6                	test   %esi,%esi
  800923:	75 06                	jne    80092b <event_callback+0x40>
          conn->socket--;
  800925:	83 e8 01             	sub    $0x1,%eax
  800928:	89 47 1c             	mov    %eax,0x1c(%edi)
        }
        sys_sem_signal(socksem);
  80092b:	83 ec 0c             	sub    $0xc,%esp
  80092e:	ff 35 44 50 81 00    	pushl  0x815044
  800934:	e8 9e 95 00 00       	call   809ed7 <sys_sem_signal>
        return;
  800939:	83 c4 10             	add    $0x10,%esp
  80093c:	e9 42 01 00 00       	jmp    800a83 <event_callback+0x198>
      }
      sys_sem_signal(socksem);
  800941:	83 ec 0c             	sub    $0xc,%esp
  800944:	ff 35 44 50 81 00    	pushl  0x815044
  80094a:	e8 88 95 00 00       	call   809ed7 <sys_sem_signal>
  80094f:	83 c4 10             	add    $0x10,%esp
    }

    sock = get_socket(s);
  800952:	89 d8                	mov    %ebx,%eax
  800954:	e8 96 fd ff ff       	call   8006ef <get_socket>
  800959:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  80095c:	85 c0                	test   %eax,%eax
  80095e:	0f 84 1f 01 00 00    	je     800a83 <event_callback+0x198>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  800964:	83 ec 0c             	sub    $0xc,%esp
  800967:	ff 35 40 50 81 00    	pushl  0x815040
  80096d:	e8 6f 46 00 00       	call   804fe1 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  800972:	83 c4 10             	add    $0x10,%esp
  800975:	83 fe 01             	cmp    $0x1,%esi
  800978:	74 1b                	je     800995 <event_callback+0xaa>
  80097a:	83 fe 01             	cmp    $0x1,%esi
  80097d:	72 0c                	jb     80098b <event_callback+0xa0>
  80097f:	83 fe 02             	cmp    $0x2,%esi
  800982:	74 1b                	je     80099f <event_callback+0xb4>
  800984:	83 fe 03             	cmp    $0x3,%esi
  800987:	74 21                	je     8009aa <event_callback+0xbf>
  800989:	eb 2a                	jmp    8009b5 <event_callback+0xca>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  80098b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80098e:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  800993:	eb 37                	jmp    8009cc <event_callback+0xe1>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  800995:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800998:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  80099d:	eb 2d                	jmp    8009cc <event_callback+0xe1>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  80099f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009a2:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  8009a8:	eb 22                	jmp    8009cc <event_callback+0xe1>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  8009aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009ad:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  8009b3:	eb 17                	jmp    8009cc <event_callback+0xe1>
    default:
      LWIP_ASSERT("unknown event", 0);
  8009b5:	83 ec 04             	sub    $0x4,%esp
  8009b8:	68 c2 0d 81 00       	push   $0x810dc2
  8009bd:	68 17 04 00 00       	push   $0x417
  8009c2:	68 d0 0d 81 00       	push   $0x810dd0
  8009c7:	e8 8c d9 00 00       	call   80e358 <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  8009cc:	83 ec 0c             	sub    $0xc,%esp
  8009cf:	ff 35 40 50 81 00    	pushl  0x815040
  8009d5:	e8 fd 94 00 00       	call   809ed7 <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  8009da:	8d 73 07             	lea    0x7(%ebx),%esi
  8009dd:	83 c4 10             	add    $0x10,%esp
  8009e0:	85 db                	test   %ebx,%ebx
  8009e2:	0f 49 f3             	cmovns %ebx,%esi
  8009e5:	c1 fe 03             	sar    $0x3,%esi
  8009e8:	89 d9                	mov    %ebx,%ecx
  8009ea:	83 e1 07             	and    $0x7,%ecx
  8009ed:	bf 01 00 00 00       	mov    $0x1,%edi
  8009f2:	d3 e7                	shl    %cl,%edi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  8009f4:	83 ec 0c             	sub    $0xc,%esp
  8009f7:	ff 35 40 50 81 00    	pushl  0x815040
  8009fd:	e8 df 45 00 00       	call   804fe1 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800a02:	8b 1d 48 50 81 00    	mov    0x815048,%ebx
  800a08:	83 c4 10             	add    $0x10,%esp
  800a0b:	eb 3a                	jmp    800a47 <event_callback+0x15c>
      if (scb->sem_signalled == 0) {
  800a0d:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800a11:	75 32                	jne    800a45 <event_callback+0x15a>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800a13:	8b 43 04             	mov    0x4(%ebx),%eax
  800a16:	85 c0                	test   %eax,%eax
  800a18:	74 12                	je     800a2c <event_callback+0x141>
  800a1a:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800a1e:	85 f8                	test   %edi,%eax
  800a20:	74 0a                	je     800a2c <event_callback+0x141>
          if (sock->rcvevent)
  800a22:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a25:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800a2a:	75 21                	jne    800a4d <event_callback+0x162>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800a2c:	8b 43 08             	mov    0x8(%ebx),%eax
  800a2f:	85 c0                	test   %eax,%eax
  800a31:	74 12                	je     800a45 <event_callback+0x15a>
  800a33:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800a37:	85 f8                	test   %edi,%eax
  800a39:	74 0a                	je     800a45 <event_callback+0x15a>
          if (sock->sendevent)
  800a3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a3e:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800a43:	75 08                	jne    800a4d <event_callback+0x162>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  800a45:	8b 1b                	mov    (%ebx),%ebx
  800a47:	85 db                	test   %ebx,%ebx
  800a49:	75 c2                	jne    800a0d <event_callback+0x122>
  800a4b:	eb 25                	jmp    800a72 <event_callback+0x187>
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
      scb->sem_signalled = 1;
  800a4d:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800a54:	83 ec 0c             	sub    $0xc,%esp
  800a57:	ff 35 40 50 81 00    	pushl  0x815040
  800a5d:	e8 75 94 00 00       	call   809ed7 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800a62:	83 c4 04             	add    $0x4,%esp
  800a65:	ff 73 14             	pushl  0x14(%ebx)
  800a68:	e8 6a 94 00 00       	call   809ed7 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  800a6d:	83 c4 10             	add    $0x10,%esp
  800a70:	eb 82                	jmp    8009f4 <event_callback+0x109>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  800a72:	83 ec 0c             	sub    $0xc,%esp
  800a75:	ff 35 40 50 81 00    	pushl  0x815040
  800a7b:	e8 57 94 00 00       	call   809ed7 <sys_sem_signal>
      break;
  800a80:	83 c4 10             	add    $0x10,%esp
    }
  }
}
  800a83:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800a86:	5b                   	pop    %ebx
  800a87:	5e                   	pop    %esi
  800a88:	5f                   	pop    %edi
  800a89:	5d                   	pop    %ebp
  800a8a:	c3                   	ret    

00800a8b <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  800a8b:	55                   	push   %ebp
  800a8c:	89 e5                	mov    %esp,%ebp
  800a8e:	56                   	push   %esi
  800a8f:	53                   	push   %ebx
  800a90:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  800a92:	83 ec 0c             	sub    $0xc,%esp
  800a95:	ff 35 44 50 81 00    	pushl  0x815044
  800a9b:	e8 41 45 00 00       	call   804fe1 <sys_sem_wait>
  800aa0:	b8 60 50 81 00       	mov    $0x815060,%eax
  800aa5:	83 c4 10             	add    $0x10,%esp

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800aa8:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800aad:	83 38 00             	cmpl   $0x0,(%eax)
  800ab0:	75 59                	jne    800b0b <alloc_socket+0x80>
      sockets[i].conn       = newconn;
  800ab2:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800ab5:	c1 e2 02             	shl    $0x2,%edx
  800ab8:	89 b2 60 50 81 00    	mov    %esi,0x815060(%edx)
      sockets[i].lastdata   = NULL;
  800abe:	c7 82 64 50 81 00 00 	movl   $0x0,0x815064(%edx)
  800ac5:	00 00 00 
      sockets[i].lastoffset = 0;
  800ac8:	66 c7 82 68 50 81 00 	movw   $0x0,0x815068(%edx)
  800acf:	00 00 
      sockets[i].rcvevent   = 0;
  800ad1:	66 c7 82 6a 50 81 00 	movw   $0x0,0x81506a(%edx)
  800ad8:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800ada:	66 c7 82 6c 50 81 00 	movw   $0x1,0x81506c(%edx)
  800ae1:	01 00 
      sockets[i].flags      = 0;
  800ae3:	66 c7 82 6e 50 81 00 	movw   $0x0,0x81506e(%edx)
  800aea:	00 00 
      sockets[i].err        = 0;
  800aec:	c7 82 70 50 81 00 00 	movl   $0x0,0x815070(%edx)
  800af3:	00 00 00 
      sys_sem_signal(socksem);
  800af6:	83 ec 0c             	sub    $0xc,%esp
  800af9:	ff 35 44 50 81 00    	pushl  0x815044
  800aff:	e8 d3 93 00 00       	call   809ed7 <sys_sem_signal>
      return i;
  800b04:	83 c4 10             	add    $0x10,%esp
  800b07:	89 d8                	mov    %ebx,%eax
  800b09:	eb 21                	jmp    800b2c <alloc_socket+0xa1>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800b0b:	83 c3 01             	add    $0x1,%ebx
  800b0e:	83 c0 14             	add    $0x14,%eax
  800b11:	83 fb 20             	cmp    $0x20,%ebx
  800b14:	75 97                	jne    800aad <alloc_socket+0x22>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  800b16:	83 ec 0c             	sub    $0xc,%esp
  800b19:	ff 35 44 50 81 00    	pushl  0x815044
  800b1f:	e8 b3 93 00 00       	call   809ed7 <sys_sem_signal>
  return -1;
  800b24:	83 c4 10             	add    $0x10,%esp
  800b27:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  800b2c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800b2f:	5b                   	pop    %ebx
  800b30:	5e                   	pop    %esi
  800b31:	5d                   	pop    %ebp
  800b32:	c3                   	ret    

00800b33 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800b33:	55                   	push   %ebp
  800b34:	89 e5                	mov    %esp,%ebp
  800b36:	53                   	push   %ebx
  800b37:	83 ec 04             	sub    $0x4,%esp
  800b3a:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800b3d:	85 c0                	test   %eax,%eax
  800b3f:	75 17                	jne    800b58 <lwip_getsockopt_internal+0x25>
  800b41:	83 ec 04             	sub    $0x4,%esp
  800b44:	68 e7 0d 81 00       	push   $0x810de7
  800b49:	68 38 05 00 00       	push   $0x538
  800b4e:	68 d0 0d 81 00       	push   $0x810dd0
  800b53:	e8 00 d8 00 00       	call   80e358 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800b58:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800b5a:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800b5d:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800b60:	8b 40 08             	mov    0x8(%eax),%eax
  800b63:	83 f8 06             	cmp    $0x6,%eax
  800b66:	0f 84 09 01 00 00    	je     800c75 <lwip_getsockopt_internal+0x142>
  800b6c:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800b71:	74 0d                	je     800b80 <lwip_getsockopt_internal+0x4d>
  800b73:	85 c0                	test   %eax,%eax
  800b75:	0f 85 26 01 00 00    	jne    800ca1 <lwip_getsockopt_internal+0x16e>
  800b7b:	e9 d1 00 00 00       	jmp    800c51 <lwip_getsockopt_internal+0x11e>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800b80:	83 fa 20             	cmp    $0x20,%edx
  800b83:	74 37                	je     800bbc <lwip_getsockopt_internal+0x89>
  800b85:	83 fa 20             	cmp    $0x20,%edx
  800b88:	7f 10                	jg     800b9a <lwip_getsockopt_internal+0x67>
  800b8a:	83 fa 02             	cmp    $0x2,%edx
  800b8d:	74 2d                	je     800bbc <lwip_getsockopt_internal+0x89>
  800b8f:	83 fa 08             	cmp    $0x8,%edx
  800b92:	0f 85 09 01 00 00    	jne    800ca1 <lwip_getsockopt_internal+0x16e>
  800b98:	eb 22                	jmp    800bbc <lwip_getsockopt_internal+0x89>
  800b9a:	81 fa 08 10 00 00    	cmp    $0x1008,%edx
  800ba0:	74 2c                	je     800bce <lwip_getsockopt_internal+0x9b>
  800ba2:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800ba8:	0f 84 93 00 00 00    	je     800c41 <lwip_getsockopt_internal+0x10e>
  800bae:	81 fa 07 10 00 00    	cmp    $0x1007,%edx
  800bb4:	0f 85 e7 00 00 00    	jne    800ca1 <lwip_getsockopt_internal+0x16e>
  800bba:	eb 4f                	jmp    800c0b <lwip_getsockopt_internal+0xd8>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800bbc:	8b 01                	mov    (%ecx),%eax
  800bbe:	8b 40 08             	mov    0x8(%eax),%eax
  800bc1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800bc5:	21 c2                	and    %eax,%edx
  800bc7:	89 13                	mov    %edx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  800bc9:	e9 d3 00 00 00       	jmp    800ca1 <lwip_getsockopt_internal+0x16e>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800bce:	8b 01                	mov    (%ecx),%eax
  800bd0:	8b 10                	mov    (%eax),%edx
  800bd2:	89 d0                	mov    %edx,%eax
  800bd4:	25 f0 00 00 00       	and    $0xf0,%eax
  800bd9:	83 f8 20             	cmp    $0x20,%eax
  800bdc:	74 22                	je     800c00 <lwip_getsockopt_internal+0xcd>
  800bde:	83 f8 40             	cmp    $0x40,%eax
  800be1:	74 12                	je     800bf5 <lwip_getsockopt_internal+0xc2>
  800be3:	83 f8 10             	cmp    $0x10,%eax
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  800be6:	b8 01 00 00 00       	mov    $0x1,%eax
  800beb:	0f 44 d0             	cmove  %eax,%edx
  800bee:	89 13                	mov    %edx,(%ebx)
  800bf0:	e9 ac 00 00 00       	jmp    800ca1 <lwip_getsockopt_internal+0x16e>
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  800bf5:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  800bfb:	e9 a1 00 00 00       	jmp    800ca1 <lwip_getsockopt_internal+0x16e>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  800c00:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  800c06:	e9 96 00 00 00       	jmp    800ca1 <lwip_getsockopt_internal+0x16e>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  800c0b:	83 79 10 00          	cmpl   $0x0,0x10(%ecx)
  800c0f:	75 22                	jne    800c33 <lwip_getsockopt_internal+0x100>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800c11:	8b 01                	mov    (%ecx),%eax
  800c13:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800c17:	f7 d8                	neg    %eax
  800c19:	ba 05 00 00 00       	mov    $0x5,%edx
  800c1e:	83 f8 0e             	cmp    $0xe,%eax
  800c21:	77 07                	ja     800c2a <lwip_getsockopt_internal+0xf7>
  800c23:	8b 14 85 a0 0e 81 00 	mov    0x810ea0(,%eax,4),%edx
  800c2a:	89 51 10             	mov    %edx,0x10(%ecx)
  800c2d:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
      } 
      *(int *)optval = sock->err;
  800c33:	8b 41 10             	mov    0x10(%ecx),%eax
  800c36:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  800c38:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  800c3f:	eb 60                	jmp    800ca1 <lwip_getsockopt_internal+0x16e>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800c41:	8b 01                	mov    (%ecx),%eax
  800c43:	8b 40 08             	mov    0x8(%eax),%eax
  800c46:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800c4a:	83 e0 01             	and    $0x1,%eax
  800c4d:	89 03                	mov    %eax,(%ebx)
      break;
  800c4f:	eb 50                	jmp    800ca1 <lwip_getsockopt_internal+0x16e>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800c51:	83 fa 01             	cmp    $0x1,%edx
  800c54:	74 12                	je     800c68 <lwip_getsockopt_internal+0x135>
  800c56:	83 fa 02             	cmp    $0x2,%edx
  800c59:	75 46                	jne    800ca1 <lwip_getsockopt_internal+0x16e>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800c5b:	8b 01                	mov    (%ecx),%eax
  800c5d:	8b 40 08             	mov    0x8(%eax),%eax
  800c60:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800c64:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  800c66:	eb 39                	jmp    800ca1 <lwip_getsockopt_internal+0x16e>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  800c68:	8b 01                	mov    (%ecx),%eax
  800c6a:	8b 40 08             	mov    0x8(%eax),%eax
  800c6d:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800c71:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  800c73:	eb 2c                	jmp    800ca1 <lwip_getsockopt_internal+0x16e>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800c75:	83 fa 01             	cmp    $0x1,%edx
  800c78:	74 07                	je     800c81 <lwip_getsockopt_internal+0x14e>
  800c7a:	83 fa 02             	cmp    $0x2,%edx
  800c7d:	74 15                	je     800c94 <lwip_getsockopt_internal+0x161>
  800c7f:	eb 20                	jmp    800ca1 <lwip_getsockopt_internal+0x16e>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800c81:	8b 01                	mov    (%ecx),%eax
  800c83:	8b 40 08             	mov    0x8(%eax),%eax
  800c86:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800c8a:	83 e0 40             	and    $0x40,%eax
  800c8d:	0f b6 c0             	movzbl %al,%eax
  800c90:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  800c92:	eb 0d                	jmp    800ca1 <lwip_getsockopt_internal+0x16e>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800c94:	8b 01                	mov    (%ecx),%eax
  800c96:	8b 40 08             	mov    0x8(%eax),%eax
  800c99:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800c9f:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800ca1:	83 ec 0c             	sub    $0xc,%esp
  800ca4:	8b 01                	mov    (%ecx),%eax
  800ca6:	ff 70 10             	pushl  0x10(%eax)
  800ca9:	e8 29 92 00 00       	call   809ed7 <sys_sem_signal>
}
  800cae:	83 c4 10             	add    $0x10,%esp
  800cb1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800cb4:	c9                   	leave  
  800cb5:	c3                   	ret    

00800cb6 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800cb6:	55                   	push   %ebp
  800cb7:	89 e5                	mov    %esp,%ebp
  800cb9:	53                   	push   %ebx
  800cba:	83 ec 04             	sub    $0x4,%esp
  800cbd:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800cc0:	85 c0                	test   %eax,%eax
  800cc2:	75 17                	jne    800cdb <lwip_setsockopt_internal+0x25>
  800cc4:	83 ec 04             	sub    $0x4,%esp
  800cc7:	68 e7 0d 81 00       	push   $0x810de7
  800ccc:	68 ae 06 00 00       	push   $0x6ae
  800cd1:	68 d0 0d 81 00       	push   $0x810dd0
  800cd6:	e8 7d d6 00 00       	call   80e358 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800cdb:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800cdd:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800ce0:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800ce3:	8b 40 08             	mov    0x8(%eax),%eax
  800ce6:	83 f8 06             	cmp    $0x6,%eax
  800ce9:	0f 84 81 00 00 00    	je     800d70 <lwip_setsockopt_internal+0xba>
  800cef:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800cf4:	74 0a                	je     800d00 <lwip_setsockopt_internal+0x4a>
  800cf6:	85 c0                	test   %eax,%eax
  800cf8:	0f 85 a6 00 00 00    	jne    800da4 <lwip_setsockopt_internal+0xee>
  800cfe:	eb 4e                	jmp    800d4e <lwip_setsockopt_internal+0x98>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800d00:	83 fa 20             	cmp    $0x20,%edx
  800d03:	74 11                	je     800d16 <lwip_setsockopt_internal+0x60>
  800d05:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800d0b:	74 26                	je     800d33 <lwip_setsockopt_internal+0x7d>
  800d0d:	83 fa 08             	cmp    $0x8,%edx
  800d10:	0f 85 8e 00 00 00    	jne    800da4 <lwip_setsockopt_internal+0xee>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  800d16:	83 3b 00             	cmpl   $0x0,(%ebx)
  800d19:	74 0b                	je     800d26 <lwip_setsockopt_internal+0x70>
        sock->conn->pcb.ip->so_options |= optname;
  800d1b:	8b 01                	mov    (%ecx),%eax
  800d1d:	8b 40 08             	mov    0x8(%eax),%eax
  800d20:	66 09 50 08          	or     %dx,0x8(%eax)
  800d24:	eb 7e                	jmp    800da4 <lwip_setsockopt_internal+0xee>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  800d26:	8b 01                	mov    (%ecx),%eax
  800d28:	8b 40 08             	mov    0x8(%eax),%eax
  800d2b:	f7 d2                	not    %edx
  800d2d:	66 21 50 08          	and    %dx,0x8(%eax)
  800d31:	eb 71                	jmp    800da4 <lwip_setsockopt_internal+0xee>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  800d33:	83 3b 00             	cmpl   $0x0,(%ebx)
  800d36:	74 0b                	je     800d43 <lwip_setsockopt_internal+0x8d>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800d38:	8b 01                	mov    (%ecx),%eax
  800d3a:	8b 40 08             	mov    0x8(%eax),%eax
  800d3d:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800d41:	eb 61                	jmp    800da4 <lwip_setsockopt_internal+0xee>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800d43:	8b 01                	mov    (%ecx),%eax
  800d45:	8b 40 08             	mov    0x8(%eax),%eax
  800d48:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800d4c:	eb 56                	jmp    800da4 <lwip_setsockopt_internal+0xee>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800d4e:	83 fa 01             	cmp    $0x1,%edx
  800d51:	74 11                	je     800d64 <lwip_setsockopt_internal+0xae>
  800d53:	83 fa 02             	cmp    $0x2,%edx
  800d56:	75 4c                	jne    800da4 <lwip_setsockopt_internal+0xee>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800d58:	8b 01                	mov    (%ecx),%eax
  800d5a:	8b 40 08             	mov    0x8(%eax),%eax
  800d5d:	8b 13                	mov    (%ebx),%edx
  800d5f:	88 50 0b             	mov    %dl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  800d62:	eb 40                	jmp    800da4 <lwip_setsockopt_internal+0xee>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800d64:	8b 01                	mov    (%ecx),%eax
  800d66:	8b 40 08             	mov    0x8(%eax),%eax
  800d69:	8b 13                	mov    (%ebx),%edx
  800d6b:	88 50 0a             	mov    %dl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  800d6e:	eb 34                	jmp    800da4 <lwip_setsockopt_internal+0xee>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800d70:	83 fa 01             	cmp    $0x1,%edx
  800d73:	74 07                	je     800d7c <lwip_setsockopt_internal+0xc6>
  800d75:	83 fa 02             	cmp    $0x2,%edx
  800d78:	74 1d                	je     800d97 <lwip_setsockopt_internal+0xe1>
  800d7a:	eb 28                	jmp    800da4 <lwip_setsockopt_internal+0xee>
    case TCP_NODELAY:
      if (*(int*)optval) {
  800d7c:	83 3b 00             	cmpl   $0x0,(%ebx)
  800d7f:	74 0b                	je     800d8c <lwip_setsockopt_internal+0xd6>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800d81:	8b 01                	mov    (%ecx),%eax
  800d83:	8b 40 08             	mov    0x8(%eax),%eax
  800d86:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800d8a:	eb 18                	jmp    800da4 <lwip_setsockopt_internal+0xee>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800d8c:	8b 01                	mov    (%ecx),%eax
  800d8e:	8b 40 08             	mov    0x8(%eax),%eax
  800d91:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800d95:	eb 0d                	jmp    800da4 <lwip_setsockopt_internal+0xee>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800d97:	8b 01                	mov    (%ecx),%eax
  800d99:	8b 40 08             	mov    0x8(%eax),%eax
  800d9c:	8b 13                	mov    (%ebx),%edx
  800d9e:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800da4:	83 ec 0c             	sub    $0xc,%esp
  800da7:	8b 01                	mov    (%ecx),%eax
  800da9:	ff 70 10             	pushl  0x10(%eax)
  800dac:	e8 26 91 00 00       	call   809ed7 <sys_sem_signal>
}
  800db1:	83 c4 10             	add    $0x10,%esp
  800db4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800db7:	c9                   	leave  
  800db8:	c3                   	ret    

00800db9 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  800db9:	55                   	push   %ebp
  800dba:	89 e5                	mov    %esp,%ebp
  800dbc:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800dbf:	6a 01                	push   $0x1
  800dc1:	e8 65 8e 00 00       	call   809c2b <sys_sem_new>
  800dc6:	a3 44 50 81 00       	mov    %eax,0x815044
  selectsem = sys_sem_new(1);
  800dcb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800dd2:	e8 54 8e 00 00       	call   809c2b <sys_sem_new>
  800dd7:	a3 40 50 81 00       	mov    %eax,0x815040
}
  800ddc:	83 c4 10             	add    $0x10,%esp
  800ddf:	c9                   	leave  
  800de0:	c3                   	ret    

00800de1 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  800de1:	55                   	push   %ebp
  800de2:	89 e5                	mov    %esp,%ebp
  800de4:	57                   	push   %edi
  800de5:	56                   	push   %esi
  800de6:	53                   	push   %ebx
  800de7:	83 ec 3c             	sub    $0x3c,%esp
  800dea:	8b 7d 10             	mov    0x10(%ebp),%edi
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  800ded:	8b 45 08             	mov    0x8(%ebp),%eax
  800df0:	e8 fa f8 ff ff       	call   8006ef <get_socket>
  if (!sock)
  800df5:	85 c0                	test   %eax,%eax
  800df7:	0f 84 86 01 00 00    	je     800f83 <lwip_accept+0x1a2>
  800dfd:	89 c6                	mov    %eax,%esi
    return -1;

  newconn = netconn_accept(sock->conn);
  800dff:	83 ec 0c             	sub    $0xc,%esp
  800e02:	ff 30                	pushl  (%eax)
  800e04:	e8 2b 9f 00 00       	call   80ad34 <netconn_accept>
  800e09:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800e0b:	83 c4 10             	add    $0x10,%esp
  800e0e:	85 c0                	test   %eax,%eax
  800e10:	75 2c                	jne    800e3e <lwip_accept+0x5d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  800e12:	8b 06                	mov    (%esi),%eax
  800e14:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800e18:	f7 d8                	neg    %eax
  800e1a:	ba 05 00 00 00       	mov    $0x5,%edx
  800e1f:	83 f8 0e             	cmp    $0xe,%eax
  800e22:	77 07                	ja     800e2b <lwip_accept+0x4a>
  800e24:	8b 14 85 a0 0e 81 00 	mov    0x810ea0(,%eax,4),%edx
  800e2b:	89 56 10             	mov    %edx,0x10(%esi)
  800e2e:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800e34:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800e39:	e9 4a 01 00 00       	jmp    800f88 <lwip_accept+0x1a7>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  800e3e:	6a 00                	push   $0x0
  800e40:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800e43:	50                   	push   %eax
  800e44:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800e47:	50                   	push   %eax
  800e48:	53                   	push   %ebx
  800e49:	e8 30 9d 00 00       	call   80ab7e <netconn_getaddr>
  800e4e:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800e51:	83 c4 10             	add    $0x10,%esp
  800e54:	84 c0                	test   %al,%al
  800e56:	74 36                	je     800e8e <lwip_accept+0xad>
    netconn_delete(newconn);
  800e58:	83 ec 0c             	sub    $0xc,%esp
  800e5b:	53                   	push   %ebx
  800e5c:	e8 b5 9c 00 00       	call   80ab16 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  800e61:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  800e65:	f7 d8                	neg    %eax
  800e67:	83 c4 10             	add    $0x10,%esp
  800e6a:	ba 05 00 00 00       	mov    $0x5,%edx
  800e6f:	83 f8 0e             	cmp    $0xe,%eax
  800e72:	77 07                	ja     800e7b <lwip_accept+0x9a>
  800e74:	8b 14 85 a0 0e 81 00 	mov    0x810ea0(,%eax,4),%edx
  800e7b:	89 56 10             	mov    %edx,0x10(%esi)
  800e7e:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800e84:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800e89:	e9 fa 00 00 00       	jmp    800f88 <lwip_accept+0x1a7>
  }

  memset(&sin, 0, sizeof(sin));
  800e8e:	83 ec 04             	sub    $0x4,%esp
  800e91:	6a 10                	push   $0x10
  800e93:	6a 00                	push   $0x0
  800e95:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800e98:	50                   	push   %eax
  800e99:	e8 5d dc 00 00       	call   80eafb <memset>
  sin.sin_len = sizeof(sin);
  800e9e:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800ea2:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800ea6:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800eaa:	89 04 24             	mov    %eax,(%esp)
  800ead:	e8 23 67 00 00       	call   8075d5 <htons>
  800eb2:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800eb6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800eb9:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  800ebc:	83 c4 10             	add    $0x10,%esp
  800ebf:	83 3f 10             	cmpl   $0x10,(%edi)
  800ec2:	76 06                	jbe    800eca <lwip_accept+0xe9>
    *addrlen = sizeof(sin);
  800ec4:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(addr, &sin, *addrlen);
  800eca:	83 ec 04             	sub    $0x4,%esp
  800ecd:	ff 37                	pushl  (%edi)
  800ecf:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800ed2:	50                   	push   %eax
  800ed3:	ff 75 0c             	pushl  0xc(%ebp)
  800ed6:	e8 d5 dc 00 00       	call   80ebb0 <memcpy>

  newsock = alloc_socket(newconn);
  800edb:	89 d8                	mov    %ebx,%eax
  800edd:	e8 a9 fb ff ff       	call   800a8b <alloc_socket>
  800ee2:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800ee4:	83 c4 10             	add    $0x10,%esp
  800ee7:	83 f8 ff             	cmp    $0xffffffff,%eax
  800eea:	75 24                	jne    800f10 <lwip_accept+0x12f>
    netconn_delete(newconn);
  800eec:	83 ec 0c             	sub    $0xc,%esp
  800eef:	53                   	push   %ebx
  800ef0:	e8 21 9c 00 00       	call   80ab16 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  800ef5:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  800efc:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  800f03:	00 00 00 
    return -1;
  800f06:	83 c4 10             	add    $0x10,%esp
  800f09:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800f0e:	eb 78                	jmp    800f88 <lwip_accept+0x1a7>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800f10:	83 f8 1f             	cmp    $0x1f,%eax
  800f13:	76 17                	jbe    800f2c <lwip_accept+0x14b>
  800f15:	83 ec 04             	sub    $0x4,%esp
  800f18:	68 f3 0d 81 00       	push   $0x810df3
  800f1d:	68 25 01 00 00       	push   $0x125
  800f22:	68 d0 0d 81 00       	push   $0x810dd0
  800f27:	e8 2c d4 00 00       	call   80e358 <_panic>
  newconn->callback = event_callback;
  800f2c:	c7 43 2c eb 08 80 00 	movl   $0x8008eb,0x2c(%ebx)
  nsock = &sockets[newsock];
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);

  sys_sem_wait(socksem);
  800f33:	83 ec 0c             	sub    $0xc,%esp
  800f36:	ff 35 44 50 81 00    	pushl  0x815044
  800f3c:	e8 a0 40 00 00       	call   804fe1 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  800f41:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  800f44:	8d 14 85 60 50 81 00 	lea    0x815060(,%eax,4),%edx
  800f4b:	0f b7 42 0a          	movzwl 0xa(%edx),%eax
  800f4f:	83 e8 01             	sub    $0x1,%eax
  800f52:	66 2b 43 1c          	sub    0x1c(%ebx),%ax
  800f56:	66 89 42 0a          	mov    %ax,0xa(%edx)
  newconn->socket = newsock;
  800f5a:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  800f5d:	83 c4 04             	add    $0x4,%esp
  800f60:	ff 35 44 50 81 00    	pushl  0x815044
  800f66:	e8 6c 8f 00 00       	call   809ed7 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  800f6b:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  800f72:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  800f79:	00 00 00 
  return newsock;
  800f7c:	83 c4 10             	add    $0x10,%esp
  800f7f:	89 f8                	mov    %edi,%eax
  800f81:	eb 05                	jmp    800f88 <lwip_accept+0x1a7>
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  if (!sock)
    return -1;
  800f83:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  return newsock;
}
  800f88:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800f8b:	5b                   	pop    %ebx
  800f8c:	5e                   	pop    %esi
  800f8d:	5f                   	pop    %edi
  800f8e:	5d                   	pop    %ebp
  800f8f:	c3                   	ret    

00800f90 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  800f90:	55                   	push   %ebp
  800f91:	89 e5                	mov    %esp,%ebp
  800f93:	56                   	push   %esi
  800f94:	53                   	push   %ebx
  800f95:	83 ec 10             	sub    $0x10,%esp
  800f98:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  800f9b:	8b 45 08             	mov    0x8(%ebp),%eax
  800f9e:	e8 4c f7 ff ff       	call   8006ef <get_socket>
  if (!sock)
  800fa3:	85 c0                	test   %eax,%eax
  800fa5:	0f 84 8f 00 00 00    	je     80103a <lwip_bind+0xaa>
  800fab:	89 c3                	mov    %eax,%ebx
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  800fad:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  800fb1:	75 06                	jne    800fb9 <lwip_bind+0x29>
  800fb3:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  800fb7:	74 17                	je     800fd0 <lwip_bind+0x40>
  800fb9:	83 ec 04             	sub    $0x4,%esp
  800fbc:	68 08 0e 81 00       	push   $0x810e08
  800fc1:	68 4a 01 00 00       	push   $0x14a
  800fc6:	68 d0 0d 81 00       	push   $0x810dd0
  800fcb:	e8 88 d3 00 00       	call   80e358 <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  800fd0:	8b 46 04             	mov    0x4(%esi),%eax
  800fd3:	89 45 f4             	mov    %eax,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  800fd6:	83 ec 0c             	sub    $0xc,%esp
  800fd9:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  800fdd:	50                   	push   %eax
  800fde:	e8 ff 65 00 00       	call   8075e2 <ntohs>
  800fe3:	83 c4 0c             	add    $0xc,%esp
  800fe6:	0f b7 c0             	movzwl %ax,%eax
  800fe9:	50                   	push   %eax
  800fea:	8d 45 f4             	lea    -0xc(%ebp),%eax
  800fed:	50                   	push   %eax
  800fee:	ff 33                	pushl  (%ebx)
  800ff0:	e8 15 9c 00 00       	call   80ac0a <netconn_bind>

  if (err != ERR_OK) {
  800ff5:	83 c4 10             	add    $0x10,%esp
  800ff8:	84 c0                	test   %al,%al
  800ffa:	74 26                	je     801022 <lwip_bind+0x92>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  800ffc:	0f be c0             	movsbl %al,%eax
  800fff:	f7 d8                	neg    %eax
  801001:	ba 05 00 00 00       	mov    $0x5,%edx
  801006:	83 f8 0e             	cmp    $0xe,%eax
  801009:	77 07                	ja     801012 <lwip_bind+0x82>
  80100b:	8b 14 85 a0 0e 81 00 	mov    0x810ea0(,%eax,4),%edx
  801012:	89 53 10             	mov    %edx,0x10(%ebx)
  801015:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80101b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801020:	eb 1d                	jmp    80103f <lwip_bind+0xaf>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  801022:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801029:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801030:	00 00 00 
  return 0;
  801033:	b8 00 00 00 00       	mov    $0x0,%eax
  801038:	eb 05                	jmp    80103f <lwip_bind+0xaf>
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  80103a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  80103f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801042:	5b                   	pop    %ebx
  801043:	5e                   	pop    %esi
  801044:	5d                   	pop    %ebp
  801045:	c3                   	ret    

00801046 <lwip_close>:

int
lwip_close(int s)
{
  801046:	55                   	push   %ebp
  801047:	89 e5                	mov    %esp,%ebp
  801049:	53                   	push   %ebx
  80104a:	83 ec 04             	sub    $0x4,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  80104d:	8b 45 08             	mov    0x8(%ebp),%eax
  801050:	e8 9a f6 ff ff       	call   8006ef <get_socket>
  if (!sock) {
  801055:	85 c0                	test   %eax,%eax
  801057:	74 6c                	je     8010c5 <lwip_close+0x7f>
  801059:	89 c3                	mov    %eax,%ebx
    return -1;
  }

  netconn_delete(sock->conn);
  80105b:	83 ec 0c             	sub    $0xc,%esp
  80105e:	ff 30                	pushl  (%eax)
  801060:	e8 b1 9a 00 00       	call   80ab16 <netconn_delete>

  sys_sem_wait(socksem);
  801065:	83 c4 04             	add    $0x4,%esp
  801068:	ff 35 44 50 81 00    	pushl  0x815044
  80106e:	e8 6e 3f 00 00       	call   804fe1 <sys_sem_wait>
  if (sock->lastdata) {
  801073:	8b 43 04             	mov    0x4(%ebx),%eax
  801076:	83 c4 10             	add    $0x10,%esp
  801079:	85 c0                	test   %eax,%eax
  80107b:	74 0c                	je     801089 <lwip_close+0x43>
    netbuf_delete(sock->lastdata);
  80107d:	83 ec 0c             	sub    $0xc,%esp
  801080:	50                   	push   %eax
  801081:	e8 6c 13 00 00       	call   8023f2 <netbuf_delete>
  801086:	83 c4 10             	add    $0x10,%esp
  }
  sock->lastdata   = NULL;
  801089:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  801090:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  801096:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  80109c:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8010a3:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8010aa:	00 00 00 
  sys_sem_signal(socksem);
  8010ad:	83 ec 0c             	sub    $0xc,%esp
  8010b0:	ff 35 44 50 81 00    	pushl  0x815044
  8010b6:	e8 1c 8e 00 00       	call   809ed7 <sys_sem_signal>
  return 0;
  8010bb:	83 c4 10             	add    $0x10,%esp
  8010be:	b8 00 00 00 00       	mov    $0x0,%eax
  8010c3:	eb 05                	jmp    8010ca <lwip_close+0x84>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  if (!sock) {
    return -1;
  8010c5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  sock->lastoffset = 0;
  sock->conn       = NULL;
  sock_set_errno(sock, 0);
  sys_sem_signal(socksem);
  return 0;
}
  8010ca:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8010cd:	c9                   	leave  
  8010ce:	c3                   	ret    

008010cf <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8010cf:	55                   	push   %ebp
  8010d0:	89 e5                	mov    %esp,%ebp
  8010d2:	56                   	push   %esi
  8010d3:	53                   	push   %ebx
  8010d4:	83 ec 10             	sub    $0x10,%esp
  8010d7:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  8010da:	8b 45 08             	mov    0x8(%ebp),%eax
  8010dd:	e8 0d f6 ff ff       	call   8006ef <get_socket>
  if (!sock)
  8010e2:	85 c0                	test   %eax,%eax
  8010e4:	0f 84 8f 00 00 00    	je     801179 <lwip_connect+0xaa>
  8010ea:	89 c3                	mov    %eax,%ebx
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8010ec:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  8010f0:	75 06                	jne    8010f8 <lwip_connect+0x29>
  8010f2:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8010f6:	74 17                	je     80110f <lwip_connect+0x40>
  8010f8:	83 ec 04             	sub    $0x4,%esp
  8010fb:	68 23 0e 81 00       	push   $0x810e23
  801100:	68 86 01 00 00       	push   $0x186
  801105:	68 d0 0d 81 00       	push   $0x810dd0
  80110a:	e8 49 d2 00 00       	call   80e358 <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80110f:	8b 46 04             	mov    0x4(%esi),%eax
  801112:	89 45 f4             	mov    %eax,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  801115:	83 ec 0c             	sub    $0xc,%esp
  801118:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80111c:	50                   	push   %eax
  80111d:	e8 c0 64 00 00       	call   8075e2 <ntohs>
  801122:	83 c4 0c             	add    $0xc,%esp
  801125:	0f b7 c0             	movzwl %ax,%eax
  801128:	50                   	push   %eax
  801129:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80112c:	50                   	push   %eax
  80112d:	ff 33                	pushl  (%ebx)
  80112f:	e8 27 9b 00 00       	call   80ac5b <netconn_connect>
  }

  if (err != ERR_OK) {
  801134:	83 c4 10             	add    $0x10,%esp
  801137:	84 c0                	test   %al,%al
  801139:	74 26                	je     801161 <lwip_connect+0x92>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80113b:	0f be c0             	movsbl %al,%eax
  80113e:	f7 d8                	neg    %eax
  801140:	ba 05 00 00 00       	mov    $0x5,%edx
  801145:	83 f8 0e             	cmp    $0xe,%eax
  801148:	77 07                	ja     801151 <lwip_connect+0x82>
  80114a:	8b 14 85 a0 0e 81 00 	mov    0x810ea0(,%eax,4),%edx
  801151:	89 53 10             	mov    %edx,0x10(%ebx)
  801154:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80115a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80115f:	eb 1d                	jmp    80117e <lwip_connect+0xaf>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  801161:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801168:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80116f:	00 00 00 
  return 0;
  801172:	b8 00 00 00 00       	mov    $0x0,%eax
  801177:	eb 05                	jmp    80117e <lwip_connect+0xaf>
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  801179:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  80117e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801181:	5b                   	pop    %ebx
  801182:	5e                   	pop    %esi
  801183:	5d                   	pop    %ebp
  801184:	c3                   	ret    

00801185 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  801185:	55                   	push   %ebp
  801186:	89 e5                	mov    %esp,%ebp
  801188:	56                   	push   %esi
  801189:	53                   	push   %ebx
  80118a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  80118d:	8b 45 08             	mov    0x8(%ebp),%eax
  801190:	e8 5a f5 ff ff       	call   8006ef <get_socket>
  if (!sock)
  801195:	85 c0                	test   %eax,%eax
  801197:	74 6d                	je     801206 <lwip_listen+0x81>
  801199:	89 c6                	mov    %eax,%esi
  80119b:	85 db                	test   %ebx,%ebx
  80119d:	b8 00 00 00 00       	mov    $0x0,%eax
  8011a2:	0f 48 d8             	cmovs  %eax,%ebx
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  8011a5:	83 ec 08             	sub    $0x8,%esp
  8011a8:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  8011ae:	b8 ff 00 00 00       	mov    $0xff,%eax
  8011b3:	0f 4f d8             	cmovg  %eax,%ebx
  8011b6:	0f b6 db             	movzbl %bl,%ebx
  8011b9:	53                   	push   %ebx
  8011ba:	ff 36                	pushl  (%esi)
  8011bc:	e8 2f 9b 00 00       	call   80acf0 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  8011c1:	83 c4 10             	add    $0x10,%esp
  8011c4:	84 c0                	test   %al,%al
  8011c6:	74 26                	je     8011ee <lwip_listen+0x69>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8011c8:	0f be c0             	movsbl %al,%eax
  8011cb:	f7 d8                	neg    %eax
  8011cd:	ba 05 00 00 00       	mov    $0x5,%edx
  8011d2:	83 f8 0e             	cmp    $0xe,%eax
  8011d5:	77 07                	ja     8011de <lwip_listen+0x59>
  8011d7:	8b 14 85 a0 0e 81 00 	mov    0x810ea0(,%eax,4),%edx
  8011de:	89 56 10             	mov    %edx,0x10(%esi)
  8011e1:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  8011e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8011ec:	eb 1d                	jmp    80120b <lwip_listen+0x86>
  }

  sock_set_errno(sock, 0);
  8011ee:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8011f5:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8011fc:	00 00 00 
  return 0;
  8011ff:	b8 00 00 00 00       	mov    $0x0,%eax
  801204:	eb 05                	jmp    80120b <lwip_listen+0x86>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  if (!sock)
    return -1;
  801206:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  }

  sock_set_errno(sock, 0);
  return 0;
}
  80120b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80120e:	5b                   	pop    %ebx
  80120f:	5e                   	pop    %esi
  801210:	5d                   	pop    %ebp
  801211:	c3                   	ret    

00801212 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  801212:	55                   	push   %ebp
  801213:	89 e5                	mov    %esp,%ebp
  801215:	57                   	push   %edi
  801216:	56                   	push   %esi
  801217:	53                   	push   %ebx
  801218:	83 ec 4c             	sub    $0x4c,%esp
  80121b:	8b 5d 14             	mov    0x14(%ebp),%ebx
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  80121e:	8b 45 08             	mov    0x8(%ebp),%eax
  801221:	e8 c9 f4 ff ff       	call   8006ef <get_socket>
  if (!sock)
  801226:	85 c0                	test   %eax,%eax
  801228:	0f 84 04 02 00 00    	je     801432 <lwip_recvfrom+0x220>
  80122e:	89 c7                	mov    %eax,%edi
  801230:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801236:	89 d8                	mov    %ebx,%eax
  801238:	83 e0 08             	and    $0x8,%eax
  80123b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  80123e:	83 e3 01             	and    $0x1,%ebx
  801241:	89 5d b8             	mov    %ebx,-0x48(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  801244:	8b 77 04             	mov    0x4(%edi),%esi
  801247:	85 f6                	test   %esi,%esi
  801249:	0f 85 80 00 00 00    	jne    8012cf <lwip_recvfrom+0xbd>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80124f:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801253:	75 06                	jne    80125b <lwip_recvfrom+0x49>
  801255:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  801259:	74 22                	je     80127d <lwip_recvfrom+0x6b>
  80125b:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801260:	75 1b                	jne    80127d <lwip_recvfrom+0x6b>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  801262:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  801269:	c7 05 e0 b1 b3 00 0b 	movl   $0xb,0xb3b1e0
  801270:	00 00 00 
        return -1;
  801273:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801278:	e9 ba 01 00 00       	jmp    801437 <lwip_recvfrom+0x225>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  80127d:	83 ec 0c             	sub    $0xc,%esp
  801280:	ff 37                	pushl  (%edi)
  801282:	e8 1f 9b 00 00       	call   80ada6 <netconn_recv>
  801287:	89 c6                	mov    %eax,%esi
  801289:	89 47 04             	mov    %eax,0x4(%edi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  80128c:	83 c4 10             	add    $0x10,%esp
  80128f:	85 c0                	test   %eax,%eax
  801291:	75 3c                	jne    8012cf <lwip_recvfrom+0xbd>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  801293:	8b 17                	mov    (%edi),%edx
  801295:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  801299:	74 0b                	je     8012a6 <lwip_recvfrom+0x94>
  80129b:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8012a0:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  8012a4:	74 17                	je     8012bd <lwip_recvfrom+0xab>
  8012a6:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  8012aa:	f7 da                	neg    %edx
  8012ac:	b8 05 00 00 00       	mov    $0x5,%eax
  8012b1:	83 fa 0e             	cmp    $0xe,%edx
  8012b4:	77 07                	ja     8012bd <lwip_recvfrom+0xab>
  8012b6:	8b 04 95 a0 0e 81 00 	mov    0x810ea0(,%edx,4),%eax
  8012bd:	89 47 10             	mov    %eax,0x10(%edi)
  8012c0:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
        return 0;
  8012c5:	b8 00 00 00 00       	mov    $0x0,%eax
  8012ca:	e9 68 01 00 00       	jmp    801437 <lwip_recvfrom+0x225>
      }
    }

    buflen = netbuf_len(buf);
  8012cf:	8b 16                	mov    (%esi),%edx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  8012d1:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8012d5:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  8012d9:	29 c3                	sub    %eax,%ebx

    if (len > buflen) {
  8012db:	0f b7 cb             	movzwl %bx,%ecx
  8012de:	89 4d bc             	mov    %ecx,-0x44(%ebp)
      copylen = buflen;
    } else {
      copylen = len;
  8012e1:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  8012e4:	66 0f 4e 5d 10       	cmovle 0x10(%ebp),%bx
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  8012e9:	0f b7 cb             	movzwl %bx,%ecx
  8012ec:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  8012ef:	0f b7 c0             	movzwl %ax,%eax
  8012f2:	50                   	push   %eax
  8012f3:	51                   	push   %ecx
  8012f4:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  8012f8:	03 45 0c             	add    0xc(%ebp),%eax
  8012fb:	50                   	push   %eax
  8012fc:	52                   	push   %edx
  8012fd:	e8 72 3b 00 00       	call   804e74 <pbuf_copy_partial>

    off += copylen;
  801302:	66 01 5d c4          	add    %bx,-0x3c(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801306:	83 c4 04             	add    $0x4,%esp
  801309:	ff 37                	pushl  (%edi)
  80130b:	e8 46 98 00 00       	call   80ab56 <netconn_type>
  801310:	83 c4 10             	add    $0x10,%esp
      len -= copylen;
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
        done = 1;
      }
    } else {
      done = 1;
  801313:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);

    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801317:	83 f8 10             	cmp    $0x10,%eax
  80131a:	75 1d                	jne    801339 <lwip_recvfrom+0x127>
      len -= copylen;
  80131c:	8b 45 c0             	mov    -0x40(%ebp),%eax
  80131f:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  801322:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801326:	7e 11                	jle    801339 <lwip_recvfrom+0x127>
  801328:	8b 06                	mov    (%esi),%eax
  80132a:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  80132e:	75 09                	jne    801339 <lwip_recvfrom+0x127>
        done = 1;
  801330:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801335:	0f 94 45 c7          	sete   -0x39(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  801339:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  80133d:	75 3d                	jne    80137c <lwip_recvfrom+0x16a>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  80133f:	8b 07                	mov    (%edi),%eax
  801341:	83 38 10             	cmpl   $0x10,(%eax)
  801344:	75 13                	jne    801359 <lwip_recvfrom+0x147>
  801346:	8b 45 bc             	mov    -0x44(%ebp),%eax
  801349:	2b 45 c0             	sub    -0x40(%ebp),%eax
  80134c:	85 c0                	test   %eax,%eax
  80134e:	7e 09                	jle    801359 <lwip_recvfrom+0x147>
        sock->lastdata = buf;
  801350:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  801353:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  801357:	eb 19                	jmp    801372 <lwip_recvfrom+0x160>
      } else {
        sock->lastdata = NULL;
  801359:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  801360:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  801366:	83 ec 0c             	sub    $0xc,%esp
  801369:	56                   	push   %esi
  80136a:	e8 83 10 00 00       	call   8023f2 <netbuf_delete>
  80136f:	83 c4 10             	add    $0x10,%esp
      }
    } else {
      done = 1;
    }
  } while (!done);
  801372:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  801376:	0f 84 c8 fe ff ff    	je     801244 <lwip_recvfrom+0x32>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  80137c:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801380:	0f 84 95 00 00 00    	je     80141b <lwip_recvfrom+0x209>
  801386:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80138a:	0f 84 8b 00 00 00    	je     80141b <lwip_recvfrom+0x209>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801390:	83 ec 0c             	sub    $0xc,%esp
  801393:	ff 37                	pushl  (%edi)
  801395:	e8 bc 97 00 00       	call   80ab56 <netconn_type>
  80139a:	83 c4 10             	add    $0x10,%esp
  80139d:	83 f8 10             	cmp    $0x10,%eax
  8013a0:	75 19                	jne    8013bb <lwip_recvfrom+0x1a9>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
      netconn_getaddr(sock->conn, addr, &port, 0);
  8013a2:	6a 00                	push   $0x0
  8013a4:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  8013a7:	50                   	push   %eax
  8013a8:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8013ab:	50                   	push   %eax
  8013ac:	ff 37                	pushl  (%edi)
  8013ae:	e8 cb 97 00 00       	call   80ab7e <netconn_getaddr>
  8013b3:	83 c4 10             	add    $0x10,%esp
  /* Check to see from where the data was.*/
  if (from && fromlen) {
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  8013b6:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  8013b9:	eb 0b                	jmp    8013c6 <lwip_recvfrom+0x1b4>
      netconn_getaddr(sock->conn, addr, &port, 0);
    } else {
      addr = netbuf_fromaddr(buf);
  8013bb:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  8013be:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8013c2:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  8013c6:	83 ec 04             	sub    $0x4,%esp
  8013c9:	6a 10                	push   $0x10
  8013cb:	6a 00                	push   $0x0
  8013cd:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8013d0:	50                   	push   %eax
  8013d1:	e8 25 d7 00 00       	call   80eafb <memset>
    sin.sin_len = sizeof(sin);
  8013d6:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  8013da:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  8013de:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8013e2:	89 04 24             	mov    %eax,(%esp)
  8013e5:	e8 eb 61 00 00       	call   8075d5 <htons>
  8013ea:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  8013ee:	8b 03                	mov    (%ebx),%eax
  8013f0:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  8013f3:	83 c4 10             	add    $0x10,%esp
  8013f6:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8013f9:	83 38 10             	cmpl   $0x10,(%eax)
  8013fc:	76 06                	jbe    801404 <lwip_recvfrom+0x1f2>
      *fromlen = sizeof(sin);
  8013fe:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

    SMEMCPY(from, &sin, *fromlen);
  801404:	83 ec 04             	sub    $0x4,%esp
  801407:	8b 45 1c             	mov    0x1c(%ebp),%eax
  80140a:	ff 30                	pushl  (%eax)
  80140c:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80140f:	50                   	push   %eax
  801410:	ff 75 18             	pushl  0x18(%ebp)
  801413:	e8 98 d7 00 00       	call   80ebb0 <memcpy>
  801418:	83 c4 10             	add    $0x10,%esp
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  80141b:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  801422:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801429:	00 00 00 
  return off;
  80142c:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  801430:	eb 05                	jmp    801437 <lwip_recvfrom+0x225>
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  if (!sock)
    return -1;
  801432:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  return off;
}
  801437:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80143a:	5b                   	pop    %ebx
  80143b:	5e                   	pop    %esi
  80143c:	5f                   	pop    %edi
  80143d:	5d                   	pop    %ebp
  80143e:	c3                   	ret    

0080143f <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  80143f:	55                   	push   %ebp
  801440:	89 e5                	mov    %esp,%ebp
  801442:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  801445:	6a 00                	push   $0x0
  801447:	6a 00                	push   $0x0
  801449:	6a 00                	push   $0x0
  80144b:	ff 75 10             	pushl  0x10(%ebp)
  80144e:	ff 75 0c             	pushl  0xc(%ebp)
  801451:	ff 75 08             	pushl  0x8(%ebp)
  801454:	e8 b9 fd ff ff       	call   801212 <lwip_recvfrom>
}
  801459:	c9                   	leave  
  80145a:	c3                   	ret    

0080145b <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  80145b:	55                   	push   %ebp
  80145c:	89 e5                	mov    %esp,%ebp
  80145e:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  801461:	6a 00                	push   $0x0
  801463:	6a 00                	push   $0x0
  801465:	ff 75 14             	pushl  0x14(%ebp)
  801468:	ff 75 10             	pushl  0x10(%ebp)
  80146b:	ff 75 0c             	pushl  0xc(%ebp)
  80146e:	ff 75 08             	pushl  0x8(%ebp)
  801471:	e8 9c fd ff ff       	call   801212 <lwip_recvfrom>
}
  801476:	c9                   	leave  
  801477:	c3                   	ret    

00801478 <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  801478:	55                   	push   %ebp
  801479:	89 e5                	mov    %esp,%ebp
  80147b:	57                   	push   %edi
  80147c:	56                   	push   %esi
  80147d:	53                   	push   %ebx
  80147e:	83 ec 2c             	sub    $0x2c,%esp
  801481:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801484:	8b 75 18             	mov    0x18(%ebp),%esi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  801487:	8b 45 08             	mov    0x8(%ebp),%eax
  80148a:	e8 60 f2 ff ff       	call   8006ef <get_socket>
  if (!sock)
  80148f:	85 c0                	test   %eax,%eax
  801491:	0f 84 21 01 00 00    	je     8015b8 <lwip_sendto+0x140>
  801497:	89 c7                	mov    %eax,%edi
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  801499:	8b 00                	mov    (%eax),%eax
  80149b:	83 38 10             	cmpl   $0x10,(%eax)
  80149e:	75 17                	jne    8014b7 <lwip_sendto+0x3f>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  8014a0:	ff 75 14             	pushl  0x14(%ebp)
  8014a3:	53                   	push   %ebx
  8014a4:	ff 75 0c             	pushl  0xc(%ebp)
  8014a7:	ff 75 08             	pushl  0x8(%ebp)
  8014aa:	e8 16 01 00 00       	call   8015c5 <lwip_send>
  8014af:	83 c4 10             	add    $0x10,%esp
  8014b2:	e9 06 01 00 00       	jmp    8015bd <lwip_sendto+0x145>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8014b7:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  8014bd:	76 17                	jbe    8014d6 <lwip_sendto+0x5e>
  8014bf:	83 ec 04             	sub    $0x4,%esp
  8014c2:	68 60 0e 81 00       	push   $0x810e60
  8014c7:	68 97 02 00 00       	push   $0x297
  8014cc:	68 d0 0d 81 00       	push   $0x810dd0
  8014d1:	e8 82 ce 00 00       	call   80e358 <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8014d6:	85 f6                	test   %esi,%esi
  8014d8:	75 06                	jne    8014e0 <lwip_sendto+0x68>
  8014da:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8014de:	74 23                	je     801503 <lwip_sendto+0x8b>
  8014e0:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8014e4:	75 06                	jne    8014ec <lwip_sendto+0x74>
  8014e6:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8014ea:	74 17                	je     801503 <lwip_sendto+0x8b>
  8014ec:	83 ec 04             	sub    $0x4,%esp
  8014ef:	68 41 0e 81 00       	push   $0x810e41
  8014f4:	68 9b 02 00 00       	push   $0x29b
  8014f9:	68 d0 0d 81 00       	push   $0x810dd0
  8014fe:	e8 55 ce 00 00       	call   80e358 <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  801503:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80150a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  801511:	85 f6                	test   %esi,%esi
  801513:	74 22                	je     801537 <lwip_sendto+0xbf>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  801515:	8b 46 04             	mov    0x4(%esi),%eax
  801518:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  80151b:	83 ec 0c             	sub    $0xc,%esp
  80151e:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801522:	50                   	push   %eax
  801523:	e8 ba 60 00 00       	call   8075e2 <ntohs>
    buf.addr         = &remote_addr;
  801528:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80152b:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  80152e:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  801532:	83 c4 10             	add    $0x10,%esp
  801535:	eb 14                	jmp    80154b <lwip_sendto+0xd3>
  } else {
    remote_addr.addr = 0;
  801537:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  80153e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  801545:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  80154b:	83 ec 04             	sub    $0x4,%esp
  80154e:	0f b7 c3             	movzwl %bx,%eax
  801551:	50                   	push   %eax
  801552:	ff 75 0c             	pushl  0xc(%ebp)
  801555:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801558:	50                   	push   %eax
  801559:	e8 96 0f 00 00       	call   8024f4 <netbuf_ref>
  80155e:	0f be f0             	movsbl %al,%esi
  801561:	83 c4 10             	add    $0x10,%esp
  801564:	85 f6                	test   %esi,%esi
  801566:	75 14                	jne    80157c <lwip_sendto+0x104>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  801568:	83 ec 08             	sub    $0x8,%esp
  80156b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80156e:	50                   	push   %eax
  80156f:	ff 37                	pushl  (%edi)
  801571:	e8 d2 99 00 00       	call   80af48 <netconn_send>
  801576:	0f be f0             	movsbl %al,%esi
  801579:	83 c4 10             	add    $0x10,%esp
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  80157c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80157f:	85 c0                	test   %eax,%eax
  801581:	74 0c                	je     80158f <lwip_sendto+0x117>
    pbuf_free(buf.p);
  801583:	83 ec 0c             	sub    $0xc,%esp
  801586:	50                   	push   %eax
  801587:	e8 98 31 00 00       	call   804724 <pbuf_free>
  80158c:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  80158f:	89 f2                	mov    %esi,%edx
  801591:	f7 da                	neg    %edx
  801593:	b8 05 00 00 00       	mov    $0x5,%eax
  801598:	83 fa 0e             	cmp    $0xe,%edx
  80159b:	77 07                	ja     8015a4 <lwip_sendto+0x12c>
  80159d:	8b 04 95 a0 0e 81 00 	mov    0x810ea0(,%edx,4),%eax
  8015a4:	89 47 10             	mov    %eax,0x10(%edi)
  8015a7:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return (err==ERR_OK?size:-1);
  8015ac:	85 f6                	test   %esi,%esi
  8015ae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8015b3:	0f 44 c3             	cmove  %ebx,%eax
  8015b6:	eb 05                	jmp    8015bd <lwip_sendto+0x145>
  u16_t remote_port;
#endif

  sock = get_socket(s);
  if (!sock)
    return -1;
  8015b8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    pbuf_free(buf.p);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  8015bd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8015c0:	5b                   	pop    %ebx
  8015c1:	5e                   	pop    %esi
  8015c2:	5f                   	pop    %edi
  8015c3:	5d                   	pop    %ebp
  8015c4:	c3                   	ret    

008015c5 <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  8015c5:	55                   	push   %ebp
  8015c6:	89 e5                	mov    %esp,%ebp
  8015c8:	57                   	push   %edi
  8015c9:	56                   	push   %esi
  8015ca:	53                   	push   %ebx
  8015cb:	83 ec 0c             	sub    $0xc,%esp
  8015ce:	8b 7d 08             	mov    0x8(%ebp),%edi
  8015d1:	8b 5d 10             	mov    0x10(%ebp),%ebx
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  8015d4:	89 f8                	mov    %edi,%eax
  8015d6:	e8 14 f1 ff ff       	call   8006ef <get_socket>
  if (!sock)
  8015db:	85 c0                	test   %eax,%eax
  8015dd:	74 6c                	je     80164b <lwip_send+0x86>
  8015df:	89 c6                	mov    %eax,%esi
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  8015e1:	8b 10                	mov    (%eax),%edx
  8015e3:	83 3a 10             	cmpl   $0x10,(%edx)
  8015e6:	74 19                	je     801601 <lwip_send+0x3c>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  8015e8:	83 ec 08             	sub    $0x8,%esp
  8015eb:	6a 00                	push   $0x0
  8015ed:	6a 00                	push   $0x0
  8015ef:	ff 75 14             	pushl  0x14(%ebp)
  8015f2:	53                   	push   %ebx
  8015f3:	ff 75 0c             	pushl  0xc(%ebp)
  8015f6:	57                   	push   %edi
  8015f7:	e8 7c fe ff ff       	call   801478 <lwip_sendto>
  8015fc:	83 c4 20             	add    $0x20,%esp
  8015ff:	eb 4f                	jmp    801650 <lwip_send+0x8b>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801601:	8b 45 14             	mov    0x14(%ebp),%eax
  801604:	83 e0 10             	and    $0x10,%eax
  801607:	83 f8 01             	cmp    $0x1,%eax
  80160a:	19 c0                	sbb    %eax,%eax
  80160c:	83 e0 fe             	and    $0xfffffffe,%eax
  80160f:	83 c0 03             	add    $0x3,%eax
  801612:	50                   	push   %eax
  801613:	53                   	push   %ebx
  801614:	ff 75 0c             	pushl  0xc(%ebp)
  801617:	52                   	push   %edx
  801618:	e8 a7 99 00 00       	call   80afc4 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  80161d:	0f be d0             	movsbl %al,%edx
  801620:	f7 da                	neg    %edx
  801622:	83 c4 10             	add    $0x10,%esp
  801625:	b9 05 00 00 00       	mov    $0x5,%ecx
  80162a:	83 fa 0e             	cmp    $0xe,%edx
  80162d:	77 07                	ja     801636 <lwip_send+0x71>
  80162f:	8b 0c 95 a0 0e 81 00 	mov    0x810ea0(,%edx,4),%ecx
  801636:	89 4e 10             	mov    %ecx,0x10(%esi)
  801639:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
  return (err==ERR_OK?size:-1);
  80163f:	84 c0                	test   %al,%al
  801641:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801646:	0f 44 c3             	cmove  %ebx,%eax
  801649:	eb 05                	jmp    801650 <lwip_send+0x8b>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  if (!sock)
    return -1;
  80164b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  801650:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801653:	5b                   	pop    %ebx
  801654:	5e                   	pop    %esi
  801655:	5f                   	pop    %edi
  801656:	5d                   	pop    %ebp
  801657:	c3                   	ret    

00801658 <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  801658:	55                   	push   %ebp
  801659:	89 e5                	mov    %esp,%ebp
  80165b:	53                   	push   %ebx
  80165c:	83 ec 04             	sub    $0x4,%esp
  80165f:	8b 45 0c             	mov    0xc(%ebp),%eax
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  801662:	83 f8 02             	cmp    $0x2,%eax
  801665:	74 27                	je     80168e <lwip_socket+0x36>
  801667:	83 f8 03             	cmp    $0x3,%eax
  80166a:	74 07                	je     801673 <lwip_socket+0x1b>
  80166c:	83 f8 01             	cmp    $0x1,%eax
  80166f:	75 5c                	jne    8016cd <lwip_socket+0x75>
  801671:	eb 42                	jmp    8016b5 <lwip_socket+0x5d>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  801673:	83 ec 04             	sub    $0x4,%esp
  801676:	68 eb 08 80 00       	push   $0x8008eb
  80167b:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  80167f:	50                   	push   %eax
  801680:	6a 40                	push   $0x40
  801682:	e8 a1 93 00 00       	call   80aa28 <netconn_new_with_proto_and_callback>
  801687:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  801689:	83 c4 10             	add    $0x10,%esp
  80168c:	eb 50                	jmp    8016de <lwip_socket+0x86>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  80168e:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  801695:	0f 94 c0             	sete   %al
  801698:	0f b6 c0             	movzbl %al,%eax
  80169b:	83 c0 20             	add    $0x20,%eax
  80169e:	83 ec 04             	sub    $0x4,%esp
  8016a1:	68 eb 08 80 00       	push   $0x8008eb
  8016a6:	6a 00                	push   $0x0
  8016a8:	50                   	push   %eax
  8016a9:	e8 7a 93 00 00       	call   80aa28 <netconn_new_with_proto_and_callback>
  8016ae:	89 c3                	mov    %eax,%ebx
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8016b0:	83 c4 10             	add    $0x10,%esp
  8016b3:	eb 29                	jmp    8016de <lwip_socket+0x86>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8016b5:	83 ec 04             	sub    $0x4,%esp
  8016b8:	68 eb 08 80 00       	push   $0x8008eb
  8016bd:	6a 00                	push   $0x0
  8016bf:	6a 10                	push   $0x10
  8016c1:	e8 62 93 00 00       	call   80aa28 <netconn_new_with_proto_and_callback>
  8016c6:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8016c8:	83 c4 10             	add    $0x10,%esp
  8016cb:	eb 11                	jmp    8016de <lwip_socket+0x86>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  8016cd:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  8016d4:	00 00 00 
    return -1;
  8016d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8016dc:	eb 4b                	jmp    801729 <lwip_socket+0xd1>
  }

  if (!conn) {
  8016de:	85 db                	test   %ebx,%ebx
  8016e0:	75 11                	jne    8016f3 <lwip_socket+0x9b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  8016e2:	c7 05 e0 b1 b3 00 69 	movl   $0x69,0xb3b1e0
  8016e9:	00 00 00 
    return -1;
  8016ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8016f1:	eb 36                	jmp    801729 <lwip_socket+0xd1>
  }

  i = alloc_socket(conn);
  8016f3:	89 d8                	mov    %ebx,%eax
  8016f5:	e8 91 f3 ff ff       	call   800a8b <alloc_socket>

  if (i == -1) {
  8016fa:	83 f8 ff             	cmp    $0xffffffff,%eax
  8016fd:	75 1d                	jne    80171c <lwip_socket+0xc4>
    netconn_delete(conn);
  8016ff:	83 ec 0c             	sub    $0xc,%esp
  801702:	53                   	push   %ebx
  801703:	e8 0e 94 00 00       	call   80ab16 <netconn_delete>
    set_errno(ENFILE);
  801708:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  80170f:	00 00 00 
    return -1;
  801712:	83 c4 10             	add    $0x10,%esp
  801715:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80171a:	eb 0d                	jmp    801729 <lwip_socket+0xd1>
  }
  conn->socket = i;
  80171c:	89 43 1c             	mov    %eax,0x1c(%ebx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  80171f:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801726:	00 00 00 
  return i;
}
  801729:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80172c:	c9                   	leave  
  80172d:	c3                   	ret    

0080172e <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  80172e:	55                   	push   %ebp
  80172f:	89 e5                	mov    %esp,%ebp
  801731:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  801734:	6a 00                	push   $0x0
  801736:	ff 75 10             	pushl  0x10(%ebp)
  801739:	ff 75 0c             	pushl  0xc(%ebp)
  80173c:	ff 75 08             	pushl  0x8(%ebp)
  80173f:	e8 81 fe ff ff       	call   8015c5 <lwip_send>
}
  801744:	c9                   	leave  
  801745:	c3                   	ret    

00801746 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  801746:	55                   	push   %ebp
  801747:	89 e5                	mov    %esp,%ebp
  801749:	57                   	push   %edi
  80174a:	56                   	push   %esi
  80174b:	53                   	push   %ebx
  80174c:	83 ec 58             	sub    $0x58,%esp
  80174f:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801752:	8b 75 10             	mov    0x10(%ebp),%esi
  801755:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  801758:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  80175f:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  801762:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  801765:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  801768:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  80176f:	ff 35 40 50 81 00    	pushl  0x815040
  801775:	e8 67 38 00 00       	call   804fe1 <sys_sem_wait>

  if (readset)
  80177a:	83 c4 10             	add    $0x10,%esp
  80177d:	85 ff                	test   %edi,%edi
  80177f:	74 07                	je     801788 <lwip_select+0x42>
    lreadset = *readset;
  801781:	8b 07                	mov    (%edi),%eax
  801783:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801786:	eb 13                	jmp    80179b <lwip_select+0x55>
  else
    FD_ZERO(&lreadset);
  801788:	83 ec 04             	sub    $0x4,%esp
  80178b:	6a 04                	push   $0x4
  80178d:	6a 00                	push   $0x0
  80178f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801792:	50                   	push   %eax
  801793:	e8 63 d3 00 00       	call   80eafb <memset>
  801798:	83 c4 10             	add    $0x10,%esp
  if (writeset)
  80179b:	85 f6                	test   %esi,%esi
  80179d:	74 07                	je     8017a6 <lwip_select+0x60>
    lwriteset = *writeset;
  80179f:	8b 06                	mov    (%esi),%eax
  8017a1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8017a4:	eb 13                	jmp    8017b9 <lwip_select+0x73>
  else
    FD_ZERO(&lwriteset);
  8017a6:	83 ec 04             	sub    $0x4,%esp
  8017a9:	6a 04                	push   $0x4
  8017ab:	6a 00                	push   $0x0
  8017ad:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8017b0:	50                   	push   %eax
  8017b1:	e8 45 d3 00 00       	call   80eafb <memset>
  8017b6:	83 c4 10             	add    $0x10,%esp
  if (exceptset)
  8017b9:	85 db                	test   %ebx,%ebx
  8017bb:	74 07                	je     8017c4 <lwip_select+0x7e>
    lexceptset = *exceptset;
  8017bd:	8b 03                	mov    (%ebx),%eax
  8017bf:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8017c2:	eb 13                	jmp    8017d7 <lwip_select+0x91>
  else
    FD_ZERO(&lexceptset);
  8017c4:	83 ec 04             	sub    $0x4,%esp
  8017c7:	6a 04                	push   $0x4
  8017c9:	6a 00                	push   $0x0
  8017cb:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8017ce:	50                   	push   %eax
  8017cf:	e8 27 d3 00 00       	call   80eafb <memset>
  8017d4:	83 c4 10             	add    $0x10,%esp

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8017d7:	83 ec 0c             	sub    $0xc,%esp
  8017da:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8017dd:	50                   	push   %eax
  8017de:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  8017e1:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8017e4:	8b 45 08             	mov    0x8(%ebp),%eax
  8017e7:	e8 4e ef ff ff       	call   80073a <lwip_selscan>
  8017ec:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  8017ef:	83 c4 10             	add    $0x10,%esp
  8017f2:	85 c0                	test   %eax,%eax
  8017f4:	0f 85 b5 01 00 00    	jne    8019af <lwip_select+0x269>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  8017fa:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8017fe:	0f 84 4f 02 00 00    	je     801a53 <lwip_select+0x30d>
  801804:	8b 45 18             	mov    0x18(%ebp),%eax
  801807:	83 38 00             	cmpl   $0x0,(%eax)
  80180a:	0f 85 dd 01 00 00    	jne    8019ed <lwip_select+0x2a7>
  801810:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  801814:	0f 85 d3 01 00 00    	jne    8019ed <lwip_select+0x2a7>
      sys_sem_signal(selectsem);
  80181a:	83 ec 0c             	sub    $0xc,%esp
  80181d:	ff 35 40 50 81 00    	pushl  0x815040
  801823:	e8 af 86 00 00       	call   809ed7 <sys_sem_signal>
      if (readset)
  801828:	83 c4 10             	add    $0x10,%esp
  80182b:	85 ff                	test   %edi,%edi
  80182d:	74 10                	je     80183f <lwip_select+0xf9>
        FD_ZERO(readset);
  80182f:	83 ec 04             	sub    $0x4,%esp
  801832:	6a 04                	push   $0x4
  801834:	6a 00                	push   $0x0
  801836:	57                   	push   %edi
  801837:	e8 bf d2 00 00       	call   80eafb <memset>
  80183c:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  80183f:	85 f6                	test   %esi,%esi
  801841:	74 10                	je     801853 <lwip_select+0x10d>
        FD_ZERO(writeset);
  801843:	83 ec 04             	sub    $0x4,%esp
  801846:	6a 04                	push   $0x4
  801848:	6a 00                	push   $0x0
  80184a:	56                   	push   %esi
  80184b:	e8 ab d2 00 00       	call   80eafb <memset>
  801850:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801853:	85 db                	test   %ebx,%ebx
  801855:	74 10                	je     801867 <lwip_select+0x121>
        FD_ZERO(exceptset);
  801857:	83 ec 04             	sub    $0x4,%esp
  80185a:	6a 04                	push   $0x4
  80185c:	6a 00                	push   $0x0
  80185e:	53                   	push   %ebx
  80185f:	e8 97 d2 00 00       	call   80eafb <memset>
  801864:	83 c4 10             	add    $0x10,%esp
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  801867:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80186e:	00 00 00 
  
      return 0;
  801871:	b8 00 00 00 00       	mov    $0x0,%eax
  801876:	e9 10 02 00 00       	jmp    801a8b <lwip_select+0x345>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  80187b:	83 ec 08             	sub    $0x8,%esp
  80187e:	52                   	push   %edx
  80187f:	ff 75 d8             	pushl  -0x28(%ebp)
  801882:	e8 19 39 00 00       	call   8051a0 <sys_sem_wait_timeout>
  801887:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  80188a:	83 c4 04             	add    $0x4,%esp
  80188d:	ff 35 40 50 81 00    	pushl  0x815040
  801893:	e8 49 37 00 00       	call   804fe1 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  801898:	a1 48 50 81 00       	mov    0x815048,%eax
  80189d:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  8018a0:	83 c4 10             	add    $0x10,%esp
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  8018a3:	89 d1                	mov    %edx,%ecx
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
  8018a5:	39 d0                	cmp    %edx,%eax
  8018a7:	75 19                	jne    8018c2 <lwip_select+0x17c>
      select_cb_list = select_cb.next;
  8018a9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  8018ac:	a3 48 50 81 00       	mov    %eax,0x815048
  8018b1:	eb 13                	jmp    8018c6 <lwip_select+0x180>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  8018b3:	8b 10                	mov    (%eax),%edx
  8018b5:	39 ca                	cmp    %ecx,%edx
  8018b7:	75 07                	jne    8018c0 <lwip_select+0x17a>
          p_selcb->next = select_cb.next;
  8018b9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  8018bc:	89 10                	mov    %edx,(%eax)
          break;
  8018be:	eb 06                	jmp    8018c6 <lwip_select+0x180>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8018c0:	89 d0                	mov    %edx,%eax
  8018c2:	85 c0                	test   %eax,%eax
  8018c4:	75 ed                	jne    8018b3 <lwip_select+0x16d>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  8018c6:	83 ec 0c             	sub    $0xc,%esp
  8018c9:	ff 35 40 50 81 00    	pushl  0x815040
  8018cf:	e8 03 86 00 00       	call   809ed7 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  8018d4:	83 c4 04             	add    $0x4,%esp
  8018d7:	ff 75 d8             	pushl  -0x28(%ebp)
  8018da:	e8 cd 83 00 00       	call   809cac <sys_sem_free>
    if (i == 0)  {
  8018df:	83 c4 10             	add    $0x10,%esp
  8018e2:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8018e6:	75 50                	jne    801938 <lwip_select+0x1f2>
      /* Timeout */
      if (readset)
  8018e8:	85 ff                	test   %edi,%edi
  8018ea:	74 10                	je     8018fc <lwip_select+0x1b6>
        FD_ZERO(readset);
  8018ec:	83 ec 04             	sub    $0x4,%esp
  8018ef:	6a 04                	push   $0x4
  8018f1:	6a 00                	push   $0x0
  8018f3:	57                   	push   %edi
  8018f4:	e8 02 d2 00 00       	call   80eafb <memset>
  8018f9:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  8018fc:	85 f6                	test   %esi,%esi
  8018fe:	74 10                	je     801910 <lwip_select+0x1ca>
        FD_ZERO(writeset);
  801900:	83 ec 04             	sub    $0x4,%esp
  801903:	6a 04                	push   $0x4
  801905:	6a 00                	push   $0x0
  801907:	56                   	push   %esi
  801908:	e8 ee d1 00 00       	call   80eafb <memset>
  80190d:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801910:	85 db                	test   %ebx,%ebx
  801912:	74 10                	je     801924 <lwip_select+0x1de>
        FD_ZERO(exceptset);
  801914:	83 ec 04             	sub    $0x4,%esp
  801917:	6a 04                	push   $0x4
  801919:	6a 00                	push   $0x0
  80191b:	53                   	push   %ebx
  80191c:	e8 da d1 00 00       	call   80eafb <memset>
  801921:	83 c4 10             	add    $0x10,%esp
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  801924:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80192b:	00 00 00 
  
      return 0;
  80192e:	b8 00 00 00 00       	mov    $0x0,%eax
  801933:	e9 53 01 00 00       	jmp    801a8b <lwip_select+0x345>
    }
    
    if (readset)
  801938:	85 ff                	test   %edi,%edi
  80193a:	74 07                	je     801943 <lwip_select+0x1fd>
      lreadset = *readset;
  80193c:	8b 07                	mov    (%edi),%eax
  80193e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801941:	eb 13                	jmp    801956 <lwip_select+0x210>
    else
      FD_ZERO(&lreadset);
  801943:	83 ec 04             	sub    $0x4,%esp
  801946:	6a 04                	push   $0x4
  801948:	6a 00                	push   $0x0
  80194a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80194d:	50                   	push   %eax
  80194e:	e8 a8 d1 00 00       	call   80eafb <memset>
  801953:	83 c4 10             	add    $0x10,%esp
    if (writeset)
  801956:	85 f6                	test   %esi,%esi
  801958:	74 07                	je     801961 <lwip_select+0x21b>
      lwriteset = *writeset;
  80195a:	8b 06                	mov    (%esi),%eax
  80195c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80195f:	eb 13                	jmp    801974 <lwip_select+0x22e>
    else
      FD_ZERO(&lwriteset);
  801961:	83 ec 04             	sub    $0x4,%esp
  801964:	6a 04                	push   $0x4
  801966:	6a 00                	push   $0x0
  801968:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80196b:	50                   	push   %eax
  80196c:	e8 8a d1 00 00       	call   80eafb <memset>
  801971:	83 c4 10             	add    $0x10,%esp
    if (exceptset)
  801974:	85 db                	test   %ebx,%ebx
  801976:	74 07                	je     80197f <lwip_select+0x239>
      lexceptset = *exceptset;
  801978:	8b 03                	mov    (%ebx),%eax
  80197a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80197d:	eb 13                	jmp    801992 <lwip_select+0x24c>
    else
      FD_ZERO(&lexceptset);
  80197f:	83 ec 04             	sub    $0x4,%esp
  801982:	6a 04                	push   $0x4
  801984:	6a 00                	push   $0x0
  801986:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801989:	50                   	push   %eax
  80198a:	e8 6c d1 00 00       	call   80eafb <memset>
  80198f:	83 c4 10             	add    $0x10,%esp
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801992:	83 ec 0c             	sub    $0xc,%esp
  801995:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801998:	50                   	push   %eax
  801999:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  80199c:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80199f:	8b 45 08             	mov    0x8(%ebp),%eax
  8019a2:	e8 93 ed ff ff       	call   80073a <lwip_selscan>
  8019a7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  8019aa:	83 c4 10             	add    $0x10,%esp
  8019ad:	eb 11                	jmp    8019c0 <lwip_select+0x27a>
  } else
    sys_sem_signal(selectsem);
  8019af:	83 ec 0c             	sub    $0xc,%esp
  8019b2:	ff 35 40 50 81 00    	pushl  0x815040
  8019b8:	e8 1a 85 00 00       	call   809ed7 <sys_sem_signal>
  8019bd:	83 c4 10             	add    $0x10,%esp
  
  if (readset)
  8019c0:	85 ff                	test   %edi,%edi
  8019c2:	74 05                	je     8019c9 <lwip_select+0x283>
    *readset = lreadset;
  8019c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8019c7:	89 07                	mov    %eax,(%edi)
  if (writeset)
  8019c9:	85 f6                	test   %esi,%esi
  8019cb:	74 05                	je     8019d2 <lwip_select+0x28c>
    *writeset = lwriteset;
  8019cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8019d0:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  8019d2:	85 db                	test   %ebx,%ebx
  8019d4:	74 05                	je     8019db <lwip_select+0x295>
    *exceptset = lexceptset;
  8019d6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8019d9:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  8019db:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8019e2:	00 00 00 
  
  return nready;
  8019e5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  8019e8:	e9 9e 00 00 00       	jmp    801a8b <lwip_select+0x345>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  8019ed:	83 ec 0c             	sub    $0xc,%esp
  8019f0:	6a 00                	push   $0x0
  8019f2:	e8 34 82 00 00       	call   809c2b <sys_sem_new>
  8019f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  8019fa:	a1 48 50 81 00       	mov    0x815048,%eax
  8019ff:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801a02:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801a05:	a3 48 50 81 00       	mov    %eax,0x815048
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801a0a:	83 c4 04             	add    $0x4,%esp
  801a0d:	ff 35 40 50 81 00    	pushl  0x815040
  801a13:	e8 bf 84 00 00       	call   809ed7 <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801a18:	8b 45 18             	mov    0x18(%ebp),%eax
  801a1b:	8b 40 04             	mov    0x4(%eax),%eax
  801a1e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801a21:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  801a27:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  801a2c:	89 c8                	mov    %ecx,%eax
  801a2e:	f7 ea                	imul   %edx
  801a30:	c1 fa 06             	sar    $0x6,%edx
  801a33:	c1 f9 1f             	sar    $0x1f,%ecx
  801a36:	29 ca                	sub    %ecx,%edx
  801a38:	8b 45 18             	mov    0x18(%ebp),%eax
  801a3b:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
      if(msectimeout == 0)
  801a41:	83 c4 10             	add    $0x10,%esp
  801a44:	01 c2                	add    %eax,%edx
        msectimeout = 1;
  801a46:	b8 01 00 00 00       	mov    $0x1,%eax
  801a4b:	0f 44 d0             	cmove  %eax,%edx
  801a4e:	e9 28 fe ff ff       	jmp    80187b <lwip_select+0x135>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801a53:	83 ec 0c             	sub    $0xc,%esp
  801a56:	6a 00                	push   $0x0
  801a58:	e8 ce 81 00 00       	call   809c2b <sys_sem_new>
  801a5d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801a60:	a1 48 50 81 00       	mov    0x815048,%eax
  801a65:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801a68:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801a6b:	a3 48 50 81 00       	mov    %eax,0x815048
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801a70:	83 c4 04             	add    $0x4,%esp
  801a73:	ff 35 40 50 81 00    	pushl  0x815040
  801a79:	e8 59 84 00 00       	call   809ed7 <sys_sem_signal>
  801a7e:	83 c4 10             	add    $0x10,%esp
    
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
  801a81:	ba 00 00 00 00       	mov    $0x0,%edx
  801a86:	e9 f0 fd ff ff       	jmp    80187b <lwip_select+0x135>
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  
  return nready;
}
  801a8b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801a8e:	5b                   	pop    %ebx
  801a8f:	5e                   	pop    %esi
  801a90:	5f                   	pop    %edi
  801a91:	5d                   	pop    %ebp
  801a92:	c3                   	ret    

00801a93 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  801a93:	55                   	push   %ebp
  801a94:	89 e5                	mov    %esp,%ebp
  801a96:	83 ec 14             	sub    $0x14,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801a99:	ff 75 08             	pushl  0x8(%ebp)
  801a9c:	e8 a5 f5 ff ff       	call   801046 <lwip_close>
}
  801aa1:	c9                   	leave  
  801aa2:	c3                   	ret    

00801aa3 <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  801aa3:	55                   	push   %ebp
  801aa4:	89 e5                	mov    %esp,%ebp
  801aa6:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801aa9:	6a 00                	push   $0x0
  801aab:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801aae:	8b 55 0c             	mov    0xc(%ebp),%edx
  801ab1:	8b 45 08             	mov    0x8(%ebp),%eax
  801ab4:	e8 87 ed ff ff       	call   800840 <lwip_getaddrname>
}
  801ab9:	c9                   	leave  
  801aba:	c3                   	ret    

00801abb <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  801abb:	55                   	push   %ebp
  801abc:	89 e5                	mov    %esp,%ebp
  801abe:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801ac1:	6a 01                	push   $0x1
  801ac3:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801ac6:	8b 55 0c             	mov    0xc(%ebp),%edx
  801ac9:	8b 45 08             	mov    0x8(%ebp),%eax
  801acc:	e8 6f ed ff ff       	call   800840 <lwip_getaddrname>
}
  801ad1:	c9                   	leave  
  801ad2:	c3                   	ret    

00801ad3 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  801ad3:	55                   	push   %ebp
  801ad4:	89 e5                	mov    %esp,%ebp
  801ad6:	57                   	push   %edi
  801ad7:	56                   	push   %esi
  801ad8:	53                   	push   %ebx
  801ad9:	83 ec 2c             	sub    $0x2c,%esp
  801adc:	8b 75 0c             	mov    0xc(%ebp),%esi
  801adf:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  801ae2:	8b 45 08             	mov    0x8(%ebp),%eax
  801ae5:	e8 05 ec ff ff       	call   8006ef <get_socket>
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801aea:	85 c0                	test   %eax,%eax
  801aec:	0f 84 7c 01 00 00    	je     801c6e <lwip_getsockopt+0x19b>
  801af2:	89 c3                	mov    %eax,%ebx
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  801af4:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801af8:	74 04                	je     801afe <lwip_getsockopt+0x2b>
  801afa:	85 ff                	test   %edi,%edi
  801afc:	75 1b                	jne    801b19 <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  801afe:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801b05:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801b0c:	00 00 00 
    return -1;
  801b0f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801b14:	e9 95 01 00 00       	jmp    801cae <lwip_getsockopt+0x1db>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801b19:	83 fe 06             	cmp    $0x6,%esi
  801b1c:	0f 84 9c 00 00 00    	je     801bbe <lwip_getsockopt+0xeb>
  801b22:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801b28:	74 0f                	je     801b39 <lwip_getsockopt+0x66>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  801b2a:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801b2f:	85 f6                	test   %esi,%esi
  801b31:	0f 85 c4 00 00 00    	jne    801bfb <lwip_getsockopt+0x128>
  801b37:	eb 6f                	jmp    801ba8 <lwip_getsockopt+0xd5>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801b39:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801b3d:	74 39                	je     801b78 <lwip_getsockopt+0xa5>
  801b3f:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801b43:	7f 12                	jg     801b57 <lwip_getsockopt+0x84>
  801b45:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  801b49:	74 2d                	je     801b78 <lwip_getsockopt+0xa5>
  801b4b:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801b4f:	0f 85 93 00 00 00    	jne    801be8 <lwip_getsockopt+0x115>
  801b55:	eb 21                	jmp    801b78 <lwip_getsockopt+0xa5>
  801b57:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  801b5e:	0f 8c 84 00 00 00    	jl     801be8 <lwip_getsockopt+0x115>
  801b64:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801b6b:	7e 0b                	jle    801b78 <lwip_getsockopt+0xa5>
  801b6d:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801b74:	74 10                	je     801b86 <lwip_getsockopt+0xb3>
  801b76:	eb 70                	jmp    801be8 <lwip_getsockopt+0x115>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  801b78:	83 3f 03             	cmpl   $0x3,(%edi)
  801b7b:	0f 86 f4 00 00 00    	jbe    801c75 <lwip_getsockopt+0x1a2>
  801b81:	e9 8e 00 00 00       	jmp    801c14 <lwip_getsockopt+0x141>
      }
      break;

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801b86:	83 3f 04             	cmpl   $0x4,(%edi)
  801b89:	19 c0                	sbb    %eax,%eax
  801b8b:	83 e0 16             	and    $0x16,%eax
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801b8e:	8b 13                	mov    (%ebx),%edx
  801b90:	83 3a 20             	cmpl   $0x20,(%edx)
  801b93:	0f 85 e3 00 00 00    	jne    801c7c <lwip_getsockopt+0x1a9>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801b99:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801b9c:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801ba0:	0f 85 e0 00 00 00    	jne    801c86 <lwip_getsockopt+0x1b3>
  801ba6:	eb 53                	jmp    801bfb <lwip_getsockopt+0x128>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801ba8:	8b 45 10             	mov    0x10(%ebp),%eax
  801bab:	83 e8 01             	sub    $0x1,%eax
  801bae:	83 f8 01             	cmp    $0x1,%eax
  801bb1:	77 3c                	ja     801bef <lwip_getsockopt+0x11c>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  801bb3:	83 3f 03             	cmpl   $0x3,(%edi)
  801bb6:	0f 86 d4 00 00 00    	jbe    801c90 <lwip_getsockopt+0x1bd>
  801bbc:	eb 56                	jmp    801c14 <lwip_getsockopt+0x141>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  801bbe:	83 3f 03             	cmpl   $0x3,(%edi)
  801bc1:	0f 86 d3 00 00 00    	jbe    801c9a <lwip_getsockopt+0x1c7>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801bc7:	8b 10                	mov    (%eax),%edx
      return 0;
  801bc9:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801bce:	83 3a 10             	cmpl   $0x10,(%edx)
  801bd1:	0f 85 d7 00 00 00    	jne    801cae <lwip_getsockopt+0x1db>
      return 0;

    switch (optname) {
  801bd7:	8b 45 10             	mov    0x10(%ebp),%eax
  801bda:	83 e8 01             	sub    $0x1,%eax
  801bdd:	83 f8 01             	cmp    $0x1,%eax
  801be0:	0f 87 be 00 00 00    	ja     801ca4 <lwip_getsockopt+0x1d1>
  801be6:	eb 0e                	jmp    801bf6 <lwip_getsockopt+0x123>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801be8:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801bed:	eb 0c                	jmp    801bfb <lwip_getsockopt+0x128>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801bef:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801bf4:	eb 05                	jmp    801bfb <lwip_getsockopt+0x128>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801bf6:	b8 00 00 00 00       	mov    $0x0,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  801bfb:	84 c0                	test   %al,%al
  801bfd:	74 15                	je     801c14 <lwip_getsockopt+0x141>
    sock_set_errno(sock, err);
  801bff:	0f be c0             	movsbl %al,%eax
  801c02:	89 43 10             	mov    %eax,0x10(%ebx)
  801c05:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801c0a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801c0f:	e9 9a 00 00 00       	jmp    801cae <lwip_getsockopt+0x1db>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  801c14:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801c17:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801c1a:	8b 45 10             	mov    0x10(%ebp),%eax
  801c1d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801c20:	8b 45 14             	mov    0x14(%ebp),%eax
  801c23:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801c26:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  801c29:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801c2d:	83 ec 04             	sub    $0x4,%esp
  801c30:	6a 01                	push   $0x1
  801c32:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801c35:	50                   	push   %eax
  801c36:	68 33 0b 80 00       	push   $0x800b33
  801c3b:	e8 d4 05 00 00       	call   802214 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801c40:	83 c4 08             	add    $0x8,%esp
  801c43:	6a 00                	push   $0x0
  801c45:	8b 03                	mov    (%ebx),%eax
  801c47:	ff 70 10             	pushl  0x10(%eax)
  801c4a:	e8 f6 82 00 00       	call   809f45 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  801c4f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  801c53:	0f be d0             	movsbl %al,%edx
  801c56:	89 53 10             	mov    %edx,0x10(%ebx)
  801c59:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  return err ? -1 : 0;
  801c5f:	83 c4 10             	add    $0x10,%esp
  801c62:	84 c0                	test   %al,%al
  801c64:	0f 95 c0             	setne  %al
  801c67:	0f b6 c0             	movzbl %al,%eax
  801c6a:	f7 d8                	neg    %eax
  801c6c:	eb 40                	jmp    801cae <lwip_getsockopt+0x1db>
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  801c6e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801c73:	eb 39                	jmp    801cae <lwip_getsockopt+0x1db>
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801c75:	b8 16 00 00 00       	mov    $0x16,%eax
  801c7a:	eb 83                	jmp    801bff <lwip_getsockopt+0x12c>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  801c7c:	b8 61 00 00 00       	mov    $0x61,%eax
  801c81:	e9 79 ff ff ff       	jmp    801bff <lwip_getsockopt+0x12c>
  801c86:	b8 61 00 00 00       	mov    $0x61,%eax
  801c8b:	e9 6f ff ff ff       	jmp    801bff <lwip_getsockopt+0x12c>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  801c90:	b8 16 00 00 00       	mov    $0x16,%eax
  801c95:	e9 65 ff ff ff       	jmp    801bff <lwip_getsockopt+0x12c>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
      err = EINVAL;
  801c9a:	b8 16 00 00 00       	mov    $0x16,%eax
  801c9f:	e9 5b ff ff ff       	jmp    801bff <lwip_getsockopt+0x12c>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801ca4:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801ca9:	e9 51 ff ff ff       	jmp    801bff <lwip_getsockopt+0x12c>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  801cae:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801cb1:	5b                   	pop    %ebx
  801cb2:	5e                   	pop    %esi
  801cb3:	5f                   	pop    %edi
  801cb4:	5d                   	pop    %ebp
  801cb5:	c3                   	ret    

00801cb6 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  801cb6:	55                   	push   %ebp
  801cb7:	89 e5                	mov    %esp,%ebp
  801cb9:	57                   	push   %edi
  801cba:	56                   	push   %esi
  801cbb:	53                   	push   %ebx
  801cbc:	83 ec 2c             	sub    $0x2c,%esp
  801cbf:	8b 75 0c             	mov    0xc(%ebp),%esi
  801cc2:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801cc5:	8b 45 08             	mov    0x8(%ebp),%eax
  801cc8:	e8 22 ea ff ff       	call   8006ef <get_socket>
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801ccd:	85 c0                	test   %eax,%eax
  801ccf:	0f 84 47 01 00 00    	je     801e1c <lwip_setsockopt+0x166>
  801cd5:	89 c3                	mov    %eax,%ebx
    return -1;

  if (NULL == optval) {
  801cd7:	85 ff                	test   %edi,%edi
  801cd9:	75 1b                	jne    801cf6 <lwip_setsockopt+0x40>
    sock_set_errno(sock, EFAULT);
  801cdb:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801ce2:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801ce9:	00 00 00 
    return -1;
  801cec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801cf1:	e9 63 01 00 00       	jmp    801e59 <lwip_setsockopt+0x1a3>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801cf6:	83 fe 06             	cmp    $0x6,%esi
  801cf9:	74 7e                	je     801d79 <lwip_setsockopt+0xc3>
  801cfb:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801d01:	74 0f                	je     801d12 <lwip_setsockopt+0x5c>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  801d03:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801d08:	85 f6                	test   %esi,%esi
  801d0a:	0f 85 a0 00 00 00    	jne    801db0 <lwip_setsockopt+0xfa>
  801d10:	eb 50                	jmp    801d62 <lwip_setsockopt+0xac>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801d12:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801d16:	74 18                	je     801d30 <lwip_setsockopt+0x7a>
  801d18:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801d1f:	74 1e                	je     801d3f <lwip_setsockopt+0x89>
#endif /* LWIP_UDP */
      break;
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  801d21:	b8 5c 00 00 00       	mov    $0x5c,%eax
  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801d26:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801d2a:	0f 85 80 00 00 00    	jne    801db0 <lwip_setsockopt+0xfa>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  801d30:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801d34:	0f 86 e9 00 00 00    	jbe    801e23 <lwip_setsockopt+0x16d>
  801d3a:	e9 87 00 00 00       	jmp    801dc6 <lwip_setsockopt+0x110>
        err = EINVAL;
      }
      break;
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801d3f:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801d43:	19 c0                	sbb    %eax,%eax
  801d45:	83 e0 16             	and    $0x16,%eax
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801d48:	8b 13                	mov    (%ebx),%edx
  801d4a:	83 3a 20             	cmpl   $0x20,(%edx)
  801d4d:	0f 85 d7 00 00 00    	jne    801e2a <lwip_setsockopt+0x174>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801d53:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801d56:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801d5a:	0f 85 d1 00 00 00    	jne    801e31 <lwip_setsockopt+0x17b>
  801d60:	eb 4e                	jmp    801db0 <lwip_setsockopt+0xfa>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801d62:	8b 45 10             	mov    0x10(%ebp),%eax
  801d65:	83 e8 01             	sub    $0x1,%eax
  801d68:	83 f8 01             	cmp    $0x1,%eax
  801d6b:	77 37                	ja     801da4 <lwip_setsockopt+0xee>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  801d6d:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801d71:	0f 86 c4 00 00 00    	jbe    801e3b <lwip_setsockopt+0x185>
  801d77:	eb 4d                	jmp    801dc6 <lwip_setsockopt+0x110>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  801d79:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801d7d:	0f 86 c2 00 00 00    	jbe    801e45 <lwip_setsockopt+0x18f>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801d83:	8b 10                	mov    (%eax),%edx
      return 0;
  801d85:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801d8a:	83 3a 10             	cmpl   $0x10,(%edx)
  801d8d:	0f 85 c6 00 00 00    	jne    801e59 <lwip_setsockopt+0x1a3>
      return 0;

    switch (optname) {
  801d93:	8b 45 10             	mov    0x10(%ebp),%eax
  801d96:	83 e8 01             	sub    $0x1,%eax
  801d99:	83 f8 01             	cmp    $0x1,%eax
  801d9c:	0f 87 ad 00 00 00    	ja     801e4f <lwip_setsockopt+0x199>
  801da2:	eb 07                	jmp    801dab <lwip_setsockopt+0xf5>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  801da4:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801da9:	eb 05                	jmp    801db0 <lwip_setsockopt+0xfa>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  801dab:	b8 00 00 00 00       	mov    $0x0,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  801db0:	85 c0                	test   %eax,%eax
  801db2:	74 12                	je     801dc6 <lwip_setsockopt+0x110>
    sock_set_errno(sock, err);
  801db4:	89 43 10             	mov    %eax,0x10(%ebx)
  801db7:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801dbc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801dc1:	e9 93 00 00 00       	jmp    801e59 <lwip_setsockopt+0x1a3>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  801dc6:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801dc9:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801dcc:	8b 45 10             	mov    0x10(%ebp),%eax
  801dcf:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801dd2:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801dd5:	8d 45 18             	lea    0x18(%ebp),%eax
  801dd8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801ddb:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801ddf:	83 ec 04             	sub    $0x4,%esp
  801de2:	6a 01                	push   $0x1
  801de4:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801de7:	50                   	push   %eax
  801de8:	68 b6 0c 80 00       	push   $0x800cb6
  801ded:	e8 22 04 00 00       	call   802214 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801df2:	83 c4 08             	add    $0x8,%esp
  801df5:	6a 00                	push   $0x0
  801df7:	8b 03                	mov    (%ebx),%eax
  801df9:	ff 70 10             	pushl  0x10(%eax)
  801dfc:	e8 44 81 00 00       	call   809f45 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  801e01:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  801e05:	89 43 10             	mov    %eax,0x10(%ebx)
  801e08:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return err ? -1 : 0;
  801e0d:	83 c4 10             	add    $0x10,%esp
  801e10:	85 c0                	test   %eax,%eax
  801e12:	0f 95 c0             	setne  %al
  801e15:	0f b6 c0             	movzbl %al,%eax
  801e18:	f7 d8                	neg    %eax
  801e1a:	eb 3d                	jmp    801e59 <lwip_setsockopt+0x1a3>
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  801e1c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801e21:	eb 36                	jmp    801e59 <lwip_setsockopt+0x1a3>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801e23:	b8 16 00 00 00       	mov    $0x16,%eax
  801e28:	eb 8a                	jmp    801db4 <lwip_setsockopt+0xfe>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  801e2a:	b8 61 00 00 00       	mov    $0x61,%eax
  801e2f:	eb 83                	jmp    801db4 <lwip_setsockopt+0xfe>
  801e31:	b8 61 00 00 00       	mov    $0x61,%eax
  801e36:	e9 79 ff ff ff       	jmp    801db4 <lwip_setsockopt+0xfe>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  801e3b:	b8 16 00 00 00       	mov    $0x16,%eax
  801e40:	e9 6f ff ff ff       	jmp    801db4 <lwip_setsockopt+0xfe>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
      err = EINVAL;
  801e45:	b8 16 00 00 00       	mov    $0x16,%eax
  801e4a:	e9 65 ff ff ff       	jmp    801db4 <lwip_setsockopt+0xfe>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  801e4f:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e54:	e9 5b ff ff ff       	jmp    801db4 <lwip_setsockopt+0xfe>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  801e59:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801e5c:	5b                   	pop    %ebx
  801e5d:	5e                   	pop    %esi
  801e5e:	5f                   	pop    %edi
  801e5f:	5d                   	pop    %ebp
  801e60:	c3                   	ret    

00801e61 <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  801e61:	55                   	push   %ebp
  801e62:	89 e5                	mov    %esp,%ebp
  801e64:	56                   	push   %esi
  801e65:	53                   	push   %ebx
  801e66:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801e69:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  801e6c:	8b 45 08             	mov    0x8(%ebp),%eax
  801e6f:	e8 7b e8 ff ff       	call   8006ef <get_socket>
  u16_t buflen = 0;

  if (!sock)
  801e74:	85 c0                	test   %eax,%eax
  801e76:	0f 84 af 00 00 00    	je     801f2b <lwip_ioctl+0xca>
    return -1;

  switch (cmd) {
  801e7c:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  801e82:	74 60                	je     801ee4 <lwip_ioctl+0x83>
  801e84:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  801e8a:	0f 85 83 00 00 00    	jne    801f13 <lwip_ioctl+0xb2>
  case FIONREAD:
    if (!argp) {
  801e90:	85 f6                	test   %esi,%esi
  801e92:	75 1b                	jne    801eaf <lwip_ioctl+0x4e>
      sock_set_errno(sock, EINVAL);
  801e94:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  801e9b:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801ea2:	00 00 00 
      return -1;
  801ea5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801eaa:	e9 81 00 00 00       	jmp    801f30 <lwip_ioctl+0xcf>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  801eaf:	8b 10                	mov    (%eax),%edx
  801eb1:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  801eb5:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  801eb8:	8b 48 04             	mov    0x4(%eax),%ecx
  801ebb:	85 c9                	test   %ecx,%ecx
  801ebd:	74 0d                	je     801ecc <lwip_ioctl+0x6b>
      buflen = netbuf_len(sock->lastdata);
  801ebf:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  801ec1:	66 03 51 08          	add    0x8(%ecx),%dx
  801ec5:	66 2b 50 08          	sub    0x8(%eax),%dx
  801ec9:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  801ecc:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801ed3:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801eda:	00 00 00 
    return 0;
  801edd:	b8 00 00 00 00       	mov    $0x0,%eax
  801ee2:	eb 4c                	jmp    801f30 <lwip_ioctl+0xcf>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  801ee4:	85 f6                	test   %esi,%esi
  801ee6:	74 0d                	je     801ef5 <lwip_ioctl+0x94>
  801ee8:	83 3e 00             	cmpl   $0x0,(%esi)
  801eeb:	74 08                	je     801ef5 <lwip_ioctl+0x94>
      sock->flags |= O_NONBLOCK;
  801eed:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
  801ef3:	eb 06                	jmp    801efb <lwip_ioctl+0x9a>
    else
      sock->flags &= ~O_NONBLOCK;
  801ef5:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  801efb:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801f02:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801f09:	00 00 00 
    return 0;
  801f0c:	b8 00 00 00 00       	mov    $0x0,%eax
  801f11:	eb 1d                	jmp    801f30 <lwip_ioctl+0xcf>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  801f13:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  801f1a:	c7 05 e0 b1 b3 00 26 	movl   $0x26,0xb3b1e0
  801f21:	00 00 00 
    return -1;
  801f24:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f29:	eb 05                	jmp    801f30 <lwip_ioctl+0xcf>
{
  struct lwip_socket *sock = get_socket(s);
  u16_t buflen = 0;

  if (!sock)
    return -1;
  801f2b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  801f30:	5b                   	pop    %ebx
  801f31:	5e                   	pop    %esi
  801f32:	5d                   	pop    %ebp
  801f33:	c3                   	ret    

00801f34 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  801f34:	55                   	push   %ebp
  801f35:	89 e5                	mov    %esp,%ebp
  801f37:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  801f3a:	e8 fe 40 00 00       	call   80603d <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  801f3f:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  801f46:	75 09                	jne    801f51 <tcpip_tcp_timer+0x1d>
  801f48:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  801f4f:	74 19                	je     801f6a <tcpip_tcp_timer+0x36>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  801f51:	83 ec 04             	sub    $0x4,%esp
  801f54:	6a 00                	push   $0x0
  801f56:	68 34 1f 80 00       	push   $0x801f34
  801f5b:	68 fa 00 00 00       	push   $0xfa
  801f60:	e8 0a 31 00 00       	call   80506f <sys_timeout>
  801f65:	83 c4 10             	add    $0x10,%esp
  801f68:	eb 0a                	jmp    801f74 <tcpip_tcp_timer+0x40>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  801f6a:	c7 05 e0 52 81 00 00 	movl   $0x0,0x8152e0
  801f71:	00 00 00 
  }
}
  801f74:	c9                   	leave  
  801f75:	c3                   	ret    

00801f76 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  801f76:	55                   	push   %ebp
  801f77:	89 e5                	mov    %esp,%ebp
  801f79:	53                   	push   %ebx
  801f7a:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  801f7d:	6a 00                	push   $0x0
  801f7f:	68 2c 21 80 00       	push   $0x80212c
  801f84:	68 e8 03 00 00       	push   $0x3e8
  801f89:	e8 e1 30 00 00       	call   80506f <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  801f8e:	83 c4 0c             	add    $0xc,%esp
  801f91:	6a 00                	push   $0x0
  801f93:	68 08 21 80 00       	push   $0x802108
  801f98:	68 88 13 00 00       	push   $0x1388
  801f9d:	e8 cd 30 00 00       	call   80506f <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  801fa2:	83 c4 0c             	add    $0xc,%esp
  801fa5:	6a 00                	push   $0x0
  801fa7:	68 e4 20 80 00       	push   $0x8020e4
  801fac:	68 60 ea 00 00       	push   $0xea60
  801fb1:	e8 b9 30 00 00       	call   80506f <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  801fb6:	83 c4 0c             	add    $0xc,%esp
  801fb9:	6a 00                	push   $0x0
  801fbb:	68 c0 20 80 00       	push   $0x8020c0
  801fc0:	68 f4 01 00 00       	push   $0x1f4
  801fc5:	e8 a5 30 00 00       	call   80506f <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  801fca:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  801fcf:	83 c4 10             	add    $0x10,%esp
  801fd2:	85 c0                	test   %eax,%eax
  801fd4:	74 0e                	je     801fe4 <tcpip_thread+0x6e>
    tcpip_init_done(tcpip_init_done_arg);
  801fd6:	83 ec 0c             	sub    $0xc,%esp
  801fd9:	ff 35 e4 52 81 00    	pushl  0x8152e4
  801fdf:	ff d0                	call   *%eax
  801fe1:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  801fe4:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  801fe7:	83 ec 08             	sub    $0x8,%esp
  801fea:	53                   	push   %ebx
  801feb:	ff 35 00 40 81 00    	pushl  0x814000
  801ff1:	e8 57 2f 00 00       	call   804f4d <sys_mbox_fetch>
    switch (msg->type) {
  801ff6:	8b 55 f4             	mov    -0xc(%ebp),%edx
  801ff9:	83 c4 10             	add    $0x10,%esp
  801ffc:	8b 02                	mov    (%edx),%eax
  801ffe:	83 f8 01             	cmp    $0x1,%eax
  802001:	74 22                	je     802025 <tcpip_thread+0xaf>
  802003:	83 f8 01             	cmp    $0x1,%eax
  802006:	72 0c                	jb     802014 <tcpip_thread+0x9e>
  802008:	83 f8 02             	cmp    $0x2,%eax
  80200b:	74 53                	je     802060 <tcpip_thread+0xea>
  80200d:	83 f8 03             	cmp    $0x3,%eax
  802010:	74 6c                	je     80207e <tcpip_thread+0x108>
  802012:	eb d3                	jmp    801fe7 <tcpip_thread+0x71>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  802014:	8b 42 08             	mov    0x8(%edx),%eax
  802017:	83 ec 0c             	sub    $0xc,%esp
  80201a:	8d 50 04             	lea    0x4(%eax),%edx
  80201d:	52                   	push   %edx
  80201e:	ff 10                	call   *(%eax)
      break;
  802020:	83 c4 10             	add    $0x10,%esp
  802023:	eb c2                	jmp    801fe7 <tcpip_thread+0x71>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  802025:	8b 42 0c             	mov    0xc(%edx),%eax
  802028:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  80202c:	74 11                	je     80203f <tcpip_thread+0xc9>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  80202e:	83 ec 08             	sub    $0x8,%esp
  802031:	50                   	push   %eax
  802032:	ff 72 08             	pushl  0x8(%edx)
  802035:	e8 4b 7a 00 00       	call   809a85 <ethernet_input>
  80203a:	83 c4 10             	add    $0x10,%esp
  80203d:	eb 0f                	jmp    80204e <tcpip_thread+0xd8>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  80203f:	83 ec 08             	sub    $0x8,%esp
  802042:	50                   	push   %eax
  802043:	ff 72 08             	pushl  0x8(%edx)
  802046:	e8 2c 44 00 00       	call   806477 <ip_input>
  80204b:	83 c4 10             	add    $0x10,%esp
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  80204e:	83 ec 08             	sub    $0x8,%esp
  802051:	ff 75 f4             	pushl  -0xc(%ebp)
  802054:	6a 09                	push   $0x9
  802056:	e8 56 23 00 00       	call   8043b1 <memp_free>
      break;
  80205b:	83 c4 10             	add    $0x10,%esp
  80205e:	eb 87                	jmp    801fe7 <tcpip_thread+0x71>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  802060:	83 ec 0c             	sub    $0xc,%esp
  802063:	ff 72 0c             	pushl  0xc(%edx)
  802066:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802069:	83 c4 08             	add    $0x8,%esp
  80206c:	ff 75 f4             	pushl  -0xc(%ebp)
  80206f:	6a 08                	push   $0x8
  802071:	e8 3b 23 00 00       	call   8043b1 <memp_free>
      break;
  802076:	83 c4 10             	add    $0x10,%esp
  802079:	e9 69 ff ff ff       	jmp    801fe7 <tcpip_thread+0x71>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  80207e:	8b 42 08             	mov    0x8(%edx),%eax
  802081:	83 f8 ff             	cmp    $0xffffffff,%eax
  802084:	74 14                	je     80209a <tcpip_thread+0x124>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  802086:	83 ec 04             	sub    $0x4,%esp
  802089:	ff 72 10             	pushl  0x10(%edx)
  80208c:	ff 72 0c             	pushl  0xc(%edx)
  80208f:	50                   	push   %eax
  802090:	e8 da 2f 00 00       	call   80506f <sys_timeout>
  802095:	83 c4 10             	add    $0x10,%esp
  802098:	eb 11                	jmp    8020ab <tcpip_thread+0x135>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  80209a:	83 ec 08             	sub    $0x8,%esp
  80209d:	ff 72 10             	pushl  0x10(%edx)
  8020a0:	ff 72 0c             	pushl  0xc(%edx)
  8020a3:	e8 76 30 00 00       	call   80511e <sys_untimeout>
  8020a8:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8020ab:	83 ec 08             	sub    $0x8,%esp
  8020ae:	ff 75 f4             	pushl  -0xc(%ebp)
  8020b1:	6a 08                	push   $0x8
  8020b3:	e8 f9 22 00 00       	call   8043b1 <memp_free>
      break;
  8020b8:	83 c4 10             	add    $0x10,%esp
  8020bb:	e9 27 ff ff ff       	jmp    801fe7 <tcpip_thread+0x71>

008020c0 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  8020c0:	55                   	push   %ebp
  8020c1:	89 e5                	mov    %esp,%ebp
  8020c3:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  8020c6:	e8 00 1b 00 00       	call   803bcb <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8020cb:	83 ec 04             	sub    $0x4,%esp
  8020ce:	6a 00                	push   $0x0
  8020d0:	68 c0 20 80 00       	push   $0x8020c0
  8020d5:	68 f4 01 00 00       	push   $0x1f4
  8020da:	e8 90 2f 00 00       	call   80506f <sys_timeout>
}
  8020df:	83 c4 10             	add    $0x10,%esp
  8020e2:	c9                   	leave  
  8020e3:	c3                   	ret    

008020e4 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  8020e4:	55                   	push   %ebp
  8020e5:	89 e5                	mov    %esp,%ebp
  8020e7:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  8020ea:	e8 18 19 00 00       	call   803a07 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8020ef:	83 ec 04             	sub    $0x4,%esp
  8020f2:	6a 00                	push   $0x0
  8020f4:	68 e4 20 80 00       	push   $0x8020e4
  8020f9:	68 60 ea 00 00       	push   $0xea60
  8020fe:	e8 6c 2f 00 00       	call   80506f <sys_timeout>
}
  802103:	83 c4 10             	add    $0x10,%esp
  802106:	c9                   	leave  
  802107:	c3                   	ret    

00802108 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  802108:	55                   	push   %ebp
  802109:	89 e5                	mov    %esp,%ebp
  80210b:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  80210e:	e8 31 72 00 00       	call   809344 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802113:	83 ec 04             	sub    $0x4,%esp
  802116:	6a 00                	push   $0x0
  802118:	68 08 21 80 00       	push   $0x802108
  80211d:	68 88 13 00 00       	push   $0x1388
  802122:	e8 48 2f 00 00       	call   80506f <sys_timeout>
}
  802127:	83 c4 10             	add    $0x10,%esp
  80212a:	c9                   	leave  
  80212b:	c3                   	ret    

0080212c <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  80212c:	55                   	push   %ebp
  80212d:	89 e5                	mov    %esp,%ebp
  80212f:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  802132:	e8 09 4a 00 00       	call   806b40 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802137:	83 ec 04             	sub    $0x4,%esp
  80213a:	6a 00                	push   $0x0
  80213c:	68 2c 21 80 00       	push   $0x80212c
  802141:	68 e8 03 00 00       	push   $0x3e8
  802146:	e8 24 2f 00 00       	call   80506f <sys_timeout>
}
  80214b:	83 c4 10             	add    $0x10,%esp
  80214e:	c9                   	leave  
  80214f:	c3                   	ret    

00802150 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  802150:	55                   	push   %ebp
  802151:	89 e5                	mov    %esp,%ebp
  802153:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  802156:	ff 75 08             	pushl  0x8(%ebp)
  802159:	e8 c6 25 00 00       	call   804724 <pbuf_free>
}
  80215e:	83 c4 10             	add    $0x10,%esp
  802161:	c9                   	leave  
  802162:	c3                   	ret    

00802163 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  802163:	55                   	push   %ebp
  802164:	89 e5                	mov    %esp,%ebp
  802166:	83 ec 08             	sub    $0x8,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802169:	83 3d e0 52 81 00 00 	cmpl   $0x0,0x8152e0
  802170:	75 33                	jne    8021a5 <tcp_timer_needed+0x42>
  802172:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  802179:	75 09                	jne    802184 <tcp_timer_needed+0x21>
  80217b:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  802182:	74 21                	je     8021a5 <tcp_timer_needed+0x42>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  802184:	c7 05 e0 52 81 00 01 	movl   $0x1,0x8152e0
  80218b:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80218e:	83 ec 04             	sub    $0x4,%esp
  802191:	6a 00                	push   $0x0
  802193:	68 34 1f 80 00       	push   $0x801f34
  802198:	68 fa 00 00 00       	push   $0xfa
  80219d:	e8 cd 2e 00 00       	call   80506f <sys_timeout>
  8021a2:	83 c4 10             	add    $0x10,%esp
  }
}
  8021a5:	c9                   	leave  
  8021a6:	c3                   	ret    

008021a7 <tcpip_input>:
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8021a7:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8021ae:	74 54                	je     802204 <tcpip_input+0x5d>
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  8021b0:	55                   	push   %ebp
  8021b1:	89 e5                	mov    %esp,%ebp
  8021b3:	53                   	push   %ebx
  8021b4:	83 ec 10             	sub    $0x10,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  8021b7:	6a 09                	push   $0x9
  8021b9:	e8 9d 21 00 00       	call   80435b <memp_malloc>
  8021be:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  8021c0:	83 c4 10             	add    $0x10,%esp
  8021c3:	85 c0                	test   %eax,%eax
  8021c5:	74 43                	je     80220a <tcpip_input+0x63>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  8021c7:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  8021cd:	8b 45 08             	mov    0x8(%ebp),%eax
  8021d0:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8021d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  8021d6:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8021d9:	83 ec 08             	sub    $0x8,%esp
  8021dc:	53                   	push   %ebx
  8021dd:	ff 35 00 40 81 00    	pushl  0x814000
  8021e3:	e8 6b 7e 00 00       	call   80a053 <sys_mbox_trypost>
  8021e8:	83 c4 10             	add    $0x10,%esp
  8021eb:	84 c0                	test   %al,%al
  8021ed:	74 20                	je     80220f <tcpip_input+0x68>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8021ef:	83 ec 08             	sub    $0x8,%esp
  8021f2:	53                   	push   %ebx
  8021f3:	6a 09                	push   $0x9
  8021f5:	e8 b7 21 00 00       	call   8043b1 <memp_free>
      return ERR_MEM;
  8021fa:	83 c4 10             	add    $0x10,%esp
  8021fd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802202:	eb 0b                	jmp    80220f <tcpip_input+0x68>
    }
    return ERR_OK;
  }
  return ERR_VAL;
  802204:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802209:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
    if (msg == NULL) {
      return ERR_MEM;
  80220a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  80220f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802212:	c9                   	leave  
  802213:	c3                   	ret    

00802214 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  802214:	55                   	push   %ebp
  802215:	89 e5                	mov    %esp,%ebp
  802217:	56                   	push   %esi
  802218:	53                   	push   %ebx
  802219:	8b 75 10             	mov    0x10(%ebp),%esi
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80221c:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802223:	74 6f                	je     802294 <tcpip_callback_with_block+0x80>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802225:	83 ec 0c             	sub    $0xc,%esp
  802228:	6a 08                	push   $0x8
  80222a:	e8 2c 21 00 00       	call   80435b <memp_malloc>
  80222f:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802231:	83 c4 10             	add    $0x10,%esp
  802234:	85 c0                	test   %eax,%eax
  802236:	74 63                	je     80229b <tcpip_callback_with_block+0x87>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  802238:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  80223e:	8b 45 08             	mov    0x8(%ebp),%eax
  802241:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802244:	8b 45 0c             	mov    0xc(%ebp),%eax
  802247:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  80224a:	89 f0                	mov    %esi,%eax
  80224c:	84 c0                	test   %al,%al
  80224e:	74 19                	je     802269 <tcpip_callback_with_block+0x55>
      sys_mbox_post(mbox, msg);
  802250:	83 ec 08             	sub    $0x8,%esp
  802253:	53                   	push   %ebx
  802254:	ff 35 00 40 81 00    	pushl  0x814000
  80225a:	e8 b7 7e 00 00       	call   80a116 <sys_mbox_post>
  80225f:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  802262:	b8 00 00 00 00       	mov    $0x0,%eax
  802267:	eb 37                	jmp    8022a0 <tcpip_callback_with_block+0x8c>
    msg->msg.cb.f = f;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(mbox, msg);
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  802269:	83 ec 08             	sub    $0x8,%esp
  80226c:	53                   	push   %ebx
  80226d:	ff 35 00 40 81 00    	pushl  0x814000
  802273:	e8 db 7d 00 00       	call   80a053 <sys_mbox_trypost>
  802278:	83 c4 10             	add    $0x10,%esp
  80227b:	84 c0                	test   %al,%al
  80227d:	74 21                	je     8022a0 <tcpip_callback_with_block+0x8c>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  80227f:	83 ec 08             	sub    $0x8,%esp
  802282:	53                   	push   %ebx
  802283:	6a 08                	push   $0x8
  802285:	e8 27 21 00 00       	call   8043b1 <memp_free>
        return ERR_MEM;
  80228a:	83 c4 10             	add    $0x10,%esp
  80228d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802292:	eb 0c                	jmp    8022a0 <tcpip_callback_with_block+0x8c>
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
  802294:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  802299:	eb 05                	jmp    8022a0 <tcpip_callback_with_block+0x8c>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  80229b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  8022a0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8022a3:	5b                   	pop    %ebx
  8022a4:	5e                   	pop    %esi
  8022a5:	5d                   	pop    %ebp
  8022a6:	c3                   	ret    

008022a7 <tcpip_timeout>:
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8022a7:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8022ae:	74 45                	je     8022f5 <tcpip_timeout+0x4e>
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8022b0:	55                   	push   %ebp
  8022b1:	89 e5                	mov    %esp,%ebp
  8022b3:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8022b6:	6a 08                	push   $0x8
  8022b8:	e8 9e 20 00 00       	call   80435b <memp_malloc>
    if (msg == NULL) {
  8022bd:	83 c4 10             	add    $0x10,%esp
  8022c0:	85 c0                	test   %eax,%eax
  8022c2:	74 37                	je     8022fb <tcpip_timeout+0x54>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  8022c4:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  8022ca:	8b 55 08             	mov    0x8(%ebp),%edx
  8022cd:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  8022d0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8022d3:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  8022d6:	8b 55 10             	mov    0x10(%ebp),%edx
  8022d9:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  8022dc:	83 ec 08             	sub    $0x8,%esp
  8022df:	50                   	push   %eax
  8022e0:	ff 35 00 40 81 00    	pushl  0x814000
  8022e6:	e8 2b 7e 00 00       	call   80a116 <sys_mbox_post>
    return ERR_OK;
  8022eb:	83 c4 10             	add    $0x10,%esp
  8022ee:	b8 00 00 00 00       	mov    $0x0,%eax
  8022f3:	eb 0b                	jmp    802300 <tcpip_timeout+0x59>
  }
  return ERR_VAL;
  8022f5:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8022fa:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  8022fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    msg->msg.tmo.arg = arg;
    sys_mbox_post(mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
}
  802300:	c9                   	leave  
  802301:	c3                   	ret    

00802302 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  802302:	55                   	push   %ebp
  802303:	89 e5                	mov    %esp,%ebp
  802305:	53                   	push   %ebx
  802306:	83 ec 24             	sub    $0x24,%esp
  802309:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  80230c:	a1 00 40 81 00       	mov    0x814000,%eax
  802311:	83 f8 ff             	cmp    $0xffffffff,%eax
  802314:	74 31                	je     802347 <tcpip_apimsg+0x45>
    msg.type = TCPIP_MSG_API;
  802316:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  80231d:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802320:	83 ec 08             	sub    $0x8,%esp
  802323:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  802326:	52                   	push   %edx
  802327:	50                   	push   %eax
  802328:	e8 e9 7d 00 00       	call   80a116 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  80232d:	83 c4 08             	add    $0x8,%esp
  802330:	6a 00                	push   $0x0
  802332:	8b 43 04             	mov    0x4(%ebx),%eax
  802335:	ff 70 10             	pushl  0x10(%eax)
  802338:	e8 08 7c 00 00       	call   809f45 <sys_arch_sem_wait>
    return ERR_OK;
  80233d:	83 c4 10             	add    $0x10,%esp
  802340:	b8 00 00 00 00       	mov    $0x0,%eax
  802345:	eb 05                	jmp    80234c <tcpip_apimsg+0x4a>
  }
  return ERR_VAL;
  802347:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80234c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80234f:	c9                   	leave  
  802350:	c3                   	ret    

00802351 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  802351:	55                   	push   %ebp
  802352:	89 e5                	mov    %esp,%ebp
  802354:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  802357:	e8 6f 03 00 00       	call   8026cb <lwip_init>

  tcpip_init_done = initfunc;
  80235c:	8b 45 08             	mov    0x8(%ebp),%eax
  80235f:	a3 e8 52 81 00       	mov    %eax,0x8152e8
  tcpip_init_done_arg = arg;
  802364:	8b 45 0c             	mov    0xc(%ebp),%eax
  802367:	a3 e4 52 81 00       	mov    %eax,0x8152e4
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  80236c:	83 ec 0c             	sub    $0xc,%esp
  80236f:	6a 00                	push   $0x0
  802371:	e8 5e 7a 00 00       	call   809dd4 <sys_mbox_new>
  802376:	a3 00 40 81 00       	mov    %eax,0x814000
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  80237b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  802382:	6a 00                	push   $0x0
  802384:	6a 00                	push   $0x0
  802386:	68 76 1f 80 00       	push   $0x801f76
  80238b:	68 dc 0e 81 00       	push   $0x810edc
  802390:	e8 b2 7e 00 00       	call   80a247 <sys_thread_new>
}
  802395:	83 c4 20             	add    $0x20,%esp
  802398:	c9                   	leave  
  802399:	c3                   	ret    

0080239a <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  80239a:	55                   	push   %ebp
  80239b:	89 e5                	mov    %esp,%ebp
  80239d:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8023a0:	6a 00                	push   $0x0
  8023a2:	ff 75 08             	pushl  0x8(%ebp)
  8023a5:	68 50 21 80 00       	push   $0x802150
  8023aa:	e8 65 fe ff ff       	call   802214 <tcpip_callback_with_block>
}
  8023af:	c9                   	leave  
  8023b0:	c3                   	ret    

008023b1 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  8023b1:	55                   	push   %ebp
  8023b2:	89 e5                	mov    %esp,%ebp
  8023b4:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  8023b7:	6a 00                	push   $0x0
  8023b9:	ff 75 08             	pushl  0x8(%ebp)
  8023bc:	68 82 3e 80 00       	push   $0x803e82
  8023c1:	e8 4e fe ff ff       	call   802214 <tcpip_callback_with_block>
}
  8023c6:	c9                   	leave  
  8023c7:	c3                   	ret    

008023c8 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  8023c8:	55                   	push   %ebp
  8023c9:	89 e5                	mov    %esp,%ebp
  8023cb:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  8023ce:	6a 06                	push   $0x6
  8023d0:	e8 86 1f 00 00       	call   80435b <memp_malloc>
  if (buf != NULL) {
  8023d5:	83 c4 10             	add    $0x10,%esp
  8023d8:	85 c0                	test   %eax,%eax
  8023da:	74 14                	je     8023f0 <netbuf_new+0x28>
    buf->p = NULL;
  8023dc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  8023e2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  8023e9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  8023f0:	c9                   	leave  
  8023f1:	c3                   	ret    

008023f2 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8023f2:	55                   	push   %ebp
  8023f3:	89 e5                	mov    %esp,%ebp
  8023f5:	53                   	push   %ebx
  8023f6:	83 ec 04             	sub    $0x4,%esp
  8023f9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  8023fc:	85 db                	test   %ebx,%ebx
  8023fe:	74 2d                	je     80242d <netbuf_delete+0x3b>
    if (buf->p != NULL) {
  802400:	8b 03                	mov    (%ebx),%eax
  802402:	85 c0                	test   %eax,%eax
  802404:	74 19                	je     80241f <netbuf_delete+0x2d>
      pbuf_free(buf->p);
  802406:	83 ec 0c             	sub    $0xc,%esp
  802409:	50                   	push   %eax
  80240a:	e8 15 23 00 00       	call   804724 <pbuf_free>
      buf->p = buf->ptr = NULL;
  80240f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802416:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80241c:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  80241f:	83 ec 08             	sub    $0x8,%esp
  802422:	53                   	push   %ebx
  802423:	6a 06                	push   $0x6
  802425:	e8 87 1f 00 00       	call   8043b1 <memp_free>
  80242a:	83 c4 10             	add    $0x10,%esp
  }
}
  80242d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802430:	c9                   	leave  
  802431:	c3                   	ret    

00802432 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  802432:	55                   	push   %ebp
  802433:	89 e5                	mov    %esp,%ebp
  802435:	56                   	push   %esi
  802436:	53                   	push   %ebx
  802437:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80243a:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80243d:	85 db                	test   %ebx,%ebx
  80243f:	75 14                	jne    802455 <netbuf_alloc+0x23>
  802441:	83 ec 04             	sub    $0x4,%esp
  802444:	68 e9 0e 81 00       	push   $0x810ee9
  802449:	6a 63                	push   $0x63
  80244b:	68 03 0f 81 00       	push   $0x810f03
  802450:	e8 03 bf 00 00       	call   80e358 <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802455:	8b 03                	mov    (%ebx),%eax
  802457:	85 c0                	test   %eax,%eax
  802459:	74 0c                	je     802467 <netbuf_alloc+0x35>
    pbuf_free(buf->p);
  80245b:	83 ec 0c             	sub    $0xc,%esp
  80245e:	50                   	push   %eax
  80245f:	e8 c0 22 00 00       	call   804724 <pbuf_free>
  802464:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  802467:	83 ec 04             	sub    $0x4,%esp
  80246a:	6a 00                	push   $0x0
  80246c:	0f b7 c6             	movzwl %si,%eax
  80246f:	50                   	push   %eax
  802470:	6a 00                	push   $0x0
  802472:	e8 73 23 00 00       	call   8047ea <pbuf_alloc>
  802477:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802479:	83 c4 10             	add    $0x10,%esp
  80247c:	85 c0                	test   %eax,%eax
  80247e:	74 22                	je     8024a2 <netbuf_alloc+0x70>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  802480:	66 3b 70 0a          	cmp    0xa(%eax),%si
  802484:	76 14                	jbe    80249a <netbuf_alloc+0x68>
  802486:	83 ec 04             	sub    $0x4,%esp
  802489:	68 d0 0f 81 00       	push   $0x810fd0
  80248e:	6a 6e                	push   $0x6e
  802490:	68 03 0f 81 00       	push   $0x810f03
  802495:	e8 be be 00 00       	call   80e358 <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  80249a:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  80249d:	8b 40 04             	mov    0x4(%eax),%eax
  8024a0:	eb 05                	jmp    8024a7 <netbuf_alloc+0x75>
  if (buf->p != NULL) {
    pbuf_free(buf->p);
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  if (buf->p == NULL) {
     return NULL;
  8024a2:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
  return buf->p->payload;
}
  8024a7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8024aa:	5b                   	pop    %ebx
  8024ab:	5e                   	pop    %esi
  8024ac:	5d                   	pop    %ebp
  8024ad:	c3                   	ret    

008024ae <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8024ae:	55                   	push   %ebp
  8024af:	89 e5                	mov    %esp,%ebp
  8024b1:	53                   	push   %ebx
  8024b2:	83 ec 04             	sub    $0x4,%esp
  8024b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8024b8:	85 db                	test   %ebx,%ebx
  8024ba:	75 14                	jne    8024d0 <netbuf_free+0x22>
  8024bc:	83 ec 04             	sub    $0x4,%esp
  8024bf:	68 19 0f 81 00       	push   $0x810f19
  8024c4:	6a 7b                	push   $0x7b
  8024c6:	68 03 0f 81 00       	push   $0x810f03
  8024cb:	e8 88 be 00 00       	call   80e358 <_panic>
  if (buf->p != NULL) {
  8024d0:	8b 03                	mov    (%ebx),%eax
  8024d2:	85 c0                	test   %eax,%eax
  8024d4:	74 0c                	je     8024e2 <netbuf_free+0x34>
    pbuf_free(buf->p);
  8024d6:	83 ec 0c             	sub    $0xc,%esp
  8024d9:	50                   	push   %eax
  8024da:	e8 45 22 00 00       	call   804724 <pbuf_free>
  8024df:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  8024e2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8024e9:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8024ef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8024f2:	c9                   	leave  
  8024f3:	c3                   	ret    

008024f4 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  8024f4:	55                   	push   %ebp
  8024f5:	89 e5                	mov    %esp,%ebp
  8024f7:	56                   	push   %esi
  8024f8:	53                   	push   %ebx
  8024f9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8024fc:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8024ff:	85 db                	test   %ebx,%ebx
  802501:	75 17                	jne    80251a <netbuf_ref+0x26>
  802503:	83 ec 04             	sub    $0x4,%esp
  802506:	68 32 0f 81 00       	push   $0x810f32
  80250b:	68 8e 00 00 00       	push   $0x8e
  802510:	68 03 0f 81 00       	push   $0x810f03
  802515:	e8 3e be 00 00       	call   80e358 <_panic>
  if (buf->p != NULL) {
  80251a:	8b 03                	mov    (%ebx),%eax
  80251c:	85 c0                	test   %eax,%eax
  80251e:	74 0c                	je     80252c <netbuf_ref+0x38>
    pbuf_free(buf->p);
  802520:	83 ec 0c             	sub    $0xc,%esp
  802523:	50                   	push   %eax
  802524:	e8 fb 21 00 00       	call   804724 <pbuf_free>
  802529:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  80252c:	83 ec 04             	sub    $0x4,%esp
  80252f:	6a 02                	push   $0x2
  802531:	6a 00                	push   $0x0
  802533:	6a 00                	push   $0x0
  802535:	e8 b0 22 00 00       	call   8047ea <pbuf_alloc>
  80253a:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80253c:	83 c4 10             	add    $0x10,%esp
  80253f:	85 c0                	test   %eax,%eax
  802541:	75 0e                	jne    802551 <netbuf_ref+0x5d>
    buf->ptr = NULL;
  802543:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  80254a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80254f:	eb 1a                	jmp    80256b <netbuf_ref+0x77>
  }
  buf->p->payload = (void*)dataptr;
  802551:	8b 55 0c             	mov    0xc(%ebp),%edx
  802554:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  802557:	8b 03                	mov    (%ebx),%eax
  802559:	66 89 70 08          	mov    %si,0x8(%eax)
  80255d:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  802561:	8b 03                	mov    (%ebx),%eax
  802563:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  802566:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80256b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80256e:	5b                   	pop    %ebx
  80256f:	5e                   	pop    %esi
  802570:	5d                   	pop    %ebp
  802571:	c3                   	ret    

00802572 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  802572:	55                   	push   %ebp
  802573:	89 e5                	mov    %esp,%ebp
  802575:	56                   	push   %esi
  802576:	53                   	push   %ebx
  802577:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80257a:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  80257d:	85 db                	test   %ebx,%ebx
  80257f:	75 17                	jne    802598 <netbuf_chain+0x26>
  802581:	83 ec 04             	sub    $0x4,%esp
  802584:	68 4a 0f 81 00       	push   $0x810f4a
  802589:	68 a6 00 00 00       	push   $0xa6
  80258e:	68 03 0f 81 00       	push   $0x810f03
  802593:	e8 c0 bd 00 00       	call   80e358 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  802598:	85 f6                	test   %esi,%esi
  80259a:	75 17                	jne    8025b3 <netbuf_chain+0x41>
  80259c:	83 ec 04             	sub    $0x4,%esp
  80259f:	68 63 0f 81 00       	push   $0x810f63
  8025a4:	68 a7 00 00 00       	push   $0xa7
  8025a9:	68 03 0f 81 00       	push   $0x810f03
  8025ae:	e8 a5 bd 00 00       	call   80e358 <_panic>
  pbuf_chain(head->p, tail->p);
  8025b3:	83 ec 08             	sub    $0x8,%esp
  8025b6:	ff 36                	pushl  (%esi)
  8025b8:	ff 33                	pushl  (%ebx)
  8025ba:	e8 59 26 00 00       	call   804c18 <pbuf_chain>
  head->ptr = head->p;
  8025bf:	8b 03                	mov    (%ebx),%eax
  8025c1:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  8025c4:	83 c4 08             	add    $0x8,%esp
  8025c7:	56                   	push   %esi
  8025c8:	6a 06                	push   $0x6
  8025ca:	e8 e2 1d 00 00       	call   8043b1 <memp_free>
}
  8025cf:	83 c4 10             	add    $0x10,%esp
  8025d2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8025d5:	5b                   	pop    %ebx
  8025d6:	5e                   	pop    %esi
  8025d7:	5d                   	pop    %ebp
  8025d8:	c3                   	ret    

008025d9 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  8025d9:	55                   	push   %ebp
  8025da:	89 e5                	mov    %esp,%ebp
  8025dc:	53                   	push   %ebx
  8025dd:	83 ec 04             	sub    $0x4,%esp
  8025e0:	8b 45 08             	mov    0x8(%ebp),%eax
  8025e3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8025e6:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  8025e9:	85 c0                	test   %eax,%eax
  8025eb:	75 17                	jne    802604 <netbuf_data+0x2b>
  8025ed:	83 ec 04             	sub    $0x4,%esp
  8025f0:	68 7e 0f 81 00       	push   $0x810f7e
  8025f5:	68 b9 00 00 00       	push   $0xb9
  8025fa:	68 03 0f 81 00       	push   $0x810f03
  8025ff:	e8 54 bd 00 00       	call   80e358 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802604:	85 c9                	test   %ecx,%ecx
  802606:	75 17                	jne    80261f <netbuf_data+0x46>
  802608:	83 ec 04             	sub    $0x4,%esp
  80260b:	68 97 0f 81 00       	push   $0x810f97
  802610:	68 ba 00 00 00       	push   $0xba
  802615:	68 03 0f 81 00       	push   $0x810f03
  80261a:	e8 39 bd 00 00       	call   80e358 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  80261f:	85 d2                	test   %edx,%edx
  802621:	75 17                	jne    80263a <netbuf_data+0x61>
  802623:	83 ec 04             	sub    $0x4,%esp
  802626:	68 b4 0f 81 00       	push   $0x810fb4
  80262b:	68 bb 00 00 00       	push   $0xbb
  802630:	68 03 0f 81 00       	push   $0x810f03
  802635:	e8 1e bd 00 00       	call   80e358 <_panic>

  if (buf->ptr == NULL) {
  80263a:	8b 58 04             	mov    0x4(%eax),%ebx
  80263d:	85 db                	test   %ebx,%ebx
  80263f:	74 16                	je     802657 <netbuf_data+0x7e>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802641:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802644:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  802646:	8b 40 04             	mov    0x4(%eax),%eax
  802649:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  80264d:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802650:	b8 00 00 00 00       	mov    $0x0,%eax
  802655:	eb 05                	jmp    80265c <netbuf_data+0x83>
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
    return ERR_BUF;
  802657:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  }
  *dataptr = buf->ptr->payload;
  *len = buf->ptr->len;
  return ERR_OK;
}
  80265c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80265f:	c9                   	leave  
  802660:	c3                   	ret    

00802661 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  802661:	55                   	push   %ebp
  802662:	89 e5                	mov    %esp,%ebp
  802664:	83 ec 08             	sub    $0x8,%esp
  802667:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  80266a:	85 c0                	test   %eax,%eax
  80266c:	75 17                	jne    802685 <netbuf_next+0x24>
  80266e:	83 ec 04             	sub    $0x4,%esp
  802671:	68 19 0f 81 00       	push   $0x810f19
  802676:	68 d2 00 00 00       	push   $0xd2
  80267b:	68 03 0f 81 00       	push   $0x810f03
  802680:	e8 d3 bc 00 00       	call   80e358 <_panic>
  if (buf->ptr->next == NULL) {
  802685:	8b 50 04             	mov    0x4(%eax),%edx
  802688:	8b 12                	mov    (%edx),%edx
  80268a:	85 d2                	test   %edx,%edx
  80268c:	74 0b                	je     802699 <netbuf_next+0x38>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  80268e:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
  802691:	83 3a 00             	cmpl   $0x0,(%edx)
  802694:	0f 94 c0             	sete   %al
  802697:	eb 05                	jmp    80269e <netbuf_next+0x3d>
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  if (buf->ptr->next == NULL) {
    return -1;
  802699:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  buf->ptr = buf->ptr->next;
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  80269e:	c9                   	leave  
  80269f:	c3                   	ret    

008026a0 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8026a0:	55                   	push   %ebp
  8026a1:	89 e5                	mov    %esp,%ebp
  8026a3:	83 ec 08             	sub    $0x8,%esp
  8026a6:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8026a9:	85 c0                	test   %eax,%eax
  8026ab:	75 17                	jne    8026c4 <netbuf_first+0x24>
  8026ad:	83 ec 04             	sub    $0x4,%esp
  8026b0:	68 19 0f 81 00       	push   $0x810f19
  8026b5:	68 e7 00 00 00       	push   $0xe7
  8026ba:	68 03 0f 81 00       	push   $0x810f03
  8026bf:	e8 94 bc 00 00       	call   80e358 <_panic>
  buf->ptr = buf->p;
  8026c4:	8b 10                	mov    (%eax),%edx
  8026c6:	89 50 04             	mov    %edx,0x4(%eax)
}
  8026c9:	c9                   	leave  
  8026ca:	c3                   	ret    

008026cb <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8026cb:	55                   	push   %ebp
  8026cc:	89 e5                	mov    %esp,%ebp
  8026ce:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  8026d1:	e8 c0 74 00 00       	call   809b96 <sys_init>
  mem_init();
  8026d6:	e8 41 17 00 00       	call   803e1c <mem_init>
  memp_init();
  8026db:	e8 24 1c 00 00       	call   804304 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  8026e0:	e8 d4 e6 ff ff       	call   800db9 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  8026e5:	c9                   	leave  
  8026e6:	c3                   	ret    

008026e7 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  8026e7:	55                   	push   %ebp
  8026e8:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  8026ea:	38 10                	cmp    %dl,(%eax)
  8026ec:	74 06                	je     8026f4 <dhcp_set_state+0xd>
    dhcp->state = new_state;
  8026ee:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  8026f0:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  8026f4:	5d                   	pop    %ebp
  8026f5:	c3                   	ret    

008026f6 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  8026f6:	55                   	push   %ebp
  8026f7:	89 e5                	mov    %esp,%ebp
  8026f9:	57                   	push   %edi
  8026fa:	56                   	push   %esi
  8026fb:	53                   	push   %ebx
  8026fc:	83 ec 08             	sub    $0x8,%esp
  8026ff:	89 45 ec             	mov    %eax,-0x14(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802702:	8b 70 14             	mov    0x14(%eax),%esi
  802705:	85 f6                	test   %esi,%esi
  802707:	0f 84 d5 00 00 00    	je     8027e2 <dhcp_get_option_ptr+0xec>
  80270d:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  802711:	b9 00 00 00 00       	mov    $0x0,%ecx
  802716:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80271a:	b8 00 00 00 00       	mov    $0x0,%eax
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80271f:	66 85 ff             	test   %di,%di
  802722:	0f 84 d2 00 00 00    	je     8027fa <dhcp_get_option_ptr+0x104>
  802728:	eb 2d                	jmp    802757 <dhcp_get_option_ptr+0x61>
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80272a:	80 fb 34             	cmp    $0x34,%bl
  80272d:	75 12                	jne    802741 <dhcp_get_option_ptr+0x4b>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  80272f:	8d 41 02             	lea    0x2(%ecx),%eax
        overload = options[offset++];
  802732:	83 c1 03             	add    $0x3,%ecx
  802735:	0f b7 c0             	movzwl %ax,%eax
  802738:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  80273c:	88 45 f0             	mov    %al,-0x10(%ebp)
  80273f:	eb 16                	jmp    802757 <dhcp_get_option_ptr+0x61>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  802741:	38 d3                	cmp    %dl,%bl
  802743:	0f 84 b1 00 00 00    	je     8027fa <dhcp_get_option_ptr+0x104>
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  802749:	8d 41 01             	lea    0x1(%ecx),%eax
  80274c:	0f b7 c0             	movzwl %ax,%eax
  80274f:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802753:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802757:	66 39 f9             	cmp    %di,%cx
  80275a:	73 0d                	jae    802769 <dhcp_get_option_ptr+0x73>
  80275c:	0f b7 c1             	movzwl %cx,%eax
  80275f:	01 f0                	add    %esi,%eax
  802761:	0f b6 18             	movzbl (%eax),%ebx
  802764:	80 fb ff             	cmp    $0xff,%bl
  802767:	75 c1                	jne    80272a <dhcp_get_option_ptr+0x34>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  802769:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
  80276d:	84 c0                	test   %al,%al
  80276f:	74 78                	je     8027e9 <dhcp_get_option_ptr+0xf3>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  802771:	3c 01                	cmp    $0x1,%al
  802773:	75 10                	jne    802785 <dhcp_get_option_ptr+0x8f>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  802775:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802778:	8b 58 10             	mov    0x10(%eax),%ebx
  80277b:	83 c3 6c             	add    $0x6c,%ebx
        field_len = DHCP_FILE_LEN;
  80277e:	be 80 00 00 00       	mov    $0x80,%esi
  802783:	eb 24                	jmp    8027a9 <dhcp_get_option_ptr+0xb3>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  802785:	80 7d f0 02          	cmpb   $0x2,-0x10(%ebp)
  802789:	75 10                	jne    80279b <dhcp_get_option_ptr+0xa5>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80278b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80278e:	8b 58 10             	mov    0x10(%eax),%ebx
  802791:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_SNAME_LEN;
  802794:	be 40 00 00 00       	mov    $0x40,%esi
  802799:	eb 0e                	jmp    8027a9 <dhcp_get_option_ptr+0xb3>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80279b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80279e:	8b 58 10             	mov    0x10(%eax),%ebx
  8027a1:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  8027a4:	be c0 00 00 00       	mov    $0xc0,%esi
      }
      offset = 0;
  8027a9:	b9 00 00 00 00       	mov    $0x0,%ecx
  8027ae:	89 d7                	mov    %edx,%edi

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8027b0:	eb 14                	jmp    8027c6 <dhcp_get_option_ptr+0xd0>
        if (options[offset] == option_type) {
  8027b2:	89 f8                	mov    %edi,%eax
  8027b4:	38 d0                	cmp    %dl,%al
  8027b6:	74 3f                	je     8027f7 <dhcp_get_option_ptr+0x101>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
          offset += 1 + options[offset];
  8027b8:	8d 41 01             	lea    0x1(%ecx),%eax
  8027bb:	0f b7 c0             	movzwl %ax,%eax
  8027be:	0f b6 04 03          	movzbl (%ebx,%eax,1),%eax
  8027c2:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8027c6:	66 39 f1             	cmp    %si,%cx
  8027c9:	73 25                	jae    8027f0 <dhcp_get_option_ptr+0xfa>
  8027cb:	0f b7 c1             	movzwl %cx,%eax
  8027ce:	01 d8                	add    %ebx,%eax
  8027d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  8027d3:	0f b6 10             	movzbl (%eax),%edx
  8027d6:	80 fa ff             	cmp    $0xff,%dl
  8027d9:	75 d7                	jne    8027b2 <dhcp_get_option_ptr+0xbc>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  8027db:	b8 00 00 00 00       	mov    $0x0,%eax
  8027e0:	eb 18                	jmp    8027fa <dhcp_get_option_ptr+0x104>
  8027e2:	b8 00 00 00 00       	mov    $0x0,%eax
  8027e7:	eb 11                	jmp    8027fa <dhcp_get_option_ptr+0x104>
  8027e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8027ee:	eb 0a                	jmp    8027fa <dhcp_get_option_ptr+0x104>
  8027f0:	b8 00 00 00 00       	mov    $0x0,%eax
  8027f5:	eb 03                	jmp    8027fa <dhcp_get_option_ptr+0x104>
  8027f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  8027fa:	83 c4 08             	add    $0x8,%esp
  8027fd:	5b                   	pop    %ebx
  8027fe:	5e                   	pop    %esi
  8027ff:	5f                   	pop    %edi
  802800:	5d                   	pop    %ebp
  802801:	c3                   	ret    

00802802 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  802802:	55                   	push   %ebp
  802803:	89 e5                	mov    %esp,%ebp
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802805:	0f b6 10             	movzbl (%eax),%edx
  802808:	89 d1                	mov    %edx,%ecx
  80280a:	c1 e1 18             	shl    $0x18,%ecx
  80280d:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  802811:	c1 e2 10             	shl    $0x10,%edx
  802814:	09 ca                	or     %ecx,%edx
  802816:	0f b6 48 03          	movzbl 0x3(%eax),%ecx
  80281a:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 16;
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
  80281c:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  802820:	c1 e0 08             	shl    $0x8,%eax
  802823:	09 d0                	or     %edx,%eax
}
  802825:	5d                   	pop    %ebp
  802826:	c3                   	ret    

00802827 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  802827:	55                   	push   %ebp
  802828:	89 e5                	mov    %esp,%ebp
  80282a:	56                   	push   %esi
  80282b:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80282c:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802830:	66 83 f9 43          	cmp    $0x43,%cx
  802834:	76 17                	jbe    80284d <dhcp_option_byte+0x26>
  802836:	83 ec 04             	sub    $0x4,%esp
  802839:	68 f4 0f 81 00       	push   $0x810ff4
  80283e:	68 65 04 00 00       	push   $0x465
  802843:	68 42 13 81 00       	push   $0x811342
  802848:	e8 0b bb 00 00       	call   80e358 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80284d:	8b 58 20             	mov    0x20(%eax),%ebx
  802850:	8d 71 01             	lea    0x1(%ecx),%esi
  802853:	66 89 70 24          	mov    %si,0x24(%eax)
  802857:	0f b7 c9             	movzwl %cx,%ecx
  80285a:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802861:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802864:	5b                   	pop    %ebx
  802865:	5e                   	pop    %esi
  802866:	5d                   	pop    %ebp
  802867:	c3                   	ret    

00802868 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  802868:	55                   	push   %ebp
  802869:	89 e5                	mov    %esp,%ebp
  80286b:	57                   	push   %edi
  80286c:	56                   	push   %esi
  80286d:	53                   	push   %ebx
  80286e:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802871:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  802875:	0f b7 fb             	movzwl %bx,%edi
  802878:	0f b6 f1             	movzbl %cl,%esi
  80287b:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  80287f:	83 fe 44             	cmp    $0x44,%esi
  802882:	76 17                	jbe    80289b <dhcp_option+0x33>
  802884:	83 ec 04             	sub    $0x4,%esp
  802887:	68 30 10 81 00       	push   $0x811030
  80288c:	68 5a 04 00 00       	push   $0x45a
  802891:	68 42 13 81 00       	push   $0x811342
  802896:	e8 bd ba 00 00       	call   80e358 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  80289b:	8b 70 20             	mov    0x20(%eax),%esi
  80289e:	8d 7b 01             	lea    0x1(%ebx),%edi
  8028a1:	66 89 78 24          	mov    %di,0x24(%eax)
  8028a5:	0f b7 db             	movzwl %bx,%ebx
  8028a8:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  8028af:	8b 58 20             	mov    0x20(%eax),%ebx
  8028b2:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8028b6:	8d 72 01             	lea    0x1(%edx),%esi
  8028b9:	66 89 70 24          	mov    %si,0x24(%eax)
  8028bd:	0f b7 d2             	movzwl %dx,%edx
  8028c0:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  8028c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8028ca:	5b                   	pop    %ebx
  8028cb:	5e                   	pop    %esi
  8028cc:	5f                   	pop    %edi
  8028cd:	5d                   	pop    %ebp
  8028ce:	c3                   	ret    

008028cf <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  8028cf:	55                   	push   %ebp
  8028d0:	89 e5                	mov    %esp,%ebp
  8028d2:	56                   	push   %esi
  8028d3:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  8028d4:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8028d8:	0f b7 d9             	movzwl %cx,%ebx
  8028db:	83 c3 02             	add    $0x2,%ebx
  8028de:	83 fb 44             	cmp    $0x44,%ebx
  8028e1:	76 17                	jbe    8028fa <dhcp_option_short+0x2b>
  8028e3:	83 ec 04             	sub    $0x4,%esp
  8028e6:	68 78 10 81 00       	push   $0x811078
  8028eb:	68 6c 04 00 00       	push   $0x46c
  8028f0:	68 42 13 81 00       	push   $0x811342
  8028f5:	e8 5e ba 00 00       	call   80e358 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  8028fa:	8d 71 01             	lea    0x1(%ecx),%esi
  8028fd:	66 89 70 24          	mov    %si,0x24(%eax)
  802901:	0f b7 c9             	movzwl %cx,%ecx
  802904:	89 d3                	mov    %edx,%ebx
  802906:	66 c1 eb 08          	shr    $0x8,%bx
  80290a:	8b 70 20             	mov    0x20(%eax),%esi
  80290d:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802914:	8b 58 20             	mov    0x20(%eax),%ebx
  802917:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  80291b:	8d 71 01             	lea    0x1(%ecx),%esi
  80291e:	66 89 70 24          	mov    %si,0x24(%eax)
  802922:	0f b7 c9             	movzwl %cx,%ecx
  802925:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  80292c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80292f:	5b                   	pop    %ebx
  802930:	5e                   	pop    %esi
  802931:	5d                   	pop    %ebp
  802932:	c3                   	ret    

00802933 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  802933:	55                   	push   %ebp
  802934:	89 e5                	mov    %esp,%ebp
  802936:	53                   	push   %ebx
  802937:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  80293a:	85 c0                	test   %eax,%eax
  80293c:	75 17                	jne    802955 <dhcp_option_trailer+0x22>
  80293e:	83 ec 04             	sub    $0x4,%esp
  802941:	68 bc 10 81 00       	push   $0x8110bc
  802946:	68 80 05 00 00       	push   $0x580
  80294b:	68 42 13 81 00       	push   $0x811342
  802950:	e8 03 ba 00 00       	call   80e358 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802955:	8b 48 20             	mov    0x20(%eax),%ecx
  802958:	85 c9                	test   %ecx,%ecx
  80295a:	75 17                	jne    802973 <dhcp_option_trailer+0x40>
  80295c:	83 ec 04             	sub    $0x4,%esp
  80295f:	68 e0 10 81 00       	push   $0x8110e0
  802964:	68 81 05 00 00       	push   $0x581
  802969:	68 42 13 81 00       	push   $0x811342
  80296e:	e8 e5 b9 00 00       	call   80e358 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802973:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802977:	66 83 fa 43          	cmp    $0x43,%dx
  80297b:	76 17                	jbe    802994 <dhcp_option_trailer+0x61>
  80297d:	83 ec 04             	sub    $0x4,%esp
  802980:	68 0c 11 81 00       	push   $0x81110c
  802985:	68 82 05 00 00       	push   $0x582
  80298a:	68 42 13 81 00       	push   $0x811342
  80298f:	e8 c4 b9 00 00       	call   80e358 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802994:	8d 5a 01             	lea    0x1(%edx),%ebx
  802997:	66 89 58 24          	mov    %bx,0x24(%eax)
  80299b:	0f b7 d2             	movzwl %dx,%edx
  80299e:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  8029a5:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  8029a6:	eb 2c                	jmp    8029d4 <dhcp_option_trailer+0xa1>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8029a8:	83 ec 04             	sub    $0x4,%esp
  8029ab:	68 0c 11 81 00       	push   $0x81110c
  8029b0:	68 87 05 00 00       	push   $0x587
  8029b5:	68 42 13 81 00       	push   $0x811342
  8029ba:	e8 99 b9 00 00       	call   80e358 <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  8029bf:	8b 48 20             	mov    0x20(%eax),%ecx
  8029c2:	8d 5a 01             	lea    0x1(%edx),%ebx
  8029c5:	66 89 58 24          	mov    %bx,0x24(%eax)
  8029c9:	0f b7 d2             	movzwl %dx,%edx
  8029cc:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  8029d3:	00 
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  8029d4:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8029d8:	66 83 fa 43          	cmp    $0x43,%dx
  8029dc:	76 e1                	jbe    8029bf <dhcp_option_trailer+0x8c>
  8029de:	f6 c2 03             	test   $0x3,%dl
  8029e1:	75 c5                	jne    8029a8 <dhcp_option_trailer+0x75>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  8029e3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8029e6:	c9                   	leave  
  8029e7:	c3                   	ret    

008029e8 <dhcp_option_long>:
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  8029e8:	55                   	push   %ebp
  8029e9:	89 e5                	mov    %esp,%ebp
  8029eb:	56                   	push   %esi
  8029ec:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  8029ed:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8029f1:	0f b7 d9             	movzwl %cx,%ebx
  8029f4:	83 c3 04             	add    $0x4,%ebx
  8029f7:	83 fb 44             	cmp    $0x44,%ebx
  8029fa:	76 17                	jbe    802a13 <dhcp_option_long+0x2b>
  8029fc:	83 ec 04             	sub    $0x4,%esp
  8029ff:	68 4c 11 81 00       	push   $0x81114c
  802a04:	68 74 04 00 00       	push   $0x474
  802a09:	68 42 13 81 00       	push   $0x811342
  802a0e:	e8 45 b9 00 00       	call   80e358 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802a13:	8d 71 01             	lea    0x1(%ecx),%esi
  802a16:	66 89 70 24          	mov    %si,0x24(%eax)
  802a1a:	0f b7 c9             	movzwl %cx,%ecx
  802a1d:	89 d3                	mov    %edx,%ebx
  802a1f:	c1 eb 18             	shr    $0x18,%ebx
  802a22:	8b 70 20             	mov    0x20(%eax),%esi
  802a25:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802a2c:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a30:	8d 71 01             	lea    0x1(%ecx),%esi
  802a33:	66 89 70 24          	mov    %si,0x24(%eax)
  802a37:	0f b7 c9             	movzwl %cx,%ecx
  802a3a:	89 d3                	mov    %edx,%ebx
  802a3c:	c1 eb 10             	shr    $0x10,%ebx
  802a3f:	8b 70 20             	mov    0x20(%eax),%esi
  802a42:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802a49:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a4d:	8d 71 01             	lea    0x1(%ecx),%esi
  802a50:	66 89 70 24          	mov    %si,0x24(%eax)
  802a54:	0f b7 c9             	movzwl %cx,%ecx
  802a57:	0f b6 de             	movzbl %dh,%ebx
  802a5a:	8b 70 20             	mov    0x20(%eax),%esi
  802a5d:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802a64:	8b 58 20             	mov    0x20(%eax),%ebx
  802a67:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a6b:	8d 71 01             	lea    0x1(%ecx),%esi
  802a6e:	66 89 70 24          	mov    %si,0x24(%eax)
  802a72:	0f b7 c9             	movzwl %cx,%ecx
  802a75:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802a7c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802a7f:	5b                   	pop    %ebx
  802a80:	5e                   	pop    %esi
  802a81:	5d                   	pop    %ebp
  802a82:	c3                   	ret    

00802a83 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  802a83:	55                   	push   %ebp
  802a84:	89 e5                	mov    %esp,%ebp
  802a86:	57                   	push   %edi
  802a87:	56                   	push   %esi
  802a88:	53                   	push   %ebx
  802a89:	83 ec 1c             	sub    $0x1c,%esp
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802a8c:	85 c0                	test   %eax,%eax
  802a8e:	75 17                	jne    802aa7 <dhcp_create_request+0x24>
  802a90:	83 ec 04             	sub    $0x4,%esp
  802a93:	68 8c 11 81 00       	push   $0x81118c
  802a98:	68 2d 05 00 00       	push   $0x52d
  802a9d:	68 42 13 81 00       	push   $0x811342
  802aa2:	e8 b1 b8 00 00       	call   80e358 <_panic>
  802aa7:	89 c7                	mov    %eax,%edi
  dhcp = netif->dhcp;
  802aa9:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802aac:	85 db                	test   %ebx,%ebx
  802aae:	75 17                	jne    802ac7 <dhcp_create_request+0x44>
  802ab0:	83 ec 04             	sub    $0x4,%esp
  802ab3:	68 b0 11 81 00       	push   $0x8111b0
  802ab8:	68 2f 05 00 00       	push   $0x52f
  802abd:	68 42 13 81 00       	push   $0x811342
  802ac2:	e8 91 b8 00 00       	call   80e358 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802ac7:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802acb:	74 17                	je     802ae4 <dhcp_create_request+0x61>
  802acd:	83 ec 04             	sub    $0x4,%esp
  802ad0:	68 d4 11 81 00       	push   $0x8111d4
  802ad5:	68 30 05 00 00       	push   $0x530
  802ada:	68 42 13 81 00       	push   $0x811342
  802adf:	e8 74 b8 00 00       	call   80e358 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802ae4:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802ae8:	74 17                	je     802b01 <dhcp_create_request+0x7e>
  802aea:	83 ec 04             	sub    $0x4,%esp
  802aed:	68 00 12 81 00       	push   $0x811200
  802af2:	68 31 05 00 00       	push   $0x531
  802af7:	68 42 13 81 00       	push   $0x811342
  802afc:	e8 57 b8 00 00       	call   80e358 <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802b01:	83 ec 04             	sub    $0x4,%esp
  802b04:	6a 00                	push   $0x0
  802b06:	68 34 01 00 00       	push   $0x134
  802b0b:	6a 00                	push   $0x0
  802b0d:	e8 d8 1c 00 00       	call   8047ea <pbuf_alloc>
  802b12:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802b15:	83 c4 10             	add    $0x10,%esp
  802b18:	85 c0                	test   %eax,%eax
  802b1a:	0f 84 37 01 00 00    	je     802c57 <dhcp_create_request+0x1d4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802b20:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802b26:	77 17                	ja     802b3f <dhcp_create_request+0xbc>
  802b28:	83 ec 04             	sub    $0x4,%esp
  802b2b:	68 2c 12 81 00       	push   $0x81122c
  802b30:	68 38 05 00 00       	push   $0x538
  802b35:	68 42 13 81 00       	push   $0x811342
  802b3a:	e8 19 b8 00 00       	call   80e358 <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  802b3f:	8b 15 04 40 81 00    	mov    0x814004,%edx
  802b45:	8d 4a 01             	lea    0x1(%edx),%ecx
  802b48:	89 0d 04 40 81 00    	mov    %ecx,0x814004
  802b4e:	89 53 04             	mov    %edx,0x4(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802b51:	8b 40 04             	mov    0x4(%eax),%eax
  802b54:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802b57:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802b5a:	8b 43 20             	mov    0x20(%ebx),%eax
  802b5d:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802b61:	8b 43 20             	mov    0x20(%ebx),%eax
  802b64:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802b68:	8b 43 20             	mov    0x20(%ebx),%eax
  802b6b:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802b6f:	8b 73 20             	mov    0x20(%ebx),%esi
  802b72:	83 ec 0c             	sub    $0xc,%esp
  802b75:	ff 73 04             	pushl  0x4(%ebx)
  802b78:	e8 72 4a 00 00       	call   8075ef <htonl>
  802b7d:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  802b80:	8b 43 20             	mov    0x20(%ebx),%eax
  802b83:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802b89:	8b 43 20             	mov    0x20(%ebx),%eax
  802b8c:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802b92:	8b 43 20             	mov    0x20(%ebx),%eax
  802b95:	8b 57 04             	mov    0x4(%edi),%edx
  802b98:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802b9b:	8b 43 20             	mov    0x20(%ebx),%eax
  802b9e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802ba5:	8b 43 20             	mov    0x20(%ebx),%eax
  802ba8:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802baf:	8b 43 20             	mov    0x20(%ebx),%eax
  802bb2:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802bb9:	83 c4 10             	add    $0x10,%esp
  802bbc:	b8 00 00 00 00       	mov    $0x0,%eax
  802bc1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802bc4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  802bc7:	8b 59 20             	mov    0x20(%ecx),%ebx
  802bca:	89 c1                	mov    %eax,%ecx
  802bcc:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  802bd0:	ba 00 00 00 00       	mov    $0x0,%edx
  802bd5:	66 39 c6             	cmp    %ax,%si
  802bd8:	76 05                	jbe    802bdf <dhcp_create_request+0x15c>
  802bda:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  802bdf:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  802be3:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802be6:	83 f8 10             	cmp    $0x10,%eax
  802be9:	75 d9                	jne    802bc4 <dhcp_create_request+0x141>
  802beb:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  802bee:	b8 00 00 00 00       	mov    $0x0,%eax
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  802bf3:	8b 53 20             	mov    0x20(%ebx),%edx
  802bf6:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802bfb:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802bfe:	83 f8 40             	cmp    $0x40,%eax
  802c01:	75 f0                	jne    802bf3 <dhcp_create_request+0x170>
  802c03:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  802c08:	8b 53 20             	mov    0x20(%ebx),%edx
  802c0b:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802c10:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802c13:	3d 80 00 00 00       	cmp    $0x80,%eax
  802c18:	75 ee                	jne    802c08 <dhcp_create_request+0x185>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802c1a:	8b 73 20             	mov    0x20(%ebx),%esi
  802c1d:	83 ec 0c             	sub    $0xc,%esp
  802c20:	68 63 53 82 63       	push   $0x63825363
  802c25:	e8 c5 49 00 00       	call   8075ef <htonl>
  802c2a:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802c30:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802c36:	83 c4 10             	add    $0x10,%esp
  802c39:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802c3e:	8b 53 20             	mov    0x20(%ebx),%edx
  802c41:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802c48:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802c4b:	83 f8 44             	cmp    $0x44,%eax
  802c4e:	75 ee                	jne    802c3e <dhcp_create_request+0x1bb>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  802c50:	b8 00 00 00 00       	mov    $0x0,%eax
  802c55:	eb 05                	jmp    802c5c <dhcp_create_request+0x1d9>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  802c57:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  802c5c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802c5f:	5b                   	pop    %ebx
  802c60:	5e                   	pop    %esi
  802c61:	5f                   	pop    %edi
  802c62:	5d                   	pop    %ebp
  802c63:	c3                   	ret    

00802c64 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  802c64:	55                   	push   %ebp
  802c65:	89 e5                	mov    %esp,%ebp
  802c67:	53                   	push   %ebx
  802c68:	83 ec 04             	sub    $0x4,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802c6b:	85 c0                	test   %eax,%eax
  802c6d:	75 17                	jne    802c86 <dhcp_delete_request+0x22>
  802c6f:	83 ec 04             	sub    $0x4,%esp
  802c72:	68 70 12 81 00       	push   $0x811270
  802c77:	68 69 05 00 00       	push   $0x569
  802c7c:	68 42 13 81 00       	push   $0x811342
  802c81:	e8 d2 b6 00 00       	call   80e358 <_panic>
  dhcp = netif->dhcp;
  802c86:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802c89:	85 db                	test   %ebx,%ebx
  802c8b:	75 17                	jne    802ca4 <dhcp_delete_request+0x40>
  802c8d:	83 ec 04             	sub    $0x4,%esp
  802c90:	68 94 12 81 00       	push   $0x811294
  802c95:	68 6b 05 00 00       	push   $0x56b
  802c9a:	68 42 13 81 00       	push   $0x811342
  802c9f:	e8 b4 b6 00 00       	call   80e358 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802ca4:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802ca7:	85 c0                	test   %eax,%eax
  802ca9:	75 17                	jne    802cc2 <dhcp_delete_request+0x5e>
  802cab:	83 ec 04             	sub    $0x4,%esp
  802cae:	68 b8 12 81 00       	push   $0x8112b8
  802cb3:	68 6c 05 00 00       	push   $0x56c
  802cb8:	68 42 13 81 00       	push   $0x811342
  802cbd:	e8 96 b6 00 00       	call   80e358 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802cc2:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802cc6:	75 17                	jne    802cdf <dhcp_delete_request+0x7b>
  802cc8:	83 ec 04             	sub    $0x4,%esp
  802ccb:	68 e4 12 81 00       	push   $0x8112e4
  802cd0:	68 6d 05 00 00       	push   $0x56d
  802cd5:	68 42 13 81 00       	push   $0x811342
  802cda:	e8 79 b6 00 00       	call   80e358 <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  802cdf:	83 ec 0c             	sub    $0xc,%esp
  802ce2:	50                   	push   %eax
  802ce3:	e8 3c 1a 00 00       	call   804724 <pbuf_free>
  }
  dhcp->p_out = NULL;
  802ce8:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802cef:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  802cf6:	83 c4 10             	add    $0x10,%esp
  802cf9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802cfc:	c9                   	leave  
  802cfd:	c3                   	ret    

00802cfe <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  802cfe:	55                   	push   %ebp
  802cff:	89 e5                	mov    %esp,%ebp
  802d01:	57                   	push   %edi
  802d02:	56                   	push   %esi
  802d03:	53                   	push   %ebx
  802d04:	83 ec 0c             	sub    $0xc,%esp
  802d07:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802d09:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802d0c:	ba 04 00 00 00       	mov    $0x4,%edx
  802d11:	89 d8                	mov    %ebx,%eax
  802d13:	e8 cf f9 ff ff       	call   8026e7 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  802d18:	89 f8                	mov    %edi,%eax
  802d1a:	e8 64 fd ff ff       	call   802a83 <dhcp_create_request>
  802d1f:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802d21:	84 c0                	test   %al,%al
  802d23:	0f 85 89 00 00 00    	jne    802db2 <dhcp_rebind+0xb4>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802d29:	b9 01 00 00 00       	mov    $0x1,%ecx
  802d2e:	ba 35 00 00 00       	mov    $0x35,%edx
  802d33:	89 d8                	mov    %ebx,%eax
  802d35:	e8 2e fb ff ff       	call   802868 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802d3a:	ba 03 00 00 00       	mov    $0x3,%edx
  802d3f:	89 d8                	mov    %ebx,%eax
  802d41:	e8 e1 fa ff ff       	call   802827 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802d46:	b9 02 00 00 00       	mov    $0x2,%ecx
  802d4b:	ba 39 00 00 00       	mov    $0x39,%edx
  802d50:	89 d8                	mov    %ebx,%eax
  802d52:	e8 11 fb ff ff       	call   802868 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802d57:	ba 40 02 00 00       	mov    $0x240,%edx
  802d5c:	89 d8                	mov    %ebx,%eax
  802d5e:	e8 6c fb ff ff       	call   8028cf <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  802d63:	89 d8                	mov    %ebx,%eax
  802d65:	e8 c9 fb ff ff       	call   802933 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802d6a:	83 ec 08             	sub    $0x8,%esp
  802d6d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802d71:	66 05 f0 00          	add    $0xf0,%ax
  802d75:	0f b7 c0             	movzwl %ax,%eax
  802d78:	50                   	push   %eax
  802d79:	ff 73 1c             	pushl  0x1c(%ebx)
  802d7c:	e8 ec 1c 00 00       	call   804a6d <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802d81:	83 c4 0c             	add    $0xc,%esp
  802d84:	6a 43                	push   $0x43
  802d86:	68 04 1c 81 00       	push   $0x811c04
  802d8b:	ff 73 08             	pushl  0x8(%ebx)
  802d8e:	e8 f6 5f 00 00       	call   808d89 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802d93:	89 3c 24             	mov    %edi,(%esp)
  802d96:	6a 43                	push   $0x43
  802d98:	68 00 1c 81 00       	push   $0x811c00
  802d9d:	ff 73 1c             	pushl  0x1c(%ebx)
  802da0:	ff 73 08             	pushl  0x8(%ebx)
  802da3:	e8 fb 5d 00 00       	call   808ba3 <udp_sendto_if>
    dhcp_delete_request(netif);
  802da8:	83 c4 20             	add    $0x20,%esp
  802dab:	89 f8                	mov    %edi,%eax
  802dad:	e8 b2 fe ff ff       	call   802c64 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  802db2:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802db6:	83 c0 01             	add    $0x1,%eax
  802db9:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802dbc:	ba 10 27 00 00       	mov    $0x2710,%edx
  802dc1:	3c 09                	cmp    $0x9,%al
  802dc3:	77 08                	ja     802dcd <dhcp_rebind+0xcf>
  802dc5:	0f b6 c0             	movzbl %al,%eax
  802dc8:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802dcd:	0f b7 c2             	movzwl %dx,%eax
  802dd0:	05 f3 01 00 00       	add    $0x1f3,%eax
  802dd5:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  802dda:	f7 ea                	imul   %edx
  802ddc:	c1 fa 05             	sar    $0x5,%edx
  802ddf:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  802de3:	89 f0                	mov    %esi,%eax
  802de5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802de8:	5b                   	pop    %ebx
  802de9:	5e                   	pop    %esi
  802dea:	5f                   	pop    %edi
  802deb:	5d                   	pop    %ebp
  802dec:	c3                   	ret    

00802ded <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  802ded:	55                   	push   %ebp
  802dee:	89 e5                	mov    %esp,%ebp
  802df0:	57                   	push   %edi
  802df1:	56                   	push   %esi
  802df2:	53                   	push   %ebx
  802df3:	83 ec 0c             	sub    $0xc,%esp
  802df6:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802df8:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  802dfb:	a1 04 1c 81 00       	mov    0x811c04,%eax
  802e00:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  802e03:	89 f8                	mov    %edi,%eax
  802e05:	e8 79 fc ff ff       	call   802a83 <dhcp_create_request>
  802e0a:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802e0c:	84 c0                	test   %al,%al
  802e0e:	0f 85 d6 00 00 00    	jne    802eea <dhcp_discover+0xfd>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802e14:	b9 01 00 00 00       	mov    $0x1,%ecx
  802e19:	ba 35 00 00 00       	mov    $0x35,%edx
  802e1e:	89 d8                	mov    %ebx,%eax
  802e20:	e8 43 fa ff ff       	call   802868 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  802e25:	ba 01 00 00 00       	mov    $0x1,%edx
  802e2a:	89 d8                	mov    %ebx,%eax
  802e2c:	e8 f6 f9 ff ff       	call   802827 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802e31:	b9 02 00 00 00       	mov    $0x2,%ecx
  802e36:	ba 39 00 00 00       	mov    $0x39,%edx
  802e3b:	89 d8                	mov    %ebx,%eax
  802e3d:	e8 26 fa ff ff       	call   802868 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802e42:	ba 40 02 00 00       	mov    $0x240,%edx
  802e47:	89 d8                	mov    %ebx,%eax
  802e49:	e8 81 fa ff ff       	call   8028cf <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  802e4e:	b9 04 00 00 00       	mov    $0x4,%ecx
  802e53:	ba 37 00 00 00       	mov    $0x37,%edx
  802e58:	89 d8                	mov    %ebx,%eax
  802e5a:	e8 09 fa ff ff       	call   802868 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  802e5f:	ba 01 00 00 00       	mov    $0x1,%edx
  802e64:	89 d8                	mov    %ebx,%eax
  802e66:	e8 bc f9 ff ff       	call   802827 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  802e6b:	ba 03 00 00 00       	mov    $0x3,%edx
  802e70:	89 d8                	mov    %ebx,%eax
  802e72:	e8 b0 f9 ff ff       	call   802827 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  802e77:	ba 1c 00 00 00       	mov    $0x1c,%edx
  802e7c:	89 d8                	mov    %ebx,%eax
  802e7e:	e8 a4 f9 ff ff       	call   802827 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  802e83:	ba 06 00 00 00       	mov    $0x6,%edx
  802e88:	89 d8                	mov    %ebx,%eax
  802e8a:	e8 98 f9 ff ff       	call   802827 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  802e8f:	89 d8                	mov    %ebx,%eax
  802e91:	e8 9d fa ff ff       	call   802933 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802e96:	83 ec 08             	sub    $0x8,%esp
  802e99:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802e9d:	66 05 f0 00          	add    $0xf0,%ax
  802ea1:	0f b7 c0             	movzwl %ax,%eax
  802ea4:	50                   	push   %eax
  802ea5:	ff 73 1c             	pushl  0x1c(%ebx)
  802ea8:	e8 c0 1b 00 00       	call   804a6d <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802ead:	83 c4 0c             	add    $0xc,%esp
  802eb0:	6a 43                	push   $0x43
  802eb2:	68 04 1c 81 00       	push   $0x811c04
  802eb7:	ff 73 08             	pushl  0x8(%ebx)
  802eba:	e8 ca 5e 00 00       	call   808d89 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802ebf:	89 3c 24             	mov    %edi,(%esp)
  802ec2:	6a 43                	push   $0x43
  802ec4:	68 00 1c 81 00       	push   $0x811c00
  802ec9:	ff 73 1c             	pushl  0x1c(%ebx)
  802ecc:	ff 73 08             	pushl  0x8(%ebx)
  802ecf:	e8 cf 5c 00 00       	call   808ba3 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  802ed4:	83 c4 20             	add    $0x20,%esp
  802ed7:	89 f8                	mov    %edi,%eax
  802ed9:	e8 86 fd ff ff       	call   802c64 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  802ede:	ba 06 00 00 00       	mov    $0x6,%edx
  802ee3:	89 d8                	mov    %ebx,%eax
  802ee5:	e8 fd f7 ff ff       	call   8026e7 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  802eea:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802eee:	83 c0 01             	add    $0x1,%eax
  802ef1:	88 43 01             	mov    %al,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  802ef4:	ba 10 27 00 00       	mov    $0x2710,%edx
  802ef9:	3c 03                	cmp    $0x3,%al
  802efb:	77 0b                	ja     802f08 <dhcp_discover+0x11b>
  802efd:	0f b6 c0             	movzbl %al,%eax
  802f00:	83 c0 01             	add    $0x1,%eax
  802f03:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802f08:	0f b7 c2             	movzwl %dx,%eax
  802f0b:	05 f3 01 00 00       	add    $0x1f3,%eax
  802f10:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  802f15:	f7 ea                	imul   %edx
  802f17:	c1 fa 05             	sar    $0x5,%edx
  802f1a:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  802f1e:	89 f0                	mov    %esi,%eax
  802f20:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802f23:	5b                   	pop    %ebx
  802f24:	5e                   	pop    %esi
  802f25:	5f                   	pop    %edi
  802f26:	5d                   	pop    %ebp
  802f27:	c3                   	ret    

00802f28 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  802f28:	55                   	push   %ebp
  802f29:	89 e5                	mov    %esp,%ebp
  802f2b:	57                   	push   %edi
  802f2c:	56                   	push   %esi
  802f2d:	53                   	push   %ebx
  802f2e:	83 ec 0c             	sub    $0xc,%esp
  802f31:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802f33:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  802f36:	e8 48 fb ff ff       	call   802a83 <dhcp_create_request>
  802f3b:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802f3d:	84 c0                	test   %al,%al
  802f3f:	0f 85 20 01 00 00    	jne    803065 <dhcp_select+0x13d>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802f45:	b9 01 00 00 00       	mov    $0x1,%ecx
  802f4a:	ba 35 00 00 00       	mov    $0x35,%edx
  802f4f:	89 d8                	mov    %ebx,%eax
  802f51:	e8 12 f9 ff ff       	call   802868 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802f56:	ba 03 00 00 00       	mov    $0x3,%edx
  802f5b:	89 d8                	mov    %ebx,%eax
  802f5d:	e8 c5 f8 ff ff       	call   802827 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802f62:	b9 02 00 00 00       	mov    $0x2,%ecx
  802f67:	ba 39 00 00 00       	mov    $0x39,%edx
  802f6c:	89 d8                	mov    %ebx,%eax
  802f6e:	e8 f5 f8 ff ff       	call   802868 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802f73:	ba 40 02 00 00       	mov    $0x240,%edx
  802f78:	89 d8                	mov    %ebx,%eax
  802f7a:	e8 50 f9 ff ff       	call   8028cf <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  802f7f:	b9 04 00 00 00       	mov    $0x4,%ecx
  802f84:	ba 32 00 00 00       	mov    $0x32,%edx
  802f89:	89 d8                	mov    %ebx,%eax
  802f8b:	e8 d8 f8 ff ff       	call   802868 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  802f90:	83 ec 0c             	sub    $0xc,%esp
  802f93:	ff 73 30             	pushl  0x30(%ebx)
  802f96:	e8 75 48 00 00       	call   807810 <ntohl>
  802f9b:	89 c2                	mov    %eax,%edx
  802f9d:	89 d8                	mov    %ebx,%eax
  802f9f:	e8 44 fa ff ff       	call   8029e8 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  802fa4:	b9 04 00 00 00       	mov    $0x4,%ecx
  802fa9:	ba 36 00 00 00       	mov    $0x36,%edx
  802fae:	89 d8                	mov    %ebx,%eax
  802fb0:	e8 b3 f8 ff ff       	call   802868 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  802fb5:	83 c4 04             	add    $0x4,%esp
  802fb8:	ff 73 2c             	pushl  0x2c(%ebx)
  802fbb:	e8 50 48 00 00       	call   807810 <ntohl>
  802fc0:	89 c2                	mov    %eax,%edx
  802fc2:	89 d8                	mov    %ebx,%eax
  802fc4:	e8 1f fa ff ff       	call   8029e8 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  802fc9:	b9 04 00 00 00       	mov    $0x4,%ecx
  802fce:	ba 37 00 00 00       	mov    $0x37,%edx
  802fd3:	89 d8                	mov    %ebx,%eax
  802fd5:	e8 8e f8 ff ff       	call   802868 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  802fda:	ba 01 00 00 00       	mov    $0x1,%edx
  802fdf:	89 d8                	mov    %ebx,%eax
  802fe1:	e8 41 f8 ff ff       	call   802827 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  802fe6:	ba 03 00 00 00       	mov    $0x3,%edx
  802feb:	89 d8                	mov    %ebx,%eax
  802fed:	e8 35 f8 ff ff       	call   802827 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  802ff2:	ba 1c 00 00 00       	mov    $0x1c,%edx
  802ff7:	89 d8                	mov    %ebx,%eax
  802ff9:	e8 29 f8 ff ff       	call   802827 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  802ffe:	ba 06 00 00 00       	mov    $0x6,%edx
  803003:	89 d8                	mov    %ebx,%eax
  803005:	e8 1d f8 ff ff       	call   802827 <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  80300a:	89 d8                	mov    %ebx,%eax
  80300c:	e8 22 f9 ff ff       	call   802933 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803011:	83 c4 08             	add    $0x8,%esp
  803014:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803018:	66 05 f0 00          	add    $0xf0,%ax
  80301c:	0f b7 c0             	movzwl %ax,%eax
  80301f:	50                   	push   %eax
  803020:	ff 73 1c             	pushl  0x1c(%ebx)
  803023:	e8 45 1a 00 00       	call   804a6d <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803028:	89 3c 24             	mov    %edi,(%esp)
  80302b:	6a 43                	push   $0x43
  80302d:	68 00 1c 81 00       	push   $0x811c00
  803032:	ff 73 1c             	pushl  0x1c(%ebx)
  803035:	ff 73 08             	pushl  0x8(%ebx)
  803038:	e8 66 5b 00 00       	call   808ba3 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80303d:	83 c4 1c             	add    $0x1c,%esp
  803040:	6a 43                	push   $0x43
  803042:	68 04 1c 81 00       	push   $0x811c04
  803047:	ff 73 08             	pushl  0x8(%ebx)
  80304a:	e8 3a 5d 00 00       	call   808d89 <udp_connect>
    dhcp_delete_request(netif);
  80304f:	89 f8                	mov    %edi,%eax
  803051:	e8 0e fc ff ff       	call   802c64 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  803056:	ba 01 00 00 00       	mov    $0x1,%edx
  80305b:	89 d8                	mov    %ebx,%eax
  80305d:	e8 85 f6 ff ff       	call   8026e7 <dhcp_set_state>
  803062:	83 c4 10             	add    $0x10,%esp
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803065:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803069:	83 c0 01             	add    $0x1,%eax
  80306c:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  80306f:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  803074:	3c 03                	cmp    $0x3,%al
  803076:	77 08                	ja     803080 <dhcp_select+0x158>
  803078:	0f b6 c0             	movzbl %al,%eax
  80307b:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803080:	0f b7 c2             	movzwl %dx,%eax
  803083:	05 f3 01 00 00       	add    $0x1f3,%eax
  803088:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80308d:	f7 ea                	imul   %edx
  80308f:	c1 fa 05             	sar    $0x5,%edx
  803092:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803096:	89 f0                	mov    %esi,%eax
  803098:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80309b:	5b                   	pop    %ebx
  80309c:	5e                   	pop    %esi
  80309d:	5f                   	pop    %edi
  80309e:	5d                   	pop    %ebp
  80309f:	c3                   	ret    

008030a0 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8030a0:	55                   	push   %ebp
  8030a1:	89 e5                	mov    %esp,%ebp
  8030a3:	53                   	push   %ebx
  8030a4:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  8030a7:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8030aa:	6a 00                	push   $0x0
  8030ac:	8d 53 30             	lea    0x30(%ebx),%edx
  8030af:	52                   	push   %edx
  8030b0:	50                   	push   %eax
  8030b1:	e8 9e 66 00 00       	call   809754 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  8030b6:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8030ba:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  8030c0:	ba 08 00 00 00       	mov    $0x8,%edx
  8030c5:	89 d8                	mov    %ebx,%eax
  8030c7:	e8 1b f6 ff ff       	call   8026e7 <dhcp_set_state>
}
  8030cc:	83 c4 10             	add    $0x10,%esp
  8030cf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8030d2:	c9                   	leave  
  8030d3:	c3                   	ret    

008030d4 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  8030d4:	55                   	push   %ebp
  8030d5:	89 e5                	mov    %esp,%ebp
  8030d7:	56                   	push   %esi
  8030d8:	53                   	push   %ebx
  8030d9:	83 ec 10             	sub    $0x10,%esp
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  8030dc:	85 c0                	test   %eax,%eax
  8030de:	75 17                	jne    8030f7 <dhcp_bind+0x23>
  8030e0:	83 ec 04             	sub    $0x4,%esp
  8030e3:	68 57 13 81 00       	push   $0x811357
  8030e8:	68 3d 03 00 00       	push   $0x33d
  8030ed:	68 42 13 81 00       	push   $0x811342
  8030f2:	e8 61 b2 00 00       	call   80e358 <_panic>
  8030f7:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  8030f9:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  8030fc:	85 db                	test   %ebx,%ebx
  8030fe:	75 17                	jne    803117 <dhcp_bind+0x43>
  803100:	83 ec 04             	sub    $0x4,%esp
  803103:	68 70 13 81 00       	push   $0x811370
  803108:	68 3f 03 00 00       	push   $0x33f
  80310d:	68 42 13 81 00       	push   $0x811342
  803112:	e8 41 b2 00 00       	call   80e358 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  803117:	8b 53 50             	mov    0x50(%ebx),%edx
  80311a:	83 fa ff             	cmp    $0xffffffff,%edx
  80311d:	74 2c                	je     80314b <dhcp_bind+0x77>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80311f:	83 c2 1e             	add    $0x1e,%edx
  803122:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803127:	89 d0                	mov    %edx,%eax
  803129:	f7 e1                	mul    %ecx
  80312b:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80312e:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  803134:	b8 ff ff 00 00       	mov    $0xffff,%eax
  803139:	0f 47 d0             	cmova  %eax,%edx
  80313c:	66 85 d2             	test   %dx,%dx
  80313f:	b8 01 00 00 00       	mov    $0x1,%eax
  803144:	0f 44 d0             	cmove  %eax,%edx
  803147:	66 89 53 28          	mov    %dx,0x28(%ebx)
      dhcp->t1_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80314b:	8b 53 54             	mov    0x54(%ebx),%edx
  80314e:	83 fa ff             	cmp    $0xffffffff,%edx
  803151:	74 2c                	je     80317f <dhcp_bind+0xab>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803153:	83 c2 1e             	add    $0x1e,%edx
  803156:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  80315b:	89 d0                	mov    %edx,%eax
  80315d:	f7 e1                	mul    %ecx
  80315f:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  803162:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  803168:	b8 ff ff 00 00       	mov    $0xffff,%eax
  80316d:	0f 47 d0             	cmova  %eax,%edx
  803170:	66 85 d2             	test   %dx,%dx
  803173:	b8 01 00 00 00       	mov    $0x1,%eax
  803178:	0f 44 d0             	cmove  %eax,%edx
  80317b:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80317f:	83 fb cc             	cmp    $0xffffffcc,%ebx
  803182:	0f 84 c4 00 00 00    	je     80324c <dhcp_bind+0x178>
  803188:	8b 43 34             	mov    0x34(%ebx),%eax
  80318b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  80318e:	85 c0                	test   %eax,%eax
  803190:	75 55                	jne    8031e7 <dhcp_bind+0x113>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  803192:	83 ec 0c             	sub    $0xc,%esp
  803195:	6a 00                	push   $0x0
  803197:	e8 74 46 00 00       	call   807810 <ntohl>
  80319c:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  80319f:	83 c4 10             	add    $0x10,%esp
  8031a2:	84 c0                	test   %al,%al
  8031a4:	78 15                	js     8031bb <dhcp_bind+0xe7>
      sn_mask.addr = htonl(0xff000000);
  8031a6:	83 ec 0c             	sub    $0xc,%esp
  8031a9:	68 00 00 00 ff       	push   $0xff000000
  8031ae:	e8 3c 44 00 00       	call   8075ef <htonl>
  8031b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8031b6:	83 c4 10             	add    $0x10,%esp
  8031b9:	eb 2c                	jmp    8031e7 <dhcp_bind+0x113>
    } else if (first_octet >= 192) {
  8031bb:	3c bf                	cmp    $0xbf,%al
  8031bd:	76 15                	jbe    8031d4 <dhcp_bind+0x100>
      sn_mask.addr = htonl(0xffffff00);
  8031bf:	83 ec 0c             	sub    $0xc,%esp
  8031c2:	68 00 ff ff ff       	push   $0xffffff00
  8031c7:	e8 23 44 00 00       	call   8075ef <htonl>
  8031cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8031cf:	83 c4 10             	add    $0x10,%esp
  8031d2:	eb 13                	jmp    8031e7 <dhcp_bind+0x113>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  8031d4:	83 ec 0c             	sub    $0xc,%esp
  8031d7:	68 00 00 ff ff       	push   $0xffff0000
  8031dc:	e8 0e 44 00 00       	call   8075ef <htonl>
  8031e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8031e4:	83 c4 10             	add    $0x10,%esp
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8031e7:	83 fb c8             	cmp    $0xffffffc8,%ebx
  8031ea:	74 0a                	je     8031f6 <dhcp_bind+0x122>
  8031ec:	8b 43 38             	mov    0x38(%ebx),%eax
  8031ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  8031f2:	85 c0                	test   %eax,%eax
  8031f4:	75 19                	jne    80320f <dhcp_bind+0x13b>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  8031f6:	8b 43 30             	mov    0x30(%ebx),%eax
  8031f9:	23 45 f4             	and    -0xc(%ebp),%eax
  8031fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  8031ff:	83 ec 0c             	sub    $0xc,%esp
  803202:	6a 01                	push   $0x1
  803204:	e8 e6 43 00 00       	call   8075ef <htonl>
  803209:	09 45 f0             	or     %eax,-0x10(%ebp)
  80320c:	83 c4 10             	add    $0x10,%esp
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  80320f:	83 ec 08             	sub    $0x8,%esp
  803212:	8d 43 30             	lea    0x30(%ebx),%eax
  803215:	50                   	push   %eax
  803216:	56                   	push   %esi
  803217:	e8 55 12 00 00       	call   804471 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  80321c:	83 c4 08             	add    $0x8,%esp
  80321f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  803222:	50                   	push   %eax
  803223:	56                   	push   %esi
  803224:	e8 ab 13 00 00       	call   8045d4 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  803229:	83 c4 08             	add    $0x8,%esp
  80322c:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80322f:	50                   	push   %eax
  803230:	56                   	push   %esi
  803231:	e8 83 13 00 00       	call   8045b9 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  803236:	89 34 24             	mov    %esi,(%esp)
  803239:	e8 be 13 00 00       	call   8045fc <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  80323e:	ba 0a 00 00 00       	mov    $0xa,%edx
  803243:	89 d8                	mov    %ebx,%eax
  803245:	e8 9d f4 ff ff       	call   8026e7 <dhcp_set_state>
}
  80324a:	eb 0c                	jmp    803258 <dhcp_bind+0x184>
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80324c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  803253:	e9 3a ff ff ff       	jmp    803192 <dhcp_bind+0xbe>
  netif_set_gw(netif, &gw_addr);
  /* bring the interface up */
  netif_set_up(netif);
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
}
  803258:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80325b:	5b                   	pop    %ebx
  80325c:	5e                   	pop    %esi
  80325d:	5d                   	pop    %ebp
  80325e:	c3                   	ret    

0080325f <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  80325f:	55                   	push   %ebp
  803260:	89 e5                	mov    %esp,%ebp
  803262:	53                   	push   %ebx
  803263:	83 ec 04             	sub    $0x4,%esp
  803266:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  803268:	8b 40 10             	mov    0x10(%eax),%eax
  80326b:	85 c0                	test   %eax,%eax
  80326d:	74 13                	je     803282 <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  80326f:	83 ec 0c             	sub    $0xc,%esp
  803272:	50                   	push   %eax
  803273:	e8 0a 0c 00 00       	call   803e82 <mem_free>
    dhcp->msg_in = NULL;
  803278:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80327f:	83 c4 10             	add    $0x10,%esp
  }
  if (dhcp->options_in) {
  803282:	8b 43 14             	mov    0x14(%ebx),%eax
  803285:	85 c0                	test   %eax,%eax
  803287:	74 19                	je     8032a2 <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  803289:	83 ec 0c             	sub    $0xc,%esp
  80328c:	50                   	push   %eax
  80328d:	e8 f0 0b 00 00       	call   803e82 <mem_free>
    dhcp->options_in = NULL;
  803292:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  803299:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  80329f:	83 c4 10             	add    $0x10,%esp
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  8032a2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8032a5:	c9                   	leave  
  8032a6:	c3                   	ret    

008032a7 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  8032a7:	55                   	push   %ebp
  8032a8:	89 e5                	mov    %esp,%ebp
  8032aa:	57                   	push   %edi
  8032ab:	56                   	push   %esi
  8032ac:	53                   	push   %ebx
  8032ad:	83 ec 1c             	sub    $0x1c,%esp
  8032b0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  8032b3:	8b 73 20             	mov    0x20(%ebx),%esi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  8032b6:	8b 45 10             	mov    0x10(%ebp),%eax
  8032b9:	8b 48 04             	mov    0x4(%eax),%ecx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  8032bc:	89 46 0c             	mov    %eax,0xc(%esi)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  8032bf:	80 39 02             	cmpb   $0x2,(%ecx)
  8032c2:	0f 85 b8 03 00 00    	jne    803680 <dhcp_recv+0x3d9>
  8032c8:	0f b6 7b 24          	movzbl 0x24(%ebx),%edi
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8032cc:	b8 00 00 00 00       	mov    $0x0,%eax
  8032d1:	eb 12                	jmp    8032e5 <dhcp_recv+0x3e>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  8032d3:	0f b6 54 03 25       	movzbl 0x25(%ebx,%eax,1),%edx
  8032d8:	83 c0 01             	add    $0x1,%eax
  8032db:	3a 54 01 1b          	cmp    0x1b(%ecx,%eax,1),%dl
  8032df:	0f 85 9b 03 00 00    	jne    803680 <dhcp_recv+0x3d9>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8032e5:	39 f8                	cmp    %edi,%eax
  8032e7:	75 ea                	jne    8032d3 <dhcp_recv+0x2c>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  8032e9:	83 ec 0c             	sub    $0xc,%esp
  8032ec:	ff 71 04             	pushl  0x4(%ecx)
  8032ef:	e8 1c 45 00 00       	call   807810 <ntohl>
  8032f4:	83 c4 10             	add    $0x10,%esp
  8032f7:	3b 46 04             	cmp    0x4(%esi),%eax
  8032fa:	0f 85 80 03 00 00    	jne    803680 <dhcp_recv+0x3d9>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  803300:	85 f6                	test   %esi,%esi
  803302:	75 17                	jne    80331b <dhcp_recv+0x74>
  803304:	83 ec 04             	sub    $0x4,%esp
  803307:	68 7b 13 81 00       	push   $0x81137b
  80330c:	68 89 04 00 00       	push   $0x489
  803311:	68 42 13 81 00       	push   $0x811342
  803316:	e8 3d b0 00 00       	call   80e358 <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80331b:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  80331f:	75 17                	jne    803338 <dhcp_recv+0x91>
  803321:	83 ec 04             	sub    $0x4,%esp
  803324:	68 88 13 81 00       	push   $0x811388
  803329:	68 8a 04 00 00       	push   $0x48a
  80332e:	68 42 13 81 00       	push   $0x811342
  803333:	e8 20 b0 00 00       	call   80e358 <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  803338:	89 f0                	mov    %esi,%eax
  80333a:	e8 20 ff ff ff       	call   80325f <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80333f:	8b 46 0c             	mov    0xc(%esi),%eax
  803342:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  803346:	66 3d f0 00          	cmp    $0xf0,%ax
  80334a:	76 22                	jbe    80336e <dhcp_recv+0xc7>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80334c:	66 2d f0 00          	sub    $0xf0,%ax
  803350:	66 89 46 18          	mov    %ax,0x18(%esi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  803354:	83 ec 0c             	sub    $0xc,%esp
  803357:	0f b7 c0             	movzwl %ax,%eax
  80335a:	50                   	push   %eax
  80335b:	e8 d4 0d 00 00       	call   804134 <mem_malloc>
  803360:	89 46 14             	mov    %eax,0x14(%esi)
    if (dhcp->options_in == NULL) {
  803363:	83 c4 10             	add    $0x10,%esp
  803366:	85 c0                	test   %eax,%eax
  803368:	0f 84 12 03 00 00    	je     803680 <dhcp_recv+0x3d9>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80336e:	83 ec 0c             	sub    $0xc,%esp
  803371:	68 f0 00 00 00       	push   $0xf0
  803376:	e8 b9 0d 00 00       	call   804134 <mem_malloc>
  80337b:	89 46 10             	mov    %eax,0x10(%esi)
  if (dhcp->msg_in == NULL) {
  80337e:	83 c4 10             	add    $0x10,%esp
  803381:	85 c0                	test   %eax,%eax
  803383:	75 1a                	jne    80339f <dhcp_recv+0xf8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  803385:	83 ec 0c             	sub    $0xc,%esp
  803388:	ff 76 14             	pushl  0x14(%esi)
  80338b:	e8 f2 0a 00 00       	call   803e82 <mem_free>
    dhcp->options_in = NULL;
  803390:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  803397:	83 c4 10             	add    $0x10,%esp
  80339a:	e9 e1 02 00 00       	jmp    803680 <dhcp_recv+0x3d9>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80339f:	6a 00                	push   $0x0
  8033a1:	68 f0 00 00 00       	push   $0xf0
  8033a6:	50                   	push   %eax
  8033a7:	ff 76 0c             	pushl  0xc(%esi)
  8033aa:	e8 c5 1a 00 00       	call   804e74 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8033af:	83 c4 10             	add    $0x10,%esp
  8033b2:	66 3d f0 00          	cmp    $0xf0,%ax
  8033b6:	74 17                	je     8033cf <dhcp_recv+0x128>
  8033b8:	83 ec 04             	sub    $0x4,%esp
  8033bb:	68 10 13 81 00       	push   $0x811310
  8033c0:	68 a0 04 00 00       	push   $0x4a0
  8033c5:	68 42 13 81 00       	push   $0x811342
  8033ca:	e8 89 af 00 00       	call   80e358 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  8033cf:	8b 46 14             	mov    0x14(%esi),%eax
  8033d2:	85 c0                	test   %eax,%eax
  8033d4:	0f 84 ba 02 00 00    	je     803694 <dhcp_recv+0x3ed>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8033da:	68 f0 00 00 00       	push   $0xf0
  8033df:	0f b7 56 18          	movzwl 0x18(%esi),%edx
  8033e3:	52                   	push   %edx
  8033e4:	50                   	push   %eax
  8033e5:	ff 76 0c             	pushl  0xc(%esi)
  8033e8:	e8 87 1a 00 00       	call   804e74 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  8033ed:	83 c4 10             	add    $0x10,%esp
  8033f0:	66 3b 46 18          	cmp    0x18(%esi),%ax
  8033f4:	0f 84 9a 02 00 00    	je     803694 <dhcp_recv+0x3ed>
  8033fa:	83 ec 04             	sub    $0x4,%esp
  8033fd:	68 98 13 81 00       	push   $0x811398
  803402:	68 a7 04 00 00       	push   $0x4a7
  803407:	68 42 13 81 00       	push   $0x811342
  80340c:	e8 47 af 00 00       	call   80e358 <_panic>
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  803411:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  803415:	3c 05                	cmp    $0x5,%al
  803417:	0f 85 a3 01 00 00    	jne    8035c0 <dhcp_recv+0x319>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  80341d:	0f b6 06             	movzbl (%esi),%eax
  803420:	3c 01                	cmp    $0x1,%al
  803422:	0f 85 7b 01 00 00    	jne    8035a3 <dhcp_recv+0x2fc>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803428:	8b 7b 20             	mov    0x20(%ebx),%edi
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  80342b:	c7 47 34 00 00 00 00 	movl   $0x0,0x34(%edi)
  dhcp->offered_gw_addr.addr = 0;
  803432:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  dhcp->offered_bc_addr.addr = 0;
  803439:	c7 47 3c 00 00 00 00 	movl   $0x0,0x3c(%edi)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  803440:	ba 33 00 00 00       	mov    $0x33,%edx
  803445:	89 f8                	mov    %edi,%eax
  803447:	e8 aa f2 ff ff       	call   8026f6 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80344c:	85 c0                	test   %eax,%eax
  80344e:	74 0b                	je     80345b <dhcp_recv+0x1b4>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  803450:	83 c0 02             	add    $0x2,%eax
  803453:	e8 aa f3 ff ff       	call   802802 <dhcp_get_option_long>
  803458:	89 47 4c             	mov    %eax,0x4c(%edi)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  80345b:	ba 3a 00 00 00       	mov    $0x3a,%edx
  803460:	89 f8                	mov    %edi,%eax
  803462:	e8 8f f2 ff ff       	call   8026f6 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803467:	85 c0                	test   %eax,%eax
  803469:	74 0d                	je     803478 <dhcp_recv+0x1d1>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  80346b:	83 c0 02             	add    $0x2,%eax
  80346e:	e8 8f f3 ff ff       	call   802802 <dhcp_get_option_long>
  803473:	89 47 50             	mov    %eax,0x50(%edi)
  803476:	eb 08                	jmp    803480 <dhcp_recv+0x1d9>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  803478:	8b 47 4c             	mov    0x4c(%edi),%eax
  80347b:	d1 e8                	shr    %eax
  80347d:	89 47 50             	mov    %eax,0x50(%edi)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  803480:	ba 3b 00 00 00       	mov    $0x3b,%edx
  803485:	89 f8                	mov    %edi,%eax
  803487:	e8 6a f2 ff ff       	call   8026f6 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80348c:	85 c0                	test   %eax,%eax
  80348e:	74 0d                	je     80349d <dhcp_recv+0x1f6>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  803490:	83 c0 02             	add    $0x2,%eax
  803493:	e8 6a f3 ff ff       	call   802802 <dhcp_get_option_long>
  803498:	89 47 54             	mov    %eax,0x54(%edi)
  80349b:	eb 06                	jmp    8034a3 <dhcp_recv+0x1fc>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  80349d:	8b 47 4c             	mov    0x4c(%edi),%eax
  8034a0:	89 47 54             	mov    %eax,0x54(%edi)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8034a3:	8b 47 10             	mov    0x10(%edi),%eax
  8034a6:	83 f8 f0             	cmp    $0xfffffff0,%eax
  8034a9:	74 05                	je     8034b0 <dhcp_recv+0x209>
  8034ab:	8b 40 10             	mov    0x10(%eax),%eax
  8034ae:	eb 05                	jmp    8034b5 <dhcp_recv+0x20e>
  8034b0:	b8 00 00 00 00       	mov    $0x0,%eax
  8034b5:	89 47 30             	mov    %eax,0x30(%edi)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8034b8:	ba 01 00 00 00       	mov    $0x1,%edx
  8034bd:	89 f8                	mov    %edi,%eax
  8034bf:	e8 32 f2 ff ff       	call   8026f6 <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  8034c4:	85 c0                	test   %eax,%eax
  8034c6:	74 17                	je     8034df <dhcp_recv+0x238>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8034c8:	83 c0 02             	add    $0x2,%eax
  8034cb:	e8 32 f3 ff ff       	call   802802 <dhcp_get_option_long>
  8034d0:	83 ec 0c             	sub    $0xc,%esp
  8034d3:	50                   	push   %eax
  8034d4:	e8 16 41 00 00       	call   8075ef <htonl>
  8034d9:	89 47 34             	mov    %eax,0x34(%edi)
  8034dc:	83 c4 10             	add    $0x10,%esp
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8034df:	ba 03 00 00 00       	mov    $0x3,%edx
  8034e4:	89 f8                	mov    %edi,%eax
  8034e6:	e8 0b f2 ff ff       	call   8026f6 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8034eb:	85 c0                	test   %eax,%eax
  8034ed:	74 17                	je     803506 <dhcp_recv+0x25f>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8034ef:	83 c0 02             	add    $0x2,%eax
  8034f2:	e8 0b f3 ff ff       	call   802802 <dhcp_get_option_long>
  8034f7:	83 ec 0c             	sub    $0xc,%esp
  8034fa:	50                   	push   %eax
  8034fb:	e8 ef 40 00 00       	call   8075ef <htonl>
  803500:	89 47 38             	mov    %eax,0x38(%edi)
  803503:	83 c4 10             	add    $0x10,%esp
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  803506:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80350b:	89 f8                	mov    %edi,%eax
  80350d:	e8 e4 f1 ff ff       	call   8026f6 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803512:	85 c0                	test   %eax,%eax
  803514:	74 17                	je     80352d <dhcp_recv+0x286>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803516:	83 c0 02             	add    $0x2,%eax
  803519:	e8 e4 f2 ff ff       	call   802802 <dhcp_get_option_long>
  80351e:	83 ec 0c             	sub    $0xc,%esp
  803521:	50                   	push   %eax
  803522:	e8 c8 40 00 00       	call   8075ef <htonl>
  803527:	89 47 3c             	mov    %eax,0x3c(%edi)
  80352a:	83 c4 10             	add    $0x10,%esp
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  80352d:	ba 06 00 00 00       	mov    $0x6,%edx
  803532:	89 f8                	mov    %edi,%eax
  803534:	e8 bd f1 ff ff       	call   8026f6 <dhcp_get_option_ptr>
  803539:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (option_ptr != NULL) {
  80353c:	85 c0                	test   %eax,%eax
  80353e:	74 51                	je     803591 <dhcp_recv+0x2ea>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803540:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  803544:	c0 e8 02             	shr    $0x2,%al
  803547:	0f b6 c0             	movzbl %al,%eax
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  80354a:	83 f8 03             	cmp    $0x3,%eax
  80354d:	ba 02 00 00 00       	mov    $0x2,%edx
  803552:	0f 43 c2             	cmovae %edx,%eax
  803555:	89 47 40             	mov    %eax,0x40(%edi)
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803558:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80355c:	89 5d 08             	mov    %ebx,0x8(%ebp)
  80355f:	eb 24                	jmp    803585 <dhcp_recv+0x2de>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  803561:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  803565:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  803568:	8d 44 99 02          	lea    0x2(%ecx,%ebx,4),%eax
  80356c:	e8 91 f2 ff ff       	call   802802 <dhcp_get_option_long>
  803571:	83 ec 0c             	sub    $0xc,%esp
  803574:	50                   	push   %eax
  803575:	e8 75 40 00 00       	call   8075ef <htonl>
  80357a:	89 44 9f 44          	mov    %eax,0x44(%edi,%ebx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  80357e:	80 45 e7 01          	addb   $0x1,-0x19(%ebp)
  803582:	83 c4 10             	add    $0x10,%esp
  803585:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  803589:	3b 47 40             	cmp    0x40(%edi),%eax
  80358c:	72 d3                	jb     803561 <dhcp_recv+0x2ba>
  80358e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  803591:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  803597:	89 d8                	mov    %ebx,%eax
  803599:	e8 02 fb ff ff       	call   8030a0 <dhcp_check>
  80359e:	e9 dd 00 00 00       	jmp    803680 <dhcp_recv+0x3d9>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  8035a3:	83 e8 03             	sub    $0x3,%eax
  8035a6:	3c 02                	cmp    $0x2,%al
  8035a8:	0f 87 d2 00 00 00    	ja     803680 <dhcp_recv+0x3d9>
      dhcp->request_timeout = 0;
  8035ae:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
      dhcp_bind(netif);
  8035b4:	89 d8                	mov    %ebx,%eax
  8035b6:	e8 19 fb ff ff       	call   8030d4 <dhcp_bind>
  8035bb:	e9 c0 00 00 00       	jmp    803680 <dhcp_recv+0x3d9>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  8035c0:	3c 06                	cmp    $0x6,%al
  8035c2:	75 67                	jne    80362b <dhcp_recv+0x384>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8035c4:	0f b6 06             	movzbl (%esi),%eax
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  8035c7:	8d 50 fd             	lea    -0x3(%eax),%edx
  8035ca:	80 fa 02             	cmp    $0x2,%dl
  8035cd:	76 08                	jbe    8035d7 <dhcp_recv+0x330>
  8035cf:	3c 01                	cmp    $0x1,%al
  8035d1:	0f 85 a9 00 00 00    	jne    803680 <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  8035d7:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  8035dd:	8b 7b 20             	mov    0x20(%ebx),%edi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  8035e0:	83 ec 0c             	sub    $0xc,%esp
  8035e3:	53                   	push   %ebx
  8035e4:	e8 44 10 00 00       	call   80462d <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  8035e9:	83 c4 08             	add    $0x8,%esp
  8035ec:	68 04 1c 81 00       	push   $0x811c04
  8035f1:	53                   	push   %ebx
  8035f2:	e8 7a 0e 00 00       	call   804471 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  8035f7:	83 c4 08             	add    $0x8,%esp
  8035fa:	68 04 1c 81 00       	push   $0x811c04
  8035ff:	53                   	push   %ebx
  803600:	e8 b4 0f 00 00       	call   8045b9 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  803605:	83 c4 08             	add    $0x8,%esp
  803608:	68 04 1c 81 00       	push   $0x811c04
  80360d:	53                   	push   %ebx
  80360e:	e8 c1 0f 00 00       	call   8045d4 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803613:	ba 0c 00 00 00       	mov    $0xc,%edx
  803618:	89 f8                	mov    %edi,%eax
  80361a:	e8 c8 f0 ff ff       	call   8026e7 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  80361f:	89 d8                	mov    %ebx,%eax
  803621:	e8 c7 f7 ff ff       	call   802ded <dhcp_discover>
  803626:	83 c4 10             	add    $0x10,%esp
  803629:	eb 55                	jmp    803680 <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80362b:	3c 02                	cmp    $0x2,%al
  80362d:	75 51                	jne    803680 <dhcp_recv+0x3d9>
  80362f:	80 3e 06             	cmpb   $0x6,(%esi)
  803632:	75 4c                	jne    803680 <dhcp_recv+0x3d9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  803634:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  80363a:	8b 7b 20             	mov    0x20(%ebx),%edi
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  80363d:	ba 36 00 00 00       	mov    $0x36,%edx
  803642:	89 f8                	mov    %edi,%eax
  803644:	e8 ad f0 ff ff       	call   8026f6 <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  803649:	85 c0                	test   %eax,%eax
  80364b:	74 33                	je     803680 <dhcp_recv+0x3d9>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80364d:	83 c0 02             	add    $0x2,%eax
  803650:	e8 ad f1 ff ff       	call   802802 <dhcp_get_option_long>
  803655:	83 ec 0c             	sub    $0xc,%esp
  803658:	50                   	push   %eax
  803659:	e8 91 3f 00 00       	call   8075ef <htonl>
  80365e:	89 47 2c             	mov    %eax,0x2c(%edi)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  803661:	8b 47 10             	mov    0x10(%edi),%eax
  803664:	83 c4 10             	add    $0x10,%esp
  803667:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80366a:	74 05                	je     803671 <dhcp_recv+0x3ca>
  80366c:	8b 40 10             	mov    0x10(%eax),%eax
  80366f:	eb 05                	jmp    803676 <dhcp_recv+0x3cf>
  803671:	b8 00 00 00 00       	mov    $0x0,%eax
  803676:	89 47 30             	mov    %eax,0x30(%edi)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  803679:	89 d8                	mov    %ebx,%eax
  80367b:	e8 a8 f8 ff ff       	call   802f28 <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  803680:	83 ec 0c             	sub    $0xc,%esp
  803683:	ff 75 10             	pushl  0x10(%ebp)
  803686:	e8 99 10 00 00       	call   804724 <pbuf_free>
  dhcp->p = NULL;
  80368b:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
}
  803692:	eb 16                	jmp    8036aa <dhcp_recv+0x403>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  803694:	ba 35 00 00 00       	mov    $0x35,%edx
  803699:	89 f0                	mov    %esi,%eax
  80369b:	e8 56 f0 ff ff       	call   8026f6 <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  8036a0:	85 c0                	test   %eax,%eax
  8036a2:	0f 85 69 fd ff ff    	jne    803411 <dhcp_recv+0x16a>
  8036a8:	eb d6                	jmp    803680 <dhcp_recv+0x3d9>
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  dhcp->p = NULL;
}
  8036aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8036ad:	5b                   	pop    %ebx
  8036ae:	5e                   	pop    %esi
  8036af:	5f                   	pop    %edi
  8036b0:	5d                   	pop    %ebp
  8036b1:	c3                   	ret    

008036b2 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  8036b2:	55                   	push   %ebp
  8036b3:	89 e5                	mov    %esp,%ebp
  8036b5:	57                   	push   %edi
  8036b6:	56                   	push   %esi
  8036b7:	53                   	push   %ebx
  8036b8:	83 ec 18             	sub    $0x18,%esp
  8036bb:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  8036be:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  8036c1:	6a 58                	push   $0x58
  8036c3:	e8 6c 0a 00 00       	call   804134 <mem_malloc>
  if (dhcp == NULL) {
  8036c8:	83 c4 10             	add    $0x10,%esp
  8036cb:	85 c0                	test   %eax,%eax
  8036cd:	0f 84 1d 01 00 00    	je     8037f0 <dhcp_inform+0x13e>
  8036d3:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  8036d5:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  8036d8:	83 ec 04             	sub    $0x4,%esp
  8036db:	6a 58                	push   $0x58
  8036dd:	6a 00                	push   $0x0
  8036df:	50                   	push   %eax
  8036e0:	e8 16 b4 00 00       	call   80eafb <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  8036e5:	e8 83 57 00 00       	call   808e6d <udp_new>
  8036ea:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  8036ed:	83 c4 10             	add    $0x10,%esp
  8036f0:	85 c0                	test   %eax,%eax
  8036f2:	75 11                	jne    803705 <dhcp_inform+0x53>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  8036f4:	83 ec 0c             	sub    $0xc,%esp
  8036f7:	53                   	push   %ebx
  8036f8:	e8 85 07 00 00       	call   803e82 <mem_free>
    return;
  8036fd:	83 c4 10             	add    $0x10,%esp
  803700:	e9 eb 00 00 00       	jmp    8037f0 <dhcp_inform+0x13e>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803705:	89 f0                	mov    %esi,%eax
  803707:	e8 77 f3 ff ff       	call   802a83 <dhcp_create_request>
  if (result == ERR_OK) {
  80370c:	84 c0                	test   %al,%al
  80370e:	0f 85 d3 00 00 00    	jne    8037e7 <dhcp_inform+0x135>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803714:	b9 01 00 00 00       	mov    $0x1,%ecx
  803719:	ba 35 00 00 00       	mov    $0x35,%edx
  80371e:	89 d8                	mov    %ebx,%eax
  803720:	e8 43 f1 ff ff       	call   802868 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803725:	ba 08 00 00 00       	mov    $0x8,%edx
  80372a:	89 d8                	mov    %ebx,%eax
  80372c:	e8 f6 f0 ff ff       	call   802827 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803731:	b9 02 00 00 00       	mov    $0x2,%ecx
  803736:	ba 39 00 00 00       	mov    $0x39,%edx
  80373b:	89 d8                	mov    %ebx,%eax
  80373d:	e8 26 f1 ff ff       	call   802868 <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  803742:	ba 40 02 00 00       	mov    $0x240,%edx
  803747:	89 d8                	mov    %ebx,%eax
  803749:	e8 81 f1 ff ff       	call   8028cf <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  80374e:	89 d8                	mov    %ebx,%eax
  803750:	e8 de f1 ff ff       	call   802933 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803755:	83 ec 08             	sub    $0x8,%esp
  803758:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80375c:	66 05 f0 00          	add    $0xf0,%ax
  803760:	0f b7 c0             	movzwl %ax,%eax
  803763:	50                   	push   %eax
  803764:	ff 73 1c             	pushl  0x1c(%ebx)
  803767:	e8 01 13 00 00       	call   804a6d <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80376c:	83 c4 0c             	add    $0xc,%esp
  80376f:	6a 44                	push   $0x44
  803771:	68 04 1c 81 00       	push   $0x811c04
  803776:	ff 73 08             	pushl  0x8(%ebx)
  803779:	e8 69 53 00 00       	call   808ae7 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  80377e:	83 c4 0c             	add    $0xc,%esp
  803781:	6a 43                	push   $0x43
  803783:	68 00 1c 81 00       	push   $0x811c00
  803788:	ff 73 08             	pushl  0x8(%ebx)
  80378b:	e8 f9 55 00 00       	call   808d89 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803790:	89 34 24             	mov    %esi,(%esp)
  803793:	6a 43                	push   $0x43
  803795:	68 00 1c 81 00       	push   $0x811c00
  80379a:	ff 73 1c             	pushl  0x1c(%ebx)
  80379d:	ff 73 08             	pushl  0x8(%ebx)
  8037a0:	e8 fe 53 00 00       	call   808ba3 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8037a5:	83 c4 1c             	add    $0x1c,%esp
  8037a8:	6a 43                	push   $0x43
  8037aa:	68 04 1c 81 00       	push   $0x811c04
  8037af:	ff 73 08             	pushl  0x8(%ebx)
  8037b2:	e8 d2 55 00 00       	call   808d89 <udp_connect>
    dhcp_delete_request(netif);
  8037b7:	89 f0                	mov    %esi,%eax
  8037b9:	e8 a6 f4 ff ff       	call   802c64 <dhcp_delete_request>
  8037be:	83 c4 10             	add    $0x10,%esp
  8037c1:	eb 24                	jmp    8037e7 <dhcp_inform+0x135>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
      udp_remove(dhcp->pcb);
  8037c3:	83 ec 0c             	sub    $0xc,%esp
  8037c6:	50                   	push   %eax
  8037c7:	e8 5d 56 00 00       	call   808e29 <udp_remove>
  8037cc:	83 c4 10             	add    $0x10,%esp
    }
    dhcp->pcb = NULL;
  8037cf:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  8037d6:	83 ec 0c             	sub    $0xc,%esp
  8037d9:	53                   	push   %ebx
  8037da:	e8 a3 06 00 00       	call   803e82 <mem_free>
    netif->dhcp = old_dhcp;
  8037df:	89 7e 20             	mov    %edi,0x20(%esi)
  8037e2:	83 c4 10             	add    $0x10,%esp
  8037e5:	eb 09                	jmp    8037f0 <dhcp_inform+0x13e>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  8037e7:	8b 43 08             	mov    0x8(%ebx),%eax
  8037ea:	85 c0                	test   %eax,%eax
  8037ec:	75 d5                	jne    8037c3 <dhcp_inform+0x111>
  8037ee:	eb df                	jmp    8037cf <dhcp_inform+0x11d>
    }
    dhcp->pcb = NULL;
    mem_free((void *)dhcp);
    netif->dhcp = old_dhcp;
  }
}
  8037f0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8037f3:	5b                   	pop    %ebx
  8037f4:	5e                   	pop    %esi
  8037f5:	5f                   	pop    %edi
  8037f6:	5d                   	pop    %ebp
  8037f7:	c3                   	ret    

008037f8 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  8037f8:	55                   	push   %ebp
  8037f9:	89 e5                	mov    %esp,%ebp
  8037fb:	56                   	push   %esi
  8037fc:	53                   	push   %ebx
  8037fd:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803800:	85 f6                	test   %esi,%esi
  803802:	75 17                	jne    80381b <dhcp_arp_reply+0x23>
  803804:	83 ec 04             	sub    $0x4,%esp
  803807:	68 62 13 81 00       	push   $0x811362
  80380c:	68 b5 02 00 00       	push   $0x2b5
  803811:	68 42 13 81 00       	push   $0x811342
  803816:	e8 3d ab 00 00       	call   80e358 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  80381b:	8b 5e 20             	mov    0x20(%esi),%ebx
  80381e:	85 db                	test   %ebx,%ebx
  803820:	0f 84 ea 00 00 00    	je     803910 <dhcp_arp_reply+0x118>
  803826:	80 3b 08             	cmpb   $0x8,(%ebx)
  803829:	0f 85 e1 00 00 00    	jne    803910 <dhcp_arp_reply+0x118>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  80382f:	8b 45 0c             	mov    0xc(%ebp),%eax
  803832:	8b 4b 30             	mov    0x30(%ebx),%ecx
  803835:	39 08                	cmp    %ecx,(%eax)
  803837:	0f 85 d3 00 00 00    	jne    803910 <dhcp_arp_reply+0x118>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  80383d:	ba 0c 00 00 00       	mov    $0xc,%edx
  803842:	89 d8                	mov    %ebx,%eax
  803844:	e8 9e ee ff ff       	call   8026e7 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803849:	89 f0                	mov    %esi,%eax
  80384b:	e8 33 f2 ff ff       	call   802a83 <dhcp_create_request>
  if (result == ERR_OK) {
  803850:	84 c0                	test   %al,%al
  803852:	0f 85 ae 00 00 00    	jne    803906 <dhcp_arp_reply+0x10e>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803858:	b9 01 00 00 00       	mov    $0x1,%ecx
  80385d:	ba 35 00 00 00       	mov    $0x35,%edx
  803862:	89 d8                	mov    %ebx,%eax
  803864:	e8 ff ef ff ff       	call   802868 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803869:	ba 04 00 00 00       	mov    $0x4,%edx
  80386e:	89 d8                	mov    %ebx,%eax
  803870:	e8 b2 ef ff ff       	call   802827 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803875:	b9 02 00 00 00       	mov    $0x2,%ecx
  80387a:	ba 39 00 00 00       	mov    $0x39,%edx
  80387f:	89 d8                	mov    %ebx,%eax
  803881:	e8 e2 ef ff ff       	call   802868 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803886:	ba 40 02 00 00       	mov    $0x240,%edx
  80388b:	89 d8                	mov    %ebx,%eax
  80388d:	e8 3d f0 ff ff       	call   8028cf <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803892:	b9 04 00 00 00       	mov    $0x4,%ecx
  803897:	ba 32 00 00 00       	mov    $0x32,%edx
  80389c:	89 d8                	mov    %ebx,%eax
  80389e:	e8 c5 ef ff ff       	call   802868 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8038a3:	83 ec 0c             	sub    $0xc,%esp
  8038a6:	ff 73 30             	pushl  0x30(%ebx)
  8038a9:	e8 62 3f 00 00       	call   807810 <ntohl>
  8038ae:	89 c2                	mov    %eax,%edx
  8038b0:	89 d8                	mov    %ebx,%eax
  8038b2:	e8 31 f1 ff ff       	call   8029e8 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  8038b7:	89 d8                	mov    %ebx,%eax
  8038b9:	e8 75 f0 ff ff       	call   802933 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8038be:	83 c4 08             	add    $0x8,%esp
  8038c1:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8038c5:	66 05 f0 00          	add    $0xf0,%ax
  8038c9:	0f b7 c0             	movzwl %ax,%eax
  8038cc:	50                   	push   %eax
  8038cd:	ff 73 1c             	pushl  0x1c(%ebx)
  8038d0:	e8 98 11 00 00       	call   804a6d <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8038d5:	83 c4 0c             	add    $0xc,%esp
  8038d8:	6a 43                	push   $0x43
  8038da:	68 04 1c 81 00       	push   $0x811c04
  8038df:	ff 73 08             	pushl  0x8(%ebx)
  8038e2:	e8 a2 54 00 00       	call   808d89 <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8038e7:	89 34 24             	mov    %esi,(%esp)
  8038ea:	6a 43                	push   $0x43
  8038ec:	68 00 1c 81 00       	push   $0x811c00
  8038f1:	ff 73 1c             	pushl  0x1c(%ebx)
  8038f4:	ff 73 08             	pushl  0x8(%ebx)
  8038f7:	e8 a7 52 00 00       	call   808ba3 <udp_sendto_if>
    dhcp_delete_request(netif);
  8038fc:	83 c4 20             	add    $0x20,%esp
  8038ff:	89 f0                	mov    %esi,%eax
  803901:	e8 5e f3 ff ff       	call   802c64 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803906:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80390a:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  803910:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803913:	5b                   	pop    %ebx
  803914:	5e                   	pop    %esi
  803915:	5d                   	pop    %ebp
  803916:	c3                   	ret    

00803917 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  803917:	55                   	push   %ebp
  803918:	89 e5                	mov    %esp,%ebp
  80391a:	57                   	push   %edi
  80391b:	56                   	push   %esi
  80391c:	53                   	push   %ebx
  80391d:	83 ec 1c             	sub    $0x1c,%esp
  803920:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  803923:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803926:	ba 05 00 00 00       	mov    $0x5,%edx
  80392b:	89 d8                	mov    %ebx,%eax
  80392d:	e8 b5 ed ff ff       	call   8026e7 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803932:	89 f8                	mov    %edi,%eax
  803934:	e8 4a f1 ff ff       	call   802a83 <dhcp_create_request>
  803939:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  80393b:	84 c0                	test   %al,%al
  80393d:	0f 85 89 00 00 00    	jne    8039cc <dhcp_renew+0xb5>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803943:	b9 01 00 00 00       	mov    $0x1,%ecx
  803948:	ba 35 00 00 00       	mov    $0x35,%edx
  80394d:	89 d8                	mov    %ebx,%eax
  80394f:	e8 14 ef ff ff       	call   802868 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803954:	ba 03 00 00 00       	mov    $0x3,%edx
  803959:	89 d8                	mov    %ebx,%eax
  80395b:	e8 c7 ee ff ff       	call   802827 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803960:	b9 02 00 00 00       	mov    $0x2,%ecx
  803965:	ba 39 00 00 00       	mov    $0x39,%edx
  80396a:	89 d8                	mov    %ebx,%eax
  80396c:	e8 f7 ee ff ff       	call   802868 <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  803971:	ba 40 02 00 00       	mov    $0x240,%edx
  803976:	89 d8                	mov    %ebx,%eax
  803978:	e8 52 ef ff ff       	call   8028cf <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  80397d:	89 d8                	mov    %ebx,%eax
  80397f:	e8 af ef ff ff       	call   802933 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803984:	83 ec 08             	sub    $0x8,%esp
  803987:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80398b:	66 05 f0 00          	add    $0xf0,%ax
  80398f:	0f b7 c0             	movzwl %ax,%eax
  803992:	50                   	push   %eax
  803993:	ff 73 1c             	pushl  0x1c(%ebx)
  803996:	e8 d2 10 00 00       	call   804a6d <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80399b:	8d 43 2c             	lea    0x2c(%ebx),%eax
  80399e:	83 c4 0c             	add    $0xc,%esp
  8039a1:	6a 43                	push   $0x43
  8039a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8039a6:	50                   	push   %eax
  8039a7:	ff 73 08             	pushl  0x8(%ebx)
  8039aa:	e8 da 53 00 00       	call   808d89 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  8039af:	89 3c 24             	mov    %edi,(%esp)
  8039b2:	6a 43                	push   $0x43
  8039b4:	ff 75 e4             	pushl  -0x1c(%ebp)
  8039b7:	ff 73 1c             	pushl  0x1c(%ebx)
  8039ba:	ff 73 08             	pushl  0x8(%ebx)
  8039bd:	e8 e1 51 00 00       	call   808ba3 <udp_sendto_if>
    dhcp_delete_request(netif);
  8039c2:	83 c4 20             	add    $0x20,%esp
  8039c5:	89 f8                	mov    %edi,%eax
  8039c7:	e8 98 f2 ff ff       	call   802c64 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8039cc:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8039d0:	83 c0 01             	add    $0x1,%eax
  8039d3:	88 43 01             	mov    %al,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  8039d6:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  8039db:	3c 09                	cmp    $0x9,%al
  8039dd:	77 08                	ja     8039e7 <dhcp_renew+0xd0>
  8039df:	0f b6 c0             	movzbl %al,%eax
  8039e2:	66 69 d0 d0 07       	imul   $0x7d0,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8039e7:	0f b7 c2             	movzwl %dx,%eax
  8039ea:	05 f3 01 00 00       	add    $0x1f3,%eax
  8039ef:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8039f4:	f7 ea                	imul   %edx
  8039f6:	c1 fa 05             	sar    $0x5,%edx
  8039f9:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8039fd:	89 f0                	mov    %esi,%eax
  8039ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803a02:	5b                   	pop    %ebx
  803a03:	5e                   	pop    %esi
  803a04:	5f                   	pop    %edi
  803a05:	5d                   	pop    %ebp
  803a06:	c3                   	ret    

00803a07 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  803a07:	55                   	push   %ebp
  803a08:	89 e5                	mov    %esp,%ebp
  803a0a:	53                   	push   %ebx
  803a0b:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803a0e:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  803a14:	eb 6b                	jmp    803a81 <dhcp_coarse_tmr+0x7a>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  803a16:	8b 43 20             	mov    0x20(%ebx),%eax
  803a19:	85 c0                	test   %eax,%eax
  803a1b:	74 62                	je     803a7f <dhcp_coarse_tmr+0x78>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  803a1d:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803a21:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803a24:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803a28:	66 83 fa 01          	cmp    $0x1,%dx
  803a2c:	75 1d                	jne    803a4b <dhcp_coarse_tmr+0x44>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803a2e:	8b 43 20             	mov    0x20(%ebx),%eax
  803a31:	0f b6 00             	movzbl (%eax),%eax
  803a34:	89 c2                	mov    %eax,%edx
  803a36:	83 e2 fb             	and    $0xfffffffb,%edx
  803a39:	80 fa 01             	cmp    $0x1,%dl
  803a3c:	74 04                	je     803a42 <dhcp_coarse_tmr+0x3b>
  803a3e:	3c 0a                	cmp    $0xa,%al
  803a40:	75 3d                	jne    803a7f <dhcp_coarse_tmr+0x78>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  803a42:	89 d8                	mov    %ebx,%eax
  803a44:	e8 b5 f2 ff ff       	call   802cfe <dhcp_rebind>
  803a49:	eb 34                	jmp    803a7f <dhcp_coarse_tmr+0x78>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803a4b:	8b 53 20             	mov    0x20(%ebx),%edx
  803a4e:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803a52:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803a55:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803a59:	66 83 f8 01          	cmp    $0x1,%ax
  803a5d:	75 20                	jne    803a7f <dhcp_coarse_tmr+0x78>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803a5f:	8b 43 20             	mov    0x20(%ebx),%eax
  803a62:	0f b6 00             	movzbl (%eax),%eax
  803a65:	89 c2                	mov    %eax,%edx
  803a67:	83 e2 fb             	and    $0xfffffffb,%edx
  803a6a:	80 fa 01             	cmp    $0x1,%dl
  803a6d:	74 04                	je     803a73 <dhcp_coarse_tmr+0x6c>
  803a6f:	3c 0a                	cmp    $0xa,%al
  803a71:	75 0c                	jne    803a7f <dhcp_coarse_tmr+0x78>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  803a73:	83 ec 0c             	sub    $0xc,%esp
  803a76:	53                   	push   %ebx
  803a77:	e8 9b fe ff ff       	call   803917 <dhcp_renew>
  803a7c:	83 c4 10             	add    $0x10,%esp
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  803a7f:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  803a81:	85 db                	test   %ebx,%ebx
  803a83:	75 91                	jne    803a16 <dhcp_coarse_tmr+0xf>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  803a85:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803a88:	c9                   	leave  
  803a89:	c3                   	ret    

00803a8a <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  803a8a:	55                   	push   %ebp
  803a8b:	89 e5                	mov    %esp,%ebp
  803a8d:	57                   	push   %edi
  803a8e:	56                   	push   %esi
  803a8f:	53                   	push   %ebx
  803a90:	83 ec 1c             	sub    $0x1c,%esp
  803a93:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803a96:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  803a99:	ba 0d 00 00 00       	mov    $0xd,%edx
  803a9e:	89 d8                	mov    %ebx,%eax
  803aa0:	e8 42 ec ff ff       	call   8026e7 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  803aa5:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803aac:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803ab3:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803aba:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803ac1:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803ac8:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803acf:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803ad6:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803add:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803ae4:	89 f0                	mov    %esi,%eax
  803ae6:	e8 98 ef ff ff       	call   802a83 <dhcp_create_request>
  803aeb:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803aed:	84 c0                	test   %al,%al
  803aef:	75 6c                	jne    803b5d <dhcp_release+0xd3>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803af1:	b9 01 00 00 00       	mov    $0x1,%ecx
  803af6:	ba 35 00 00 00       	mov    $0x35,%edx
  803afb:	89 d8                	mov    %ebx,%eax
  803afd:	e8 66 ed ff ff       	call   802868 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803b02:	ba 07 00 00 00       	mov    $0x7,%edx
  803b07:	89 d8                	mov    %ebx,%eax
  803b09:	e8 19 ed ff ff       	call   802827 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  803b0e:	89 d8                	mov    %ebx,%eax
  803b10:	e8 1e ee ff ff       	call   802933 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803b15:	83 ec 08             	sub    $0x8,%esp
  803b18:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803b1c:	66 05 f0 00          	add    $0xf0,%ax
  803b20:	0f b7 c0             	movzwl %ax,%eax
  803b23:	50                   	push   %eax
  803b24:	ff 73 1c             	pushl  0x1c(%ebx)
  803b27:	e8 41 0f 00 00       	call   804a6d <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803b2c:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803b2f:	83 c4 0c             	add    $0xc,%esp
  803b32:	6a 43                	push   $0x43
  803b34:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803b37:	50                   	push   %eax
  803b38:	ff 73 08             	pushl  0x8(%ebx)
  803b3b:	e8 49 52 00 00       	call   808d89 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803b40:	89 34 24             	mov    %esi,(%esp)
  803b43:	6a 43                	push   $0x43
  803b45:	ff 75 e4             	pushl  -0x1c(%ebp)
  803b48:	ff 73 1c             	pushl  0x1c(%ebx)
  803b4b:	ff 73 08             	pushl  0x8(%ebx)
  803b4e:	e8 50 50 00 00       	call   808ba3 <udp_sendto_if>
    dhcp_delete_request(netif);
  803b53:	83 c4 20             	add    $0x20,%esp
  803b56:	89 f0                	mov    %esi,%eax
  803b58:	e8 07 f1 ff ff       	call   802c64 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803b5d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803b61:	83 c0 01             	add    $0x1,%eax
  803b64:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803b67:	ba 10 27 00 00       	mov    $0x2710,%edx
  803b6c:	3c 09                	cmp    $0x9,%al
  803b6e:	77 08                	ja     803b78 <dhcp_release+0xee>
  803b70:	0f b6 c0             	movzbl %al,%eax
  803b73:	66 69 d0 e8 03       	imul   $0x3e8,%ax,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803b78:	0f b7 c2             	movzwl %dx,%eax
  803b7b:	05 f3 01 00 00       	add    $0x1f3,%eax
  803b80:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803b85:	f7 ea                	imul   %edx
  803b87:	c1 fa 05             	sar    $0x5,%edx
  803b8a:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  803b8e:	83 ec 0c             	sub    $0xc,%esp
  803b91:	56                   	push   %esi
  803b92:	e8 96 0a 00 00       	call   80462d <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803b97:	83 c4 08             	add    $0x8,%esp
  803b9a:	68 04 1c 81 00       	push   $0x811c04
  803b9f:	56                   	push   %esi
  803ba0:	e8 cc 08 00 00       	call   804471 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803ba5:	83 c4 08             	add    $0x8,%esp
  803ba8:	68 04 1c 81 00       	push   $0x811c04
  803bad:	56                   	push   %esi
  803bae:	e8 06 0a 00 00       	call   8045b9 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803bb3:	83 c4 08             	add    $0x8,%esp
  803bb6:	68 04 1c 81 00       	push   $0x811c04
  803bbb:	56                   	push   %esi
  803bbc:	e8 13 0a 00 00       	call   8045d4 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  803bc1:	89 f8                	mov    %edi,%eax
  803bc3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803bc6:	5b                   	pop    %ebx
  803bc7:	5e                   	pop    %esi
  803bc8:	5f                   	pop    %edi
  803bc9:	5d                   	pop    %ebp
  803bca:	c3                   	ret    

00803bcb <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  803bcb:	55                   	push   %ebp
  803bcc:	89 e5                	mov    %esp,%ebp
  803bce:	53                   	push   %ebx
  803bcf:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803bd2:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  803bd8:	e9 c6 00 00 00       	jmp    803ca3 <dhcp_fine_tmr+0xd8>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  803bdd:	8b 53 20             	mov    0x20(%ebx),%edx
  803be0:	85 d2                	test   %edx,%edx
  803be2:	0f 84 b9 00 00 00    	je     803ca1 <dhcp_fine_tmr+0xd6>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  803be8:	0f b7 42 26          	movzwl 0x26(%edx),%eax
  803bec:	66 83 f8 01          	cmp    $0x1,%ax
  803bf0:	76 0c                	jbe    803bfe <dhcp_fine_tmr+0x33>
        netif->dhcp->request_timeout--;
  803bf2:	83 e8 01             	sub    $0x1,%eax
  803bf5:	66 89 42 26          	mov    %ax,0x26(%edx)
  803bf9:	e9 a3 00 00 00       	jmp    803ca1 <dhcp_fine_tmr+0xd6>
      }
      else if (netif->dhcp->request_timeout == 1) {
  803bfe:	66 83 f8 01          	cmp    $0x1,%ax
  803c02:	0f 85 99 00 00 00    	jne    803ca1 <dhcp_fine_tmr+0xd6>
        netif->dhcp->request_timeout--;
  803c08:	66 c7 42 26 00 00    	movw   $0x0,0x26(%edx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803c0e:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803c11:	0f b6 02             	movzbl (%edx),%eax
  803c14:	3c 0c                	cmp    $0xc,%al
  803c16:	74 04                	je     803c1c <dhcp_fine_tmr+0x51>
  803c18:	3c 06                	cmp    $0x6,%al
  803c1a:	75 09                	jne    803c25 <dhcp_fine_tmr+0x5a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  803c1c:	89 d8                	mov    %ebx,%eax
  803c1e:	e8 ca f1 ff ff       	call   802ded <dhcp_discover>
  803c23:	eb 7c                	jmp    803ca1 <dhcp_fine_tmr+0xd6>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  803c25:	3c 01                	cmp    $0x1,%al
  803c27:	75 24                	jne    803c4d <dhcp_fine_tmr+0x82>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  803c29:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803c2d:	77 09                	ja     803c38 <dhcp_fine_tmr+0x6d>
      dhcp_select(netif);
  803c2f:	89 d8                	mov    %ebx,%eax
  803c31:	e8 f2 f2 ff ff       	call   802f28 <dhcp_select>
  803c36:	eb 69                	jmp    803ca1 <dhcp_fine_tmr+0xd6>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  803c38:	83 ec 0c             	sub    $0xc,%esp
  803c3b:	53                   	push   %ebx
  803c3c:	e8 49 fe ff ff       	call   803a8a <dhcp_release>
      dhcp_discover(netif);
  803c41:	89 d8                	mov    %ebx,%eax
  803c43:	e8 a5 f1 ff ff       	call   802ded <dhcp_discover>
  803c48:	83 c4 10             	add    $0x10,%esp
  803c4b:	eb 54                	jmp    803ca1 <dhcp_fine_tmr+0xd6>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  803c4d:	3c 08                	cmp    $0x8,%al
  803c4f:	75 18                	jne    803c69 <dhcp_fine_tmr+0x9e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  803c51:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803c55:	77 09                	ja     803c60 <dhcp_fine_tmr+0x95>
      dhcp_check(netif);
  803c57:	89 d8                	mov    %ebx,%eax
  803c59:	e8 42 f4 ff ff       	call   8030a0 <dhcp_check>
  803c5e:	eb 41                	jmp    803ca1 <dhcp_fine_tmr+0xd6>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  803c60:	89 d8                	mov    %ebx,%eax
  803c62:	e8 6d f4 ff ff       	call   8030d4 <dhcp_bind>
  803c67:	eb 38                	jmp    803ca1 <dhcp_fine_tmr+0xd6>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  803c69:	3c 05                	cmp    $0x5,%al
  803c6b:	75 0e                	jne    803c7b <dhcp_fine_tmr+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  803c6d:	83 ec 0c             	sub    $0xc,%esp
  803c70:	53                   	push   %ebx
  803c71:	e8 a1 fc ff ff       	call   803917 <dhcp_renew>
  803c76:	83 c4 10             	add    $0x10,%esp
  803c79:	eb 26                	jmp    803ca1 <dhcp_fine_tmr+0xd6>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  803c7b:	3c 04                	cmp    $0x4,%al
  803c7d:	75 22                	jne    803ca1 <dhcp_fine_tmr+0xd6>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  803c7f:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803c83:	77 09                	ja     803c8e <dhcp_fine_tmr+0xc3>
      dhcp_rebind(netif);
  803c85:	89 d8                	mov    %ebx,%eax
  803c87:	e8 72 f0 ff ff       	call   802cfe <dhcp_rebind>
  803c8c:	eb 13                	jmp    803ca1 <dhcp_fine_tmr+0xd6>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  803c8e:	83 ec 0c             	sub    $0xc,%esp
  803c91:	53                   	push   %ebx
  803c92:	e8 f3 fd ff ff       	call   803a8a <dhcp_release>
      dhcp_discover(netif);
  803c97:	89 d8                	mov    %ebx,%eax
  803c99:	e8 4f f1 ff ff       	call   802ded <dhcp_discover>
  803c9e:	83 c4 10             	add    $0x10,%esp
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  803ca1:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  803ca3:	85 db                	test   %ebx,%ebx
  803ca5:	0f 85 32 ff ff ff    	jne    803bdd <dhcp_fine_tmr+0x12>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  803cab:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803cae:	c9                   	leave  
  803caf:	c3                   	ret    

00803cb0 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  803cb0:	55                   	push   %ebp
  803cb1:	89 e5                	mov    %esp,%ebp
  803cb3:	56                   	push   %esi
  803cb4:	53                   	push   %ebx
  803cb5:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803cb8:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  803cbb:	85 f6                	test   %esi,%esi
  803cbd:	75 17                	jne    803cd6 <dhcp_stop+0x26>
  803cbf:	83 ec 04             	sub    $0x4,%esp
  803cc2:	68 b4 13 81 00       	push   $0x8113b4
  803cc7:	68 2c 04 00 00       	push   $0x42c
  803ccc:	68 42 13 81 00       	push   $0x811342
  803cd1:	e8 82 a6 00 00       	call   80e358 <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  803cd6:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  803cda:	85 db                	test   %ebx,%ebx
  803cdc:	74 4e                	je     803d2c <dhcp_stop+0x7c>
    if (dhcp->pcb != NULL) {
  803cde:	8b 43 08             	mov    0x8(%ebx),%eax
  803ce1:	85 c0                	test   %eax,%eax
  803ce3:	74 13                	je     803cf8 <dhcp_stop+0x48>
      udp_remove(dhcp->pcb);
  803ce5:	83 ec 0c             	sub    $0xc,%esp
  803ce8:	50                   	push   %eax
  803ce9:	e8 3b 51 00 00       	call   808e29 <udp_remove>
      dhcp->pcb = NULL;
  803cee:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803cf5:	83 c4 10             	add    $0x10,%esp
    }
    if (dhcp->p != NULL) {
  803cf8:	8b 43 0c             	mov    0xc(%ebx),%eax
  803cfb:	85 c0                	test   %eax,%eax
  803cfd:	74 13                	je     803d12 <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  803cff:	83 ec 0c             	sub    $0xc,%esp
  803d02:	50                   	push   %eax
  803d03:	e8 1c 0a 00 00       	call   804724 <pbuf_free>
      dhcp->p = NULL;
  803d08:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803d0f:	83 c4 10             	add    $0x10,%esp
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  803d12:	89 d8                	mov    %ebx,%eax
  803d14:	e8 46 f5 ff ff       	call   80325f <dhcp_free_reply>
    mem_free((void *)dhcp);
  803d19:	83 ec 0c             	sub    $0xc,%esp
  803d1c:	53                   	push   %ebx
  803d1d:	e8 60 01 00 00       	call   803e82 <mem_free>
    netif->dhcp = NULL;
  803d22:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803d29:	83 c4 10             	add    $0x10,%esp
  }
}
  803d2c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803d2f:	5b                   	pop    %ebx
  803d30:	5e                   	pop    %esi
  803d31:	5d                   	pop    %ebp
  803d32:	c3                   	ret    

00803d33 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  803d33:	55                   	push   %ebp
  803d34:	89 e5                	mov    %esp,%ebp
  803d36:	56                   	push   %esi
  803d37:	53                   	push   %ebx
  803d38:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803d3b:	85 db                	test   %ebx,%ebx
  803d3d:	75 17                	jne    803d56 <dhcp_start+0x23>
  803d3f:	83 ec 04             	sub    $0x4,%esp
  803d42:	68 62 13 81 00       	push   $0x811362
  803d47:	68 38 02 00 00       	push   $0x238
  803d4c:	68 42 13 81 00       	push   $0x811342
  803d51:	e8 02 a6 00 00       	call   80e358 <_panic>
  dhcp = netif->dhcp;
  803d56:	8b 73 20             	mov    0x20(%ebx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  803d59:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  803d5d:	85 f6                	test   %esi,%esi
  803d5f:	75 1a                	jne    803d7b <dhcp_start+0x48>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  803d61:	83 ec 0c             	sub    $0xc,%esp
  803d64:	6a 58                	push   $0x58
  803d66:	e8 c9 03 00 00       	call   804134 <mem_malloc>
  803d6b:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  803d6d:	83 c4 10             	add    $0x10,%esp
  803d70:	85 c0                	test   %eax,%eax
  803d72:	0f 84 98 00 00 00    	je     803e10 <dhcp_start+0xdd>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  803d78:	89 43 20             	mov    %eax,0x20(%ebx)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  803d7b:	83 ec 04             	sub    $0x4,%esp
  803d7e:	6a 58                	push   $0x58
  803d80:	6a 00                	push   $0x0
  803d82:	56                   	push   %esi
  803d83:	e8 73 ad 00 00       	call   80eafb <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  803d88:	e8 e0 50 00 00       	call   808e6d <udp_new>
  803d8d:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803d90:	83 c4 10             	add    $0x10,%esp
  803d93:	85 c0                	test   %eax,%eax
  803d95:	75 1a                	jne    803db1 <dhcp_start+0x7e>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  803d97:	83 ec 0c             	sub    $0xc,%esp
  803d9a:	56                   	push   %esi
  803d9b:	e8 e2 00 00 00       	call   803e82 <mem_free>
    netif->dhcp = dhcp = NULL;
  803da0:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  803da7:	83 c4 10             	add    $0x10,%esp
  803daa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803daf:	eb 64                	jmp    803e15 <dhcp_start+0xe2>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803db1:	83 ec 04             	sub    $0x4,%esp
  803db4:	6a 44                	push   $0x44
  803db6:	68 04 1c 81 00       	push   $0x811c04
  803dbb:	50                   	push   %eax
  803dbc:	e8 26 4d 00 00       	call   808ae7 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803dc1:	83 c4 0c             	add    $0xc,%esp
  803dc4:	6a 43                	push   $0x43
  803dc6:	68 04 1c 81 00       	push   $0x811c04
  803dcb:	ff 76 08             	pushl  0x8(%esi)
  803dce:	e8 b6 4f 00 00       	call   808d89 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803dd3:	83 c4 0c             	add    $0xc,%esp
  803dd6:	53                   	push   %ebx
  803dd7:	68 a7 32 80 00       	push   $0x8032a7
  803ddc:	ff 76 08             	pushl  0x8(%esi)
  803ddf:	e8 31 50 00 00       	call   808e15 <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  803de4:	89 d8                	mov    %ebx,%eax
  803de6:	e8 02 f0 ff ff       	call   802ded <dhcp_discover>
  if (result != ERR_OK) {
  803deb:	83 c4 10             	add    $0x10,%esp
  803dee:	84 c0                	test   %al,%al
  803df0:	74 13                	je     803e05 <dhcp_start+0xd2>
    /* free resources allocated above */
    dhcp_stop(netif);
  803df2:	83 ec 0c             	sub    $0xc,%esp
  803df5:	53                   	push   %ebx
  803df6:	e8 b5 fe ff ff       	call   803cb0 <dhcp_stop>
    return ERR_MEM;
  803dfb:	83 c4 10             	add    $0x10,%esp
  803dfe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803e03:	eb 10                	jmp    803e15 <dhcp_start+0xe2>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  803e05:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
  return result;
  803e09:	b8 00 00 00 00       	mov    $0x0,%eax
  803e0e:	eb 05                	jmp    803e15 <dhcp_start+0xe2>
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
    if (dhcp == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  803e10:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  return result;
}
  803e15:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803e18:	5b                   	pop    %ebx
  803e19:	5e                   	pop    %esi
  803e1a:	5d                   	pop    %ebp
  803e1b:	c3                   	ret    

00803e1c <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  803e1c:	55                   	push   %ebp
  803e1d:	89 e5                	mov    %esp,%ebp
  803e1f:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  803e22:	b8 23 53 81 00       	mov    $0x815323,%eax
  803e27:	83 e0 fc             	and    $0xfffffffc,%eax
  803e2a:	a3 0c 53 81 00       	mov    %eax,0x81530c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  803e2f:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  803e35:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  803e3c:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  803e40:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  803e46:	89 15 08 53 81 00    	mov    %edx,0x815308
  ram_end->used = 1;
  803e4c:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  803e53:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  803e5a:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  803e5d:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  803e64:	00 22 00 

  mem_sem = sys_sem_new(1);
  803e67:	6a 01                	push   $0x1
  803e69:	e8 bd 5d 00 00       	call   809c2b <sys_sem_new>
  803e6e:	a3 00 53 81 00       	mov    %eax,0x815300

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  803e73:	a1 0c 53 81 00       	mov    0x81530c,%eax
  803e78:	a3 04 53 81 00       	mov    %eax,0x815304

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  803e7d:	83 c4 10             	add    $0x10,%esp
  803e80:	c9                   	leave  
  803e81:	c3                   	ret    

00803e82 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  803e82:	55                   	push   %ebp
  803e83:	89 e5                	mov    %esp,%ebp
  803e85:	56                   	push   %esi
  803e86:	53                   	push   %ebx
  803e87:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  803e8a:	85 db                	test   %ebx,%ebx
  803e8c:	0f 84 52 01 00 00    	je     803fe4 <mem_free+0x162>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  803e92:	f6 c3 03             	test   $0x3,%bl
  803e95:	74 17                	je     803eae <mem_free+0x2c>
  803e97:	83 ec 04             	sub    $0x4,%esp
  803e9a:	68 d0 13 81 00       	push   $0x8113d0
  803e9f:	68 30 01 00 00       	push   $0x130
  803ea4:	68 c7 14 81 00       	push   $0x8114c7
  803ea9:	e8 aa a4 00 00       	call   80e358 <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  803eae:	3b 1d 0c 53 81 00    	cmp    0x81530c,%ebx
  803eb4:	72 08                	jb     803ebe <mem_free+0x3c>
  803eb6:	3b 1d 08 53 81 00    	cmp    0x815308,%ebx
  803ebc:	72 17                	jb     803ed5 <mem_free+0x53>
  803ebe:	83 ec 04             	sub    $0x4,%esp
  803ec1:	68 db 14 81 00       	push   $0x8114db
  803ec6:	68 33 01 00 00       	push   $0x133
  803ecb:	68 c7 14 81 00       	push   $0x8114c7
  803ed0:	e8 83 a4 00 00       	call   80e358 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  803ed5:	83 ec 08             	sub    $0x8,%esp
  803ed8:	6a 00                	push   $0x0
  803eda:	ff 35 00 53 81 00    	pushl  0x815300
  803ee0:	e8 60 60 00 00       	call   809f45 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  803ee5:	83 c4 10             	add    $0x10,%esp
  803ee8:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  803eec:	75 17                	jne    803f05 <mem_free+0x83>
  803eee:	83 ec 04             	sub    $0x4,%esp
  803ef1:	68 f2 14 81 00       	push   $0x8114f2
  803ef6:	68 43 01 00 00       	push   $0x143
  803efb:	68 c7 14 81 00       	push   $0x8114c7
  803f00:	e8 53 a4 00 00       	call   80e358 <_panic>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  803f05:	8d 53 f4             	lea    -0xc(%ebx),%edx
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
  803f08:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  803f0c:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  803f12:	73 06                	jae    803f1a <mem_free+0x98>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  803f14:	89 15 04 53 81 00    	mov    %edx,0x815304
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  803f1a:	8b 0d 0c 53 81 00    	mov    0x81530c,%ecx
  803f20:	39 ca                	cmp    %ecx,%edx
  803f22:	73 17                	jae    803f3b <mem_free+0xb9>
  803f24:	83 ec 04             	sub    $0x4,%esp
  803f27:	68 06 15 81 00       	push   $0x811506
  803f2c:	68 e3 00 00 00       	push   $0xe3
  803f31:	68 c7 14 81 00       	push   $0x8114c7
  803f36:	e8 1d a4 00 00       	call   80e358 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  803f3b:	8b 35 08 53 81 00    	mov    0x815308,%esi
  803f41:	39 f2                	cmp    %esi,%edx
  803f43:	72 17                	jb     803f5c <mem_free+0xda>
  803f45:	83 ec 04             	sub    $0x4,%esp
  803f48:	68 1d 15 81 00       	push   $0x81151d
  803f4d:	68 e4 00 00 00       	push   $0xe4
  803f52:	68 c7 14 81 00       	push   $0x8114c7
  803f57:	e8 fc a3 00 00       	call   80e358 <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  803f5c:	8b 43 f4             	mov    -0xc(%ebx),%eax
  803f5f:	3d 00 00 22 00       	cmp    $0x220000,%eax
  803f64:	76 17                	jbe    803f7d <mem_free+0xfb>
  803f66:	83 ec 04             	sub    $0x4,%esp
  803f69:	68 f4 13 81 00       	push   $0x8113f4
  803f6e:	68 e8 00 00 00       	push   $0xe8
  803f73:	68 c7 14 81 00       	push   $0x8114c7
  803f78:	e8 db a3 00 00       	call   80e358 <_panic>

  nmem = (struct mem *)&ram[mem->next];
  803f7d:	01 c8                	add    %ecx,%eax
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  803f7f:	39 c2                	cmp    %eax,%edx
  803f81:	74 27                	je     803faa <mem_free+0x128>
  803f83:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  803f87:	75 21                	jne    803faa <mem_free+0x128>
  803f89:	39 c6                	cmp    %eax,%esi
  803f8b:	74 1d                	je     803faa <mem_free+0x128>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  803f8d:	3b 05 04 53 81 00    	cmp    0x815304,%eax
  803f93:	75 06                	jne    803f9b <mem_free+0x119>
      lfree = mem;
  803f95:	89 15 04 53 81 00    	mov    %edx,0x815304
    }
    mem->next = nmem->next;
  803f9b:	8b 30                	mov    (%eax),%esi
  803f9d:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  803fa0:	8b 00                	mov    (%eax),%eax
  803fa2:	89 d6                	mov    %edx,%esi
  803fa4:	29 ce                	sub    %ecx,%esi
  803fa6:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  803faa:	8b 73 f8             	mov    -0x8(%ebx),%esi
  803fad:	8d 04 31             	lea    (%ecx,%esi,1),%eax
  if (pmem != mem && pmem->used == 0) {
  803fb0:	39 c2                	cmp    %eax,%edx
  803fb2:	74 1f                	je     803fd3 <mem_free+0x151>
  803fb4:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  803fb8:	75 19                	jne    803fd3 <mem_free+0x151>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  803fba:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  803fc0:	75 05                	jne    803fc7 <mem_free+0x145>
      lfree = pmem;
  803fc2:	a3 04 53 81 00       	mov    %eax,0x815304
    }
    pmem->next = mem->next;
  803fc7:	8b 53 f4             	mov    -0xc(%ebx),%edx
  803fca:	89 10                	mov    %edx,(%eax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  803fcc:	8b 43 f4             	mov    -0xc(%ebx),%eax
  803fcf:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  803fd3:	83 ec 0c             	sub    $0xc,%esp
  803fd6:	ff 35 00 53 81 00    	pushl  0x815300
  803fdc:	e8 f6 5e 00 00       	call   809ed7 <sys_sem_signal>
  803fe1:	83 c4 10             	add    $0x10,%esp
}
  803fe4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803fe7:	5b                   	pop    %ebx
  803fe8:	5e                   	pop    %esi
  803fe9:	5d                   	pop    %ebp
  803fea:	c3                   	ret    

00803feb <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  803feb:	55                   	push   %ebp
  803fec:	89 e5                	mov    %esp,%ebp
  803fee:	57                   	push   %edi
  803fef:	56                   	push   %esi
  803ff0:	53                   	push   %ebx
  803ff1:	83 ec 1c             	sub    $0x1c,%esp
  803ff4:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  803ff7:	8b 45 0c             	mov    0xc(%ebp),%eax
  803ffa:	8d 58 03             	lea    0x3(%eax),%ebx
  803ffd:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  804000:	83 fb 0b             	cmp    $0xb,%ebx
  804003:	76 0d                	jbe    804012 <mem_realloc+0x27>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  804005:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  80400b:	76 0a                	jbe    804017 <mem_realloc+0x2c>
  80400d:	e9 15 01 00 00       	jmp    804127 <mem_realloc+0x13c>
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  804012:	bb 0c 00 00 00       	mov    $0xc,%ebx

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804017:	a1 0c 53 81 00       	mov    0x81530c,%eax
  80401c:	39 f0                	cmp    %esi,%eax
  80401e:	77 08                	ja     804028 <mem_realloc+0x3d>
  804020:	3b 35 08 53 81 00    	cmp    0x815308,%esi
  804026:	72 17                	jb     80403f <mem_realloc+0x54>
  804028:	83 ec 04             	sub    $0x4,%esp
  80402b:	68 37 15 81 00       	push   $0x811537
  804030:	68 79 01 00 00       	push   $0x179
  804035:	68 c7 14 81 00       	push   $0x8114c7
  80403a:	e8 19 a3 00 00       	call   80e358 <_panic>
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  80403f:	8d 56 f4             	lea    -0xc(%esi),%edx
  804042:	29 c2                	sub    %eax,%edx
  804044:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  804047:	8b 46 f4             	mov    -0xc(%esi),%eax
  80404a:	8d 78 f4             	lea    -0xc(%eax),%edi
  80404d:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  80404f:	39 df                	cmp    %ebx,%edi
  804051:	73 17                	jae    80406a <mem_realloc+0x7f>
  804053:	83 ec 04             	sub    $0x4,%esp
  804056:	68 20 14 81 00       	push   $0x811420
  80405b:	68 8a 01 00 00       	push   $0x18a
  804060:	68 c7 14 81 00       	push   $0x8114c7
  804065:	e8 ee a2 00 00       	call   80e358 <_panic>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
    /* No change in size, simply return */
    return rmem;
  80406a:	89 f0                	mov    %esi,%eax
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  80406c:	39 df                	cmp    %ebx,%edi
  80406e:	0f 84 b8 00 00 00    	je     80412c <mem_realloc+0x141>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  804074:	83 ec 08             	sub    $0x8,%esp
  804077:	6a 00                	push   $0x0
  804079:	ff 35 00 53 81 00    	pushl  0x815300
  80407f:	e8 c1 5e 00 00       	call   809f45 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  804084:	a1 0c 53 81 00       	mov    0x81530c,%eax
  804089:	89 c2                	mov    %eax,%edx
  80408b:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  80408e:	83 c4 10             	add    $0x10,%esp
  804091:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804095:	75 3c                	jne    8040d3 <mem_realloc+0xe8>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  804097:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804099:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80409c:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  8040a0:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  8040a6:	75 09                	jne    8040b1 <mem_realloc+0xc6>
      lfree = (struct mem *)&ram[ptr2];
  8040a8:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  8040ab:	89 15 04 53 81 00    	mov    %edx,0x815304
    }
    mem2 = (struct mem *)&ram[ptr2];
  8040b1:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  8040b4:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  8040b8:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  8040ba:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8040bd:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  8040c0:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8040c3:	8b 12                	mov    (%edx),%edx
  8040c5:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8040cb:	74 45                	je     804112 <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8040cd:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
  8040d1:	eb 3f                	jmp    804112 <mem_realloc+0x127>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  8040d3:	8d 53 18             	lea    0x18(%ebx),%edx
  8040d6:	39 d7                	cmp    %edx,%edi
  8040d8:	72 38                	jb     804112 <mem_realloc+0x127>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8040da:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8040dd:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8040e1:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8040e4:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  8040ea:	73 06                	jae    8040f2 <mem_realloc+0x107>
      lfree = mem2;
  8040ec:	89 15 04 53 81 00    	mov    %edx,0x815304
    }
    mem2->used = 0;
  8040f2:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8040f6:	8b 5e f4             	mov    -0xc(%esi),%ebx
  8040f9:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  8040fb:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8040fe:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  804101:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804104:	8b 12                	mov    (%edx),%edx
  804106:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80410c:	74 04                	je     804112 <mem_realloc+0x127>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80410e:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804112:	83 ec 0c             	sub    $0xc,%esp
  804115:	ff 35 00 53 81 00    	pushl  0x815300
  80411b:	e8 b7 5d 00 00       	call   809ed7 <sys_sem_signal>
  return rmem;
  804120:	83 c4 10             	add    $0x10,%esp
  804123:	89 f0                	mov    %esi,%eax
  804125:	eb 05                	jmp    80412c <mem_realloc+0x141>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  804127:	b8 00 00 00 00       	mov    $0x0,%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
  80412c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80412f:	5b                   	pop    %ebx
  804130:	5e                   	pop    %esi
  804131:	5f                   	pop    %edi
  804132:	5d                   	pop    %ebp
  804133:	c3                   	ret    

00804134 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  804134:	55                   	push   %ebp
  804135:	89 e5                	mov    %esp,%ebp
  804137:	57                   	push   %edi
  804138:	56                   	push   %esi
  804139:	53                   	push   %ebx
  80413a:	83 ec 1c             	sub    $0x1c,%esp
  80413d:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  804140:	85 f6                	test   %esi,%esi
  804142:	0f 84 72 01 00 00    	je     8042ba <mem_malloc+0x186>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  804148:	83 c6 03             	add    $0x3,%esi
  80414b:	83 e6 fc             	and    $0xfffffffc,%esi

  if(size < MIN_SIZE_ALIGNED) {
  80414e:	83 fe 0b             	cmp    $0xb,%esi
  804151:	76 0d                	jbe    804160 <mem_malloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  804153:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  804159:	76 0a                	jbe    804165 <mem_malloc+0x31>
  80415b:	e9 61 01 00 00       	jmp    8042c1 <mem_malloc+0x18d>
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  804160:	be 0c 00 00 00       	mov    $0xc,%esi
  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  804165:	83 ec 08             	sub    $0x8,%esp
  804168:	6a 00                	push   $0x0
  80416a:	ff 35 00 53 81 00    	pushl  0x815300
  804170:	e8 d0 5d 00 00       	call   809f45 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804175:	8b 15 0c 53 81 00    	mov    0x81530c,%edx
  80417b:	a1 04 53 81 00       	mov    0x815304,%eax
  804180:	29 d0                	sub    %edx,%eax
  804182:	83 c4 10             	add    $0x10,%esp
  804185:	bf 00 00 22 00       	mov    $0x220000,%edi
  80418a:	29 f7                	sub    %esi,%edi
  80418c:	e9 09 01 00 00       	jmp    80429a <mem_malloc+0x166>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  804191:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  804194:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804198:	0f 85 fa 00 00 00    	jne    804298 <mem_malloc+0x164>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80419e:	8b 0b                	mov    (%ebx),%ecx
  8041a0:	83 e9 0c             	sub    $0xc,%ecx
  8041a3:	29 c1                	sub    %eax,%ecx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  8041a5:	39 f1                	cmp    %esi,%ecx
  8041a7:	0f 82 eb 00 00 00    	jb     804298 <mem_malloc+0x164>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  8041ad:	8d 7e 18             	lea    0x18(%esi),%edi
  8041b0:	39 f9                	cmp    %edi,%ecx
  8041b2:	72 2d                	jb     8041e1 <mem_malloc+0xad>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  8041b4:	8d 7c 30 0c          	lea    0xc(%eax,%esi,1),%edi
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  8041b8:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  8041bb:	8d 0c 3a             	lea    (%edx,%edi,1),%ecx
          mem2->used = 0;
  8041be:	c6 41 08 00          	movb   $0x0,0x8(%ecx)
          mem2->next = mem->next;
  8041c2:	8b 3b                	mov    (%ebx),%edi
  8041c4:	89 39                	mov    %edi,(%ecx)
          mem2->prev = ptr;
  8041c6:	89 41 04             	mov    %eax,0x4(%ecx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  8041c9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8041cc:	89 3b                	mov    %edi,(%ebx)
          mem->used = 1;
  8041ce:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  8041d2:	8b 01                	mov    (%ecx),%eax
  8041d4:	3d 00 00 22 00       	cmp    $0x220000,%eax
  8041d9:	74 0a                	je     8041e5 <mem_malloc+0xb1>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8041db:	89 7c 02 04          	mov    %edi,0x4(%edx,%eax,1)
  8041df:	eb 04                	jmp    8041e5 <mem_malloc+0xb1>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  8041e1:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  8041e5:	a1 04 53 81 00       	mov    0x815304,%eax
  8041ea:	39 c3                	cmp    %eax,%ebx
  8041ec:	75 3c                	jne    80422a <mem_malloc+0xf6>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8041ee:	8b 0d 08 53 81 00    	mov    0x815308,%ecx
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  8041f4:	8b 3d 0c 53 81 00    	mov    0x81530c,%edi
  8041fa:	ba 00 00 00 00       	mov    $0x0,%edx
  8041ff:	eb 0b                	jmp    80420c <mem_malloc+0xd8>
  804201:	89 fa                	mov    %edi,%edx
  804203:	03 10                	add    (%eax),%edx
  804205:	89 d0                	mov    %edx,%eax
  804207:	ba 01 00 00 00       	mov    $0x1,%edx
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80420c:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  804210:	75 0b                	jne    80421d <mem_malloc+0xe9>
  804212:	84 d2                	test   %dl,%dl
  804214:	74 14                	je     80422a <mem_malloc+0xf6>
  804216:	a3 04 53 81 00       	mov    %eax,0x815304
  80421b:	eb 0d                	jmp    80422a <mem_malloc+0xf6>
  80421d:	39 c1                	cmp    %eax,%ecx
  80421f:	75 e0                	jne    804201 <mem_malloc+0xcd>
  804221:	84 d2                	test   %dl,%dl
  804223:	74 05                	je     80422a <mem_malloc+0xf6>
  804225:	a3 04 53 81 00       	mov    %eax,0x815304
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80422a:	83 ec 0c             	sub    $0xc,%esp
  80422d:	ff 35 00 53 81 00    	pushl  0x815300
  804233:	e8 9f 5c 00 00       	call   809ed7 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  804238:	8d 44 33 0c          	lea    0xc(%ebx,%esi,1),%eax
  80423c:	83 c4 10             	add    $0x10,%esp
  80423f:	39 05 08 53 81 00    	cmp    %eax,0x815308
  804245:	73 17                	jae    80425e <mem_malloc+0x12a>
  804247:	83 ec 04             	sub    $0x4,%esp
  80424a:	68 44 14 81 00       	push   $0x811444
  80424f:	68 4b 02 00 00       	push   $0x24b
  804254:	68 c7 14 81 00       	push   $0x8114c7
  804259:	e8 fa a0 00 00       	call   80e358 <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80425e:	8d 43 0c             	lea    0xc(%ebx),%eax
  804261:	a8 03                	test   $0x3,%al
  804263:	74 17                	je     80427c <mem_malloc+0x148>
  804265:	83 ec 04             	sub    $0x4,%esp
  804268:	68 74 14 81 00       	push   $0x811474
  80426d:	68 4d 02 00 00       	push   $0x24d
  804272:	68 c7 14 81 00       	push   $0x8114c7
  804277:	e8 dc a0 00 00       	call   80e358 <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  80427c:	f6 c3 03             	test   $0x3,%bl
  80427f:	74 45                	je     8042c6 <mem_malloc+0x192>
  804281:	83 ec 04             	sub    $0x4,%esp
  804284:	68 a4 14 81 00       	push   $0x8114a4
  804289:	68 4f 02 00 00       	push   $0x24f
  80428e:	68 c7 14 81 00       	push   $0x8114c7
  804293:	e8 c0 a0 00 00       	call   80e358 <_panic>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  804298:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80429a:	39 f8                	cmp    %edi,%eax
  80429c:	0f 82 ef fe ff ff    	jb     804191 <mem_malloc+0x5d>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  8042a2:	83 ec 0c             	sub    $0xc,%esp
  8042a5:	ff 35 00 53 81 00    	pushl  0x815300
  8042ab:	e8 27 5c 00 00       	call   809ed7 <sys_sem_signal>
  return NULL;
  8042b0:	83 c4 10             	add    $0x10,%esp
  8042b3:	b8 00 00 00 00       	mov    $0x0,%eax
  8042b8:	eb 0c                	jmp    8042c6 <mem_malloc+0x192>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
  8042ba:	b8 00 00 00 00       	mov    $0x0,%eax
  8042bf:	eb 05                	jmp    8042c6 <mem_malloc+0x192>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  8042c1:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
}
  8042c6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8042c9:	5b                   	pop    %ebx
  8042ca:	5e                   	pop    %esi
  8042cb:	5f                   	pop    %edi
  8042cc:	5d                   	pop    %ebp
  8042cd:	c3                   	ret    

008042ce <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8042ce:	55                   	push   %ebp
  8042cf:	89 e5                	mov    %esp,%ebp
  8042d1:	56                   	push   %esi
  8042d2:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8042d3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8042d6:	0f af 5d 08          	imul   0x8(%ebp),%ebx
  8042da:	83 ec 0c             	sub    $0xc,%esp
  8042dd:	53                   	push   %ebx
  8042de:	e8 51 fe ff ff       	call   804134 <mem_malloc>
  8042e3:	89 c6                	mov    %eax,%esi
  if (p) {
  8042e5:	83 c4 10             	add    $0x10,%esp
  8042e8:	85 c0                	test   %eax,%eax
  8042ea:	74 0f                	je     8042fb <mem_calloc+0x2d>
    /* zero the memory */
    memset(p, 0, count * size);
  8042ec:	83 ec 04             	sub    $0x4,%esp
  8042ef:	53                   	push   %ebx
  8042f0:	6a 00                	push   $0x0
  8042f2:	50                   	push   %eax
  8042f3:	e8 03 a8 00 00       	call   80eafb <memset>
  8042f8:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  8042fb:	89 f0                	mov    %esi,%eax
  8042fd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804300:	5b                   	pop    %ebx
  804301:	5e                   	pop    %esi
  804302:	5d                   	pop    %ebp
  804303:	c3                   	ret    

00804304 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  804304:	55                   	push   %ebp
  804305:	89 e5                	mov    %esp,%ebp
  804307:	57                   	push   %edi
  804308:	56                   	push   %esi
  804309:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80430a:	b8 43 53 a3 00       	mov    $0xa35343,%eax
  80430f:	83 e0 fc             	and    $0xfffffffc,%eax
  804312:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  804317:	c7 84 12 c0 43 b3 00 	movl   $0x0,0xb343c0(%edx,%edx,1)
  80431e:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804322:	0f b7 b2 c8 15 81 00 	movzwl 0x8115c8(%edx),%esi
  804329:	b9 00 00 00 00       	mov    $0x0,%ecx
  80432e:	eb 19                	jmp    804349 <memp_init+0x45>
      memp->next = memp_tab[i];
  804330:	bb c0 43 b3 00       	mov    $0xb343c0,%ebx
  804335:	8b 3c 53             	mov    (%ebx,%edx,2),%edi
  804338:	89 38                	mov    %edi,(%eax)
      memp_tab[i] = memp;
  80433a:	89 04 53             	mov    %eax,(%ebx,%edx,2)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80433d:	0f b7 9a e4 15 81 00 	movzwl 0x8115e4(%edx),%ebx
  804344:	01 d8                	add    %ebx,%eax
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  804346:	83 c1 01             	add    $0x1,%ecx
  804349:	66 39 f1             	cmp    %si,%cx
  80434c:	75 e2                	jne    804330 <memp_init+0x2c>
  80434e:	83 c2 02             	add    $0x2,%edx
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  804351:	83 fa 1c             	cmp    $0x1c,%edx
  804354:	75 c1                	jne    804317 <memp_init+0x13>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  804356:	5b                   	pop    %ebx
  804357:	5e                   	pop    %esi
  804358:	5f                   	pop    %edi
  804359:	5d                   	pop    %ebp
  80435a:	c3                   	ret    

0080435b <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80435b:	55                   	push   %ebp
  80435c:	89 e5                	mov    %esp,%ebp
  80435e:	83 ec 08             	sub    $0x8,%esp
  804361:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804364:	83 fa 0d             	cmp    $0xd,%edx
  804367:	76 17                	jbe    804380 <memp_malloc+0x25>
  804369:	83 ec 04             	sub    $0x4,%esp
  80436c:	68 51 15 81 00       	push   $0x811551
  804371:	68 2d 01 00 00       	push   $0x12d
  804376:	68 6e 15 81 00       	push   $0x81156e
  80437b:	e8 d8 9f 00 00       	call   80e358 <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  804380:	8b 04 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%eax
  
  if (memp != NULL) {    
  804387:	85 c0                	test   %eax,%eax
  804389:	74 24                	je     8043af <memp_malloc+0x54>
    memp_tab[type] = memp->next;    
  80438b:	8b 08                	mov    (%eax),%ecx
  80438d:	89 0c 95 c0 43 b3 00 	mov    %ecx,0xb343c0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804394:	a8 03                	test   $0x3,%al
  804396:	74 17                	je     8043af <memp_malloc+0x54>
  804398:	83 ec 04             	sub    $0x4,%esp
  80439b:	68 84 15 81 00       	push   $0x811584
  8043a0:	68 3f 01 00 00       	push   $0x13f
  8043a5:	68 6e 15 81 00       	push   $0x81156e
  8043aa:	e8 a9 9f 00 00       	call   80e358 <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  8043af:	c9                   	leave  
  8043b0:	c3                   	ret    

008043b1 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8043b1:	55                   	push   %ebp
  8043b2:	89 e5                	mov    %esp,%ebp
  8043b4:	83 ec 08             	sub    $0x8,%esp
  8043b7:	8b 55 08             	mov    0x8(%ebp),%edx
  8043ba:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8043bd:	85 c0                	test   %eax,%eax
  8043bf:	74 2b                	je     8043ec <memp_free+0x3b>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8043c1:	a8 03                	test   $0x3,%al
  8043c3:	74 17                	je     8043dc <memp_free+0x2b>
  8043c5:	83 ec 04             	sub    $0x4,%esp
  8043c8:	68 a8 15 81 00       	push   $0x8115a8
  8043cd:	68 5b 01 00 00       	push   $0x15b
  8043d2:	68 6e 15 81 00       	push   $0x81156e
  8043d7:	e8 7c 9f 00 00       	call   80e358 <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8043dc:	8b 0c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ecx
  8043e3:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  8043e5:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  8043ec:	c9                   	leave  
  8043ed:	c3                   	ret    

008043ee <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  8043ee:	55                   	push   %ebp
  8043ef:	89 e5                	mov    %esp,%ebp
  8043f1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  8043f4:	85 c9                	test   %ecx,%ecx
  8043f6:	74 38                	je     804430 <netif_remove+0x42>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  8043f8:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  8043fd:	39 c1                	cmp    %eax,%ecx
  8043ff:	75 17                	jne    804418 <netif_remove+0x2a>
    netif_list = netif->next;
  804401:	8b 01                	mov    (%ecx),%eax
  804403:	a3 34 b2 b3 00       	mov    %eax,0xb3b234
  804408:	eb 14                	jmp    80441e <netif_remove+0x30>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  80440a:	8b 10                	mov    (%eax),%edx
  80440c:	39 d1                	cmp    %edx,%ecx
  80440e:	75 06                	jne    804416 <netif_remove+0x28>
        tmpNetif->next = netif->next;
  804410:	8b 11                	mov    (%ecx),%edx
  804412:	89 10                	mov    %edx,(%eax)
  804414:	eb 08                	jmp    80441e <netif_remove+0x30>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804416:	89 d0                	mov    %edx,%eax
  804418:	85 c0                	test   %eax,%eax
  80441a:	75 ee                	jne    80440a <netif_remove+0x1c>
  80441c:	eb 12                	jmp    804430 <netif_remove+0x42>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  80441e:	3b 0d 38 b2 b3 00    	cmp    0xb3b238,%ecx
  804424:	75 0a                	jne    804430 <netif_remove+0x42>
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804426:	c7 05 38 b2 b3 00 00 	movl   $0x0,0xb3b238
  80442d:	00 00 00 
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804430:	5d                   	pop    %ebp
  804431:	c3                   	ret    

00804432 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  804432:	55                   	push   %ebp
  804433:	89 e5                	mov    %esp,%ebp
  804435:	53                   	push   %ebx
  804436:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  804439:	85 c9                	test   %ecx,%ecx
  80443b:	74 2c                	je     804469 <netif_find+0x37>
    return NULL;
  }

  num = name[2] - '0';
  80443d:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  804441:	8d 50 d0             	lea    -0x30(%eax),%edx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804444:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804449:	eb 18                	jmp    804463 <netif_find+0x31>
    if (num == netif->num &&
  80444b:	3a 50 31             	cmp    0x31(%eax),%dl
  80444e:	75 11                	jne    804461 <netif_find+0x2f>
  804450:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  804454:	38 19                	cmp    %bl,(%ecx)
  804456:	75 09                	jne    804461 <netif_find+0x2f>
       name[0] == netif->name[0] &&
  804458:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  80445c:	38 59 01             	cmp    %bl,0x1(%ecx)
  80445f:	74 0d                	je     80446e <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804461:	8b 00                	mov    (%eax),%eax
  804463:	85 c0                	test   %eax,%eax
  804465:	75 e4                	jne    80444b <netif_find+0x19>
  804467:	eb 05                	jmp    80446e <netif_find+0x3c>
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
  804469:	b8 00 00 00 00       	mov    $0x0,%eax
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  80446e:	5b                   	pop    %ebx
  80446f:	5d                   	pop    %ebp
  804470:	c3                   	ret    

00804471 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  804471:	55                   	push   %ebp
  804472:	89 e5                	mov    %esp,%ebp
  804474:	57                   	push   %edi
  804475:	56                   	push   %esi
  804476:	53                   	push   %ebx
  804477:	83 ec 0c             	sub    $0xc,%esp
  80447a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80447d:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804480:	8b 43 04             	mov    0x4(%ebx),%eax
  804483:	39 06                	cmp    %eax,(%esi)
  804485:	74 54                	je     8044db <netif_set_ipaddr+0x6a>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  804487:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    while (pcb != NULL) {
  80448c:	eb 1d                	jmp    8044ab <netif_set_ipaddr+0x3a>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80448e:	8b 4b 04             	mov    0x4(%ebx),%ecx
  804491:	39 08                	cmp    %ecx,(%eax)
  804493:	75 13                	jne    8044a8 <netif_set_ipaddr+0x37>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  804495:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  804498:	83 ec 0c             	sub    $0xc,%esp
  80449b:	50                   	push   %eax
  80449c:	e8 42 16 00 00       	call   805ae3 <tcp_abort>
  8044a1:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  8044a4:	89 f8                	mov    %edi,%eax
  8044a6:	eb 03                	jmp    8044ab <netif_set_ipaddr+0x3a>
      } else {
        pcb = pcb->next;
  8044a8:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  8044ab:	85 c0                	test   %eax,%eax
  8044ad:	75 df                	jne    80448e <netif_set_ipaddr+0x1d>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8044af:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  8044b4:	eb 21                	jmp    8044d7 <netif_set_ipaddr+0x66>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  8044b6:	85 c0                	test   %eax,%eax
  8044b8:	74 1a                	je     8044d4 <netif_set_ipaddr+0x63>
  8044ba:	8b 10                	mov    (%eax),%edx
  8044bc:	85 d2                	test   %edx,%edx
  8044be:	74 14                	je     8044d4 <netif_set_ipaddr+0x63>
  8044c0:	3b 53 04             	cmp    0x4(%ebx),%edx
  8044c3:	75 0f                	jne    8044d4 <netif_set_ipaddr+0x63>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8044c5:	85 f6                	test   %esi,%esi
  8044c7:	74 04                	je     8044cd <netif_set_ipaddr+0x5c>
  8044c9:	8b 16                	mov    (%esi),%edx
  8044cb:	eb 05                	jmp    8044d2 <netif_set_ipaddr+0x61>
  8044cd:	ba 00 00 00 00       	mov    $0x0,%edx
  8044d2:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8044d4:	8b 40 0c             	mov    0xc(%eax),%eax
  8044d7:	85 c0                	test   %eax,%eax
  8044d9:	75 db                	jne    8044b6 <netif_set_ipaddr+0x45>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  8044db:	85 f6                	test   %esi,%esi
  8044dd:	74 04                	je     8044e3 <netif_set_ipaddr+0x72>
  8044df:	8b 06                	mov    (%esi),%eax
  8044e1:	eb 05                	jmp    8044e8 <netif_set_ipaddr+0x77>
  8044e3:	b8 00 00 00 00       	mov    $0x0,%eax
  8044e8:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  8044eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8044ee:	5b                   	pop    %ebx
  8044ef:	5e                   	pop    %esi
  8044f0:	5f                   	pop    %edi
  8044f1:	5d                   	pop    %ebp
  8044f2:	c3                   	ret    

008044f3 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  8044f3:	55                   	push   %ebp
  8044f4:	89 e5                	mov    %esp,%ebp
  8044f6:	57                   	push   %edi
  8044f7:	56                   	push   %esi
  8044f8:	53                   	push   %ebx
  8044f9:	83 ec 14             	sub    $0x14,%esp
  8044fc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8044ff:	8b 7d 10             	mov    0x10(%ebp),%edi
  804502:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  804505:	ff 75 0c             	pushl  0xc(%ebp)
  804508:	53                   	push   %ebx
  804509:	e8 63 ff ff ff       	call   804471 <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  80450e:	83 c4 10             	add    $0x10,%esp
  804511:	85 ff                	test   %edi,%edi
  804513:	74 04                	je     804519 <netif_set_addr+0x26>
  804515:	8b 07                	mov    (%edi),%eax
  804517:	eb 05                	jmp    80451e <netif_set_addr+0x2b>
  804519:	b8 00 00 00 00       	mov    $0x0,%eax
  80451e:	89 43 08             	mov    %eax,0x8(%ebx)
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  ip_addr_set(&(netif->gw), gw);
  804521:	85 f6                	test   %esi,%esi
  804523:	74 04                	je     804529 <netif_set_addr+0x36>
  804525:	8b 06                	mov    (%esi),%eax
  804527:	eb 05                	jmp    80452e <netif_set_addr+0x3b>
  804529:	b8 00 00 00 00       	mov    $0x0,%eax
  80452e:	89 43 0c             	mov    %eax,0xc(%ebx)
    struct ip_addr *gw)
{
  netif_set_ipaddr(netif, ipaddr);
  netif_set_netmask(netif, netmask);
  netif_set_gw(netif, gw);
}
  804531:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804534:	5b                   	pop    %ebx
  804535:	5e                   	pop    %esi
  804536:	5f                   	pop    %edi
  804537:	5d                   	pop    %ebp
  804538:	c3                   	ret    

00804539 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  804539:	55                   	push   %ebp
  80453a:	89 e5                	mov    %esp,%ebp
  80453c:	53                   	push   %ebx
  80453d:	83 ec 04             	sub    $0x4,%esp
  804540:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  804543:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  80454a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804551:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  804558:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  80455c:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  804563:	8b 45 18             	mov    0x18(%ebp),%eax
  804566:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804569:	0f b6 05 f8 43 b3 00 	movzbl 0xb343f8,%eax
  804570:	8d 50 01             	lea    0x1(%eax),%edx
  804573:	88 15 f8 43 b3 00    	mov    %dl,0xb343f8
  804579:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  80457c:	8b 45 20             	mov    0x20(%ebp),%eax
  80457f:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  804582:	ff 75 14             	pushl  0x14(%ebp)
  804585:	ff 75 10             	pushl  0x10(%ebp)
  804588:	ff 75 0c             	pushl  0xc(%ebp)
  80458b:	53                   	push   %ebx
  80458c:	e8 62 ff ff ff       	call   8044f3 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  804591:	89 1c 24             	mov    %ebx,(%esp)
  804594:	ff 55 1c             	call   *0x1c(%ebp)
  804597:	83 c4 10             	add    $0x10,%esp
  80459a:	84 c0                	test   %al,%al
  80459c:	75 11                	jne    8045af <netif_add+0x76>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  80459e:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  8045a3:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  8045a5:	89 1d 34 b2 b3 00    	mov    %ebx,0xb3b234
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  8045ab:	89 d8                	mov    %ebx,%eax
  8045ad:	eb 05                	jmp    8045b4 <netif_add+0x7b>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
  8045af:	b8 00 00 00 00       	mov    $0x0,%eax
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  8045b4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8045b7:	c9                   	leave  
  8045b8:	c3                   	ret    

008045b9 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  8045b9:	55                   	push   %ebp
  8045ba:	89 e5                	mov    %esp,%ebp
  8045bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&(netif->gw), gw);
  8045bf:	85 c0                	test   %eax,%eax
  8045c1:	74 04                	je     8045c7 <netif_set_gw+0xe>
  8045c3:	8b 10                	mov    (%eax),%edx
  8045c5:	eb 05                	jmp    8045cc <netif_set_gw+0x13>
  8045c7:	ba 00 00 00 00       	mov    $0x0,%edx
  8045cc:	8b 45 08             	mov    0x8(%ebp),%eax
  8045cf:	89 50 0c             	mov    %edx,0xc(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  8045d2:	5d                   	pop    %ebp
  8045d3:	c3                   	ret    

008045d4 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  8045d4:	55                   	push   %ebp
  8045d5:	89 e5                	mov    %esp,%ebp
  8045d7:	8b 45 0c             	mov    0xc(%ebp),%eax
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  8045da:	85 c0                	test   %eax,%eax
  8045dc:	74 04                	je     8045e2 <netif_set_netmask+0xe>
  8045de:	8b 10                	mov    (%eax),%edx
  8045e0:	eb 05                	jmp    8045e7 <netif_set_netmask+0x13>
  8045e2:	ba 00 00 00 00       	mov    $0x0,%edx
  8045e7:	8b 45 08             	mov    0x8(%ebp),%eax
  8045ea:	89 50 08             	mov    %edx,0x8(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  8045ed:	5d                   	pop    %ebp
  8045ee:	c3                   	ret    

008045ef <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  8045ef:	55                   	push   %ebp
  8045f0:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  8045f2:	8b 45 08             	mov    0x8(%ebp),%eax
  8045f5:	a3 38 b2 b3 00       	mov    %eax,0xb3b238
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  8045fa:	5d                   	pop    %ebp
  8045fb:	c3                   	ret    

008045fc <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8045fc:	55                   	push   %ebp
  8045fd:	89 e5                	mov    %esp,%ebp
  8045ff:	83 ec 08             	sub    $0x8,%esp
  804602:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  804605:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  804609:	a8 01                	test   $0x1,%al
  80460b:	75 1e                	jne    80462b <netif_set_up+0x2f>
    netif->flags |= NETIF_FLAG_UP;
  80460d:	89 c1                	mov    %eax,%ecx
  80460f:	83 c9 01             	or     $0x1,%ecx
  804612:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  804615:	a8 20                	test   $0x20,%al
  804617:	74 12                	je     80462b <netif_set_up+0x2f>
      etharp_query(netif, &(netif->ip_addr), NULL);
  804619:	83 ec 04             	sub    $0x4,%esp
  80461c:	6a 00                	push   $0x0
  80461e:	8d 42 04             	lea    0x4(%edx),%eax
  804621:	50                   	push   %eax
  804622:	52                   	push   %edx
  804623:	e8 2c 51 00 00       	call   809754 <etharp_query>
  804628:	83 c4 10             	add    $0x10,%esp
    }
#endif /* LWIP_ARP */
    
  }
}
  80462b:	c9                   	leave  
  80462c:	c3                   	ret    

0080462d <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  80462d:	55                   	push   %ebp
  80462e:	89 e5                	mov    %esp,%ebp
  804630:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  804633:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  804637:	a8 01                	test   $0x1,%al
  804639:	74 06                	je     804641 <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  80463b:	83 e0 fe             	and    $0xfffffffe,%eax
  80463e:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804641:	5d                   	pop    %ebp
  804642:	c3                   	ret    

00804643 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804643:	55                   	push   %ebp
  804644:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  804646:	8b 45 08             	mov    0x8(%ebp),%eax
  804649:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  80464d:	83 e0 01             	and    $0x1,%eax
}
  804650:	5d                   	pop    %ebp
  804651:	c3                   	ret    

00804652 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804652:	55                   	push   %ebp
  804653:	89 e5                	mov    %esp,%ebp
  804655:	56                   	push   %esi
  804656:	53                   	push   %ebx
  804657:	8b 55 08             	mov    0x8(%ebp),%edx
  80465a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  80465d:	85 d2                	test   %edx,%edx
  80465f:	75 17                	jne    804678 <pbuf_header+0x26>
  804661:	83 ec 04             	sub    $0x4,%esp
  804664:	68 c4 16 81 00       	push   $0x8116c4
  804669:	68 64 01 00 00       	push   $0x164
  80466e:	68 00 16 81 00       	push   $0x811600
  804673:	e8 e0 9c 00 00       	call   80e358 <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  804678:	66 85 c9             	test   %cx,%cx
  80467b:	0f 84 97 00 00 00    	je     804718 <pbuf_header+0xc6>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  804681:	89 ce                	mov    %ecx,%esi

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  804683:	66 85 c9             	test   %cx,%cx
  804686:	79 1f                	jns    8046a7 <pbuf_header+0x55>
    increment_magnitude = -header_size_increment;
  804688:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  80468a:	66 3b 72 0a          	cmp    0xa(%edx),%si
  80468e:	76 17                	jbe    8046a7 <pbuf_header+0x55>
  804690:	83 ec 04             	sub    $0x4,%esp
  804693:	68 15 16 81 00       	push   $0x811615
  804698:	68 6b 01 00 00       	push   $0x16b
  80469d:	68 00 16 81 00       	push   $0x811600
  8046a2:	e8 b1 9c 00 00       	call   80e358 <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  8046a7:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  8046ab:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  8046ae:	66 85 c0             	test   %ax,%ax
  8046b1:	74 06                	je     8046b9 <pbuf_header+0x67>
  8046b3:	66 83 f8 03          	cmp    $0x3,%ax
  8046b7:	75 13                	jne    8046cc <pbuf_header+0x7a>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  8046b9:	0f bf c1             	movswl %cx,%eax
  8046bc:	29 c3                	sub    %eax,%ebx
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8046be:	8d 72 10             	lea    0x10(%edx),%esi
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
  8046c1:	b8 01 00 00 00       	mov    $0x1,%eax
  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8046c6:	39 f3                	cmp    %esi,%ebx
  8046c8:	73 3c                	jae    804706 <pbuf_header+0xb4>
  8046ca:	eb 51                	jmp    80471d <pbuf_header+0xcb>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  8046cc:	83 e8 01             	sub    $0x1,%eax
  8046cf:	66 83 f8 01          	cmp    $0x1,%ax
  8046d3:	77 1a                	ja     8046ef <pbuf_header+0x9d>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  8046d5:	b8 01 00 00 00       	mov    $0x1,%eax
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  8046da:	66 85 c9             	test   %cx,%cx
  8046dd:	79 3e                	jns    80471d <pbuf_header+0xcb>
  8046df:	66 3b 72 0a          	cmp    0xa(%edx),%si
  8046e3:	77 38                	ja     80471d <pbuf_header+0xcb>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  8046e5:	0f bf c1             	movswl %cx,%eax
  8046e8:	29 c3                	sub    %eax,%ebx
  8046ea:	89 5a 04             	mov    %ebx,0x4(%edx)
  8046ed:	eb 1a                	jmp    804709 <pbuf_header+0xb7>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  8046ef:	83 ec 04             	sub    $0x4,%esp
  8046f2:	68 33 16 81 00       	push   $0x811633
  8046f7:	68 9a 01 00 00       	push   $0x19a
  8046fc:	68 00 16 81 00       	push   $0x811600
  804701:	e8 52 9c 00 00       	call   80e358 <_panic>
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  804706:	89 5a 04             	mov    %ebx,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  804709:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  80470d:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  804711:	b8 00 00 00 00       	mov    $0x0,%eax
  804716:	eb 05                	jmp    80471d <pbuf_header+0xcb>
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
  804718:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
  80471d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804720:	5b                   	pop    %ebx
  804721:	5e                   	pop    %esi
  804722:	5d                   	pop    %ebp
  804723:	c3                   	ret    

00804724 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  804724:	55                   	push   %ebp
  804725:	89 e5                	mov    %esp,%ebp
  804727:	56                   	push   %esi
  804728:	53                   	push   %ebx
  804729:	8b 55 08             	mov    0x8(%ebp),%edx
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80472c:	85 d2                	test   %edx,%edx
  80472e:	75 17                	jne    804747 <pbuf_free+0x23>
    LWIP_ASSERT("p != NULL", p != NULL);
  804730:	83 ec 04             	sub    $0x4,%esp
  804733:	68 c4 16 81 00       	push   $0x8116c4
  804738:	68 d0 01 00 00       	push   $0x1d0
  80473d:	68 00 16 81 00       	push   $0x811600
  804742:	e8 11 9c 00 00       	call   80e358 <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804747:	80 7a 0c 03          	cmpb   $0x3,0xc(%edx)
  80474b:	76 17                	jbe    804764 <pbuf_free+0x40>
  80474d:	83 ec 04             	sub    $0x4,%esp
  804750:	68 41 16 81 00       	push   $0x811641
  804755:	68 db 01 00 00       	push   $0x1db
  80475a:	68 00 16 81 00       	push   $0x811600
  80475f:	e8 f4 9b 00 00       	call   80e358 <_panic>
  804764:	bb 00 00 00 00       	mov    $0x0,%ebx
  804769:	eb 02                	jmp    80476d <pbuf_free+0x49>
      } else {
        mem_free(p);
      }
      count++;
      /* proceed to next pbuf */
      p = q;
  80476b:	89 f2                	mov    %esi,%edx
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80476d:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
  804771:	66 85 c0             	test   %ax,%ax
  804774:	75 17                	jne    80478d <pbuf_free+0x69>
  804776:	83 ec 04             	sub    $0x4,%esp
  804779:	68 56 16 81 00       	push   $0x811656
  80477e:	68 e8 01 00 00       	push   $0x1e8
  804783:	68 00 16 81 00       	push   $0x811600
  804788:	e8 cb 9b 00 00       	call   80e358 <_panic>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  80478d:	83 e8 01             	sub    $0x1,%eax
  804790:	66 89 42 0e          	mov    %ax,0xe(%edx)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  804794:	66 85 c0             	test   %ax,%ax
  804797:	75 48                	jne    8047e1 <pbuf_free+0xbd>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  804799:	8b 32                	mov    (%edx),%esi
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  80479b:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  80479f:	66 83 f8 03          	cmp    $0x3,%ax
  8047a3:	75 10                	jne    8047b5 <pbuf_free+0x91>
        memp_free(MEMP_PBUF_POOL, p);
  8047a5:	83 ec 08             	sub    $0x8,%esp
  8047a8:	52                   	push   %edx
  8047a9:	6a 0d                	push   $0xd
  8047ab:	e8 01 fc ff ff       	call   8043b1 <memp_free>
  8047b0:	83 c4 10             	add    $0x10,%esp
  8047b3:	eb 25                	jmp    8047da <pbuf_free+0xb6>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  8047b5:	83 e8 01             	sub    $0x1,%eax
  8047b8:	66 83 f8 01          	cmp    $0x1,%ax
  8047bc:	77 10                	ja     8047ce <pbuf_free+0xaa>
        memp_free(MEMP_PBUF, p);
  8047be:	83 ec 08             	sub    $0x8,%esp
  8047c1:	52                   	push   %edx
  8047c2:	6a 0c                	push   $0xc
  8047c4:	e8 e8 fb ff ff       	call   8043b1 <memp_free>
  8047c9:	83 c4 10             	add    $0x10,%esp
  8047cc:	eb 0c                	jmp    8047da <pbuf_free+0xb6>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  8047ce:	83 ec 0c             	sub    $0xc,%esp
  8047d1:	52                   	push   %edx
  8047d2:	e8 ab f6 ff ff       	call   803e82 <mem_free>
  8047d7:	83 c4 10             	add    $0x10,%esp
      }
      count++;
  8047da:	83 c3 01             	add    $0x1,%ebx
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  8047dd:	85 f6                	test   %esi,%esi
  8047df:	75 8a                	jne    80476b <pbuf_free+0x47>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  8047e1:	89 d8                	mov    %ebx,%eax
  8047e3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8047e6:	5b                   	pop    %ebx
  8047e7:	5e                   	pop    %esi
  8047e8:	5d                   	pop    %ebp
  8047e9:	c3                   	ret    

008047ea <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  8047ea:	55                   	push   %ebp
  8047eb:	89 e5                	mov    %esp,%ebp
  8047ed:	57                   	push   %edi
  8047ee:	56                   	push   %esi
  8047ef:	53                   	push   %ebx
  8047f0:	83 ec 1c             	sub    $0x1c,%esp
  8047f3:	8b 45 08             	mov    0x8(%ebp),%eax
  8047f6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  8047f9:	83 f8 01             	cmp    $0x1,%eax
  8047fc:	74 18                	je     804816 <pbuf_alloc+0x2c>
  8047fe:	83 f8 01             	cmp    $0x1,%eax
  804801:	72 0c                	jb     80480f <pbuf_alloc+0x25>
  804803:	83 f8 02             	cmp    $0x2,%eax
  804806:	74 18                	je     804820 <pbuf_alloc+0x36>
  804808:	83 f8 03             	cmp    $0x3,%eax
  80480b:	74 34                	je     804841 <pbuf_alloc+0x57>
  80480d:	eb 1b                	jmp    80482a <pbuf_alloc+0x40>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  80480f:	bf 14 00 00 00       	mov    $0x14,%edi
  804814:	eb 05                	jmp    80481b <pbuf_alloc+0x31>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804816:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  80481b:	83 c7 14             	add    $0x14,%edi
  80481e:	eb 05                	jmp    804825 <pbuf_alloc+0x3b>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804820:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  804825:	83 c7 0e             	add    $0xe,%edi
    break;
  804828:	eb 1c                	jmp    804846 <pbuf_alloc+0x5c>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  80482a:	83 ec 04             	sub    $0x4,%esp
  80482d:	68 6c 16 81 00       	push   $0x81166c
  804832:	68 8a 00 00 00       	push   $0x8a
  804837:	68 00 16 81 00       	push   $0x811600
  80483c:	e8 17 9b 00 00       	call   80e358 <_panic>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804841:	bf 00 00 00 00       	mov    $0x0,%edi
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  804846:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  80484a:	77 0f                	ja     80485b <pbuf_alloc+0x71>
  80484c:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  804850:	0f 82 60 01 00 00    	jb     8049b6 <pbuf_alloc+0x1cc>
  804856:	e9 a1 01 00 00       	jmp    8049fc <pbuf_alloc+0x212>
  80485b:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  80485f:	0f 85 c8 01 00 00    	jne    804a2d <pbuf_alloc+0x243>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  804865:	83 ec 0c             	sub    $0xc,%esp
  804868:	6a 0d                	push   $0xd
  80486a:	e8 ec fa ff ff       	call   80435b <memp_malloc>
  80486f:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  804871:	83 c4 10             	add    $0x10,%esp
  804874:	85 c0                	test   %eax,%eax
  804876:	0f 84 d6 01 00 00    	je     804a52 <pbuf_alloc+0x268>
      return NULL;
    }
    p->type = type;
  80487c:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804880:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804886:	0f b7 ff             	movzwl %di,%edi
  804889:	8d 54 38 13          	lea    0x13(%eax,%edi,1),%edx
  80488d:	83 e2 fc             	and    $0xfffffffc,%edx
  804890:	89 50 04             	mov    %edx,0x4(%eax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  804893:	66 89 58 08          	mov    %bx,0x8(%eax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804897:	0f b7 db             	movzwl %bx,%ebx
  80489a:	83 c7 03             	add    $0x3,%edi
  80489d:	83 e7 fc             	and    $0xfffffffc,%edi
  8048a0:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  8048a5:	29 f8                	sub    %edi,%eax
  8048a7:	39 d8                	cmp    %ebx,%eax
  8048a9:	0f 4f c3             	cmovg  %ebx,%eax
  8048ac:	66 89 46 0a          	mov    %ax,0xa(%esi)
  8048b0:	0f b7 c0             	movzwl %ax,%eax
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  8048b3:	8d 8e e0 07 00 00    	lea    0x7e0(%esi),%ecx
  8048b9:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8048bc:	01 c2                	add    %eax,%edx
  8048be:	39 d1                	cmp    %edx,%ecx
  8048c0:	73 17                	jae    8048d9 <pbuf_alloc+0xef>
  8048c2:	83 ec 04             	sub    $0x4,%esp
  8048c5:	68 84 17 81 00       	push   $0x811784
  8048ca:	68 a3 00 00 00       	push   $0xa3
  8048cf:	68 00 16 81 00       	push   $0x811600
  8048d4:	e8 7f 9a 00 00       	call   80e358 <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  8048d9:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  8048df:	29 c3                	sub    %eax,%ebx
    p->ref = 1;

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  8048e1:	89 f7                	mov    %esi,%edi
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  8048e3:	e9 c1 00 00 00       	jmp    8049a9 <pbuf_alloc+0x1bf>
      q = memp_malloc(MEMP_PBUF_POOL);
  8048e8:	83 ec 0c             	sub    $0xc,%esp
  8048eb:	6a 0d                	push   $0xd
  8048ed:	e8 69 fa ff ff       	call   80435b <memp_malloc>
      if (q == NULL) {
  8048f2:	83 c4 10             	add    $0x10,%esp
  8048f5:	85 c0                	test   %eax,%eax
  8048f7:	75 16                	jne    80490f <pbuf_alloc+0x125>
        /* free chain so far allocated */
        pbuf_free(p);
  8048f9:	83 ec 0c             	sub    $0xc,%esp
  8048fc:	56                   	push   %esi
  8048fd:	e8 22 fe ff ff       	call   804724 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
  804902:	83 c4 10             	add    $0x10,%esp
  804905:	b8 00 00 00 00       	mov    $0x0,%eax
  80490a:	e9 56 01 00 00       	jmp    804a65 <pbuf_alloc+0x27b>
      }
      q->type = type;
  80490f:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804913:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804917:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  80491d:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80491f:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  804925:	7e 17                	jle    80493e <pbuf_alloc+0x154>
  804927:	83 ec 04             	sub    $0x4,%esp
  80492a:	68 87 16 81 00       	push   $0x811687
  80492f:	68 bc 00 00 00       	push   $0xbc
  804934:	68 00 16 81 00       	push   $0x811600
  804939:	e8 1a 9a 00 00       	call   80e358 <_panic>
      q->tot_len = (u16_t)rem_len;
  80493e:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804942:	0f b7 d3             	movzwl %bx,%edx
  804945:	81 fa d0 07 00 00    	cmp    $0x7d0,%edx
  80494b:	bf d0 07 00 00       	mov    $0x7d0,%edi
  804950:	0f 4f d7             	cmovg  %edi,%edx
  804953:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804957:	8d 48 10             	lea    0x10(%eax),%ecx
  80495a:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  80495d:	f6 c1 03             	test   $0x3,%cl
  804960:	74 17                	je     804979 <pbuf_alloc+0x18f>
  804962:	83 ec 04             	sub    $0x4,%esp
  804965:	68 b8 17 81 00       	push   $0x8117b8
  80496a:	68 c2 00 00 00       	push   $0xc2
  80496f:	68 00 16 81 00       	push   $0x811600
  804974:	e8 df 99 00 00       	call   80e358 <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804979:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  80497d:	03 4e 04             	add    0x4(%esi),%ecx
  804980:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  804983:	73 17                	jae    80499c <pbuf_alloc+0x1b2>
  804985:	83 ec 04             	sub    $0x4,%esp
  804988:	68 84 17 81 00       	push   $0x811784
  80498d:	68 c5 00 00 00       	push   $0xc5
  804992:	68 00 16 81 00       	push   $0x811600
  804997:	e8 bc 99 00 00       	call   80e358 <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  80499c:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  8049a2:	0f b7 d2             	movzwl %dx,%edx
  8049a5:	29 d3                	sub    %edx,%ebx
      /* remember this pbuf for linkage in next iteration */
      r = q;
  8049a7:	89 c7                	mov    %eax,%edi
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  8049a9:	85 db                	test   %ebx,%ebx
  8049ab:	0f 8f 37 ff ff ff    	jg     8048e8 <pbuf_alloc+0xfe>
  8049b1:	e9 8e 00 00 00       	jmp    804a44 <pbuf_alloc+0x25a>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  8049b6:	0f b7 ff             	movzwl %di,%edi
  8049b9:	83 ec 0c             	sub    $0xc,%esp
  8049bc:	8d 47 13             	lea    0x13(%edi),%eax
  8049bf:	83 e0 fc             	and    $0xfffffffc,%eax
  8049c2:	89 c2                	mov    %eax,%edx
  8049c4:	0f b7 c3             	movzwl %bx,%eax
  8049c7:	83 c0 03             	add    $0x3,%eax
  8049ca:	83 e0 fc             	and    $0xfffffffc,%eax
  8049cd:	01 d0                	add    %edx,%eax
  8049cf:	50                   	push   %eax
  8049d0:	e8 5f f7 ff ff       	call   804134 <mem_malloc>
  8049d5:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8049d7:	83 c4 10             	add    $0x10,%esp
  8049da:	85 c0                	test   %eax,%eax
  8049dc:	74 7b                	je     804a59 <pbuf_alloc+0x26f>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  8049de:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  8049e2:	83 e0 fc             	and    $0xfffffffc,%eax
  8049e5:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  8049e8:	66 89 5e 08          	mov    %bx,0x8(%esi)
  8049ec:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  8049f0:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  8049f6:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  8049fa:	eb 48                	jmp    804a44 <pbuf_alloc+0x25a>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  8049fc:	83 ec 0c             	sub    $0xc,%esp
  8049ff:	6a 0c                	push   $0xc
  804a01:	e8 55 f9 ff ff       	call   80435b <memp_malloc>
  804a06:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  804a08:	83 c4 10             	add    $0x10,%esp
  804a0b:	85 c0                	test   %eax,%eax
  804a0d:	74 51                	je     804a60 <pbuf_alloc+0x276>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  804a0f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804a16:	66 89 58 08          	mov    %bx,0x8(%eax)
  804a1a:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  804a1e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804a24:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  804a28:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  804a2b:	eb 17                	jmp    804a44 <pbuf_alloc+0x25a>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804a2d:	83 ec 04             	sub    $0x4,%esp
  804a30:	68 9b 16 81 00       	push   $0x81169b
  804a35:	68 f1 00 00 00       	push   $0xf1
  804a3a:	68 00 16 81 00       	push   $0x811600
  804a3f:	e8 14 99 00 00       	call   80e358 <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  804a44:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  804a4a:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  804a4e:	89 f0                	mov    %esi,%eax
  804a50:	eb 13                	jmp    804a65 <pbuf_alloc+0x27b>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      return NULL;
  804a52:	b8 00 00 00 00       	mov    $0x0,%eax
  804a57:	eb 0c                	jmp    804a65 <pbuf_alloc+0x27b>
    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    if (p == NULL) {
      return NULL;
  804a59:	b8 00 00 00 00       	mov    $0x0,%eax
  804a5e:	eb 05                	jmp    804a65 <pbuf_alloc+0x27b>
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
    if (p == NULL) {
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  804a60:	b8 00 00 00 00       	mov    $0x0,%eax
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  804a65:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804a68:	5b                   	pop    %ebx
  804a69:	5e                   	pop    %esi
  804a6a:	5f                   	pop    %edi
  804a6b:	5d                   	pop    %ebp
  804a6c:	c3                   	ret    

00804a6d <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  804a6d:	55                   	push   %ebp
  804a6e:	89 e5                	mov    %esp,%ebp
  804a70:	57                   	push   %edi
  804a71:	56                   	push   %esi
  804a72:	53                   	push   %ebx
  804a73:	83 ec 0c             	sub    $0xc,%esp
  804a76:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804a79:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804a7c:	85 db                	test   %ebx,%ebx
  804a7e:	75 17                	jne    804a97 <pbuf_realloc+0x2a>
  804a80:	83 ec 04             	sub    $0x4,%esp
  804a83:	68 b6 16 81 00       	push   $0x8116b6
  804a88:	68 13 01 00 00       	push   $0x113
  804a8d:	68 00 16 81 00       	push   $0x811600
  804a92:	e8 c1 98 00 00       	call   80e358 <_panic>
  804a97:	89 f7                	mov    %esi,%edi
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804a99:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804a9d:	76 17                	jbe    804ab6 <pbuf_realloc+0x49>
  804a9f:	83 ec 04             	sub    $0x4,%esp
  804aa2:	68 ce 16 81 00       	push   $0x8116ce
  804aa7:	68 17 01 00 00       	push   $0x117
  804aac:	68 00 16 81 00       	push   $0x811600
  804ab1:	e8 a2 98 00 00       	call   80e358 <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  804ab6:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  804aba:	66 39 f2             	cmp    %si,%dx
  804abd:	0f 86 b8 00 00 00    	jbe    804b7b <pbuf_realloc+0x10e>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  804ac3:	0f b7 ce             	movzwl %si,%ecx
  804ac6:	0f b7 c2             	movzwl %dx,%eax
  804ac9:	29 c1                	sub    %eax,%ecx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804acb:	eb 46                	jmp    804b13 <pbuf_realloc+0xa6>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  804acd:	29 c6                	sub    %eax,%esi
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804acf:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804ad5:	7e 17                	jle    804aee <pbuf_realloc+0x81>
  804ad7:	83 ec 04             	sub    $0x4,%esp
  804ada:	68 e9 16 81 00       	push   $0x8116e9
  804adf:	68 2b 01 00 00       	push   $0x12b
  804ae4:	68 00 16 81 00       	push   $0x811600
  804ae9:	e8 6a 98 00 00       	call   80e358 <_panic>
    q->tot_len += (u16_t)grow;
  804aee:	89 f8                	mov    %edi,%eax
  804af0:	29 d0                	sub    %edx,%eax
  804af2:	66 01 43 08          	add    %ax,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  804af6:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804af8:	85 db                	test   %ebx,%ebx
  804afa:	75 17                	jne    804b13 <pbuf_realloc+0xa6>
  804afc:	83 ec 04             	sub    $0x4,%esp
  804aff:	68 fa 16 81 00       	push   $0x8116fa
  804b04:	68 2f 01 00 00       	push   $0x12f
  804b09:	68 00 16 81 00       	push   $0x811600
  804b0e:	e8 45 98 00 00       	call   80e358 <_panic>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  804b13:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804b17:	66 39 c6             	cmp    %ax,%si
  804b1a:	77 b1                	ja     804acd <pbuf_realloc+0x60>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804b1c:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804b20:	75 39                	jne    804b5b <pbuf_realloc+0xee>
  804b22:	66 39 c6             	cmp    %ax,%si
  804b25:	74 34                	je     804b5b <pbuf_realloc+0xee>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804b27:	8b 53 04             	mov    0x4(%ebx),%edx
  804b2a:	29 da                	sub    %ebx,%edx
  804b2c:	0f b7 c6             	movzwl %si,%eax
  804b2f:	01 d0                	add    %edx,%eax
  804b31:	83 ec 08             	sub    $0x8,%esp
  804b34:	50                   	push   %eax
  804b35:	53                   	push   %ebx
  804b36:	e8 b0 f4 ff ff       	call   803feb <mem_realloc>
  804b3b:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804b3d:	83 c4 10             	add    $0x10,%esp
  804b40:	85 c0                	test   %eax,%eax
  804b42:	75 17                	jne    804b5b <pbuf_realloc+0xee>
  804b44:	83 ec 04             	sub    $0x4,%esp
  804b47:	68 12 17 81 00       	push   $0x811712
  804b4c:	68 39 01 00 00       	push   $0x139
  804b51:	68 00 16 81 00       	push   $0x811600
  804b56:	e8 fd 97 00 00       	call   80e358 <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  804b5b:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804b5f:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  804b63:	8b 03                	mov    (%ebx),%eax
  804b65:	85 c0                	test   %eax,%eax
  804b67:	74 0c                	je     804b75 <pbuf_realloc+0x108>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  804b69:	83 ec 0c             	sub    $0xc,%esp
  804b6c:	50                   	push   %eax
  804b6d:	e8 b2 fb ff ff       	call   804724 <pbuf_free>
  804b72:	83 c4 10             	add    $0x10,%esp
  }
  /* q is last packet in chain */
  q->next = NULL;
  804b75:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  804b7b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804b7e:	5b                   	pop    %ebx
  804b7f:	5e                   	pop    %esi
  804b80:	5f                   	pop    %edi
  804b81:	5d                   	pop    %ebp
  804b82:	c3                   	ret    

00804b83 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804b83:	55                   	push   %ebp
  804b84:	89 e5                	mov    %esp,%ebp
  804b86:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  804b89:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  804b8e:	eb 05                	jmp    804b95 <pbuf_clen+0x12>
    ++len;
  804b90:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  804b93:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  804b95:	85 d2                	test   %edx,%edx
  804b97:	75 f7                	jne    804b90 <pbuf_clen+0xd>
    ++len;
    p = p->next;
  }
  return len;
}
  804b99:	5d                   	pop    %ebp
  804b9a:	c3                   	ret    

00804b9b <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804b9b:	55                   	push   %ebp
  804b9c:	89 e5                	mov    %esp,%ebp
  804b9e:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804ba1:	85 c0                	test   %eax,%eax
  804ba3:	74 05                	je     804baa <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804ba5:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804baa:	5d                   	pop    %ebp
  804bab:	c3                   	ret    

00804bac <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804bac:	55                   	push   %ebp
  804bad:	89 e5                	mov    %esp,%ebp
  804baf:	53                   	push   %ebx
  804bb0:	83 ec 04             	sub    $0x4,%esp
  804bb3:	8b 45 08             	mov    0x8(%ebp),%eax
  804bb6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804bb9:	85 c0                	test   %eax,%eax
  804bbb:	74 04                	je     804bc1 <pbuf_cat+0x15>
  804bbd:	85 db                	test   %ebx,%ebx
  804bbf:	75 21                	jne    804be2 <pbuf_cat+0x36>
  804bc1:	83 ec 04             	sub    $0x4,%esp
  804bc4:	68 e8 17 81 00       	push   $0x8117e8
  804bc9:	68 42 02 00 00       	push   $0x242
  804bce:	68 00 16 81 00       	push   $0x811600
  804bd3:	e8 80 97 00 00       	call   80e358 <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804bd8:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804bdc:	66 01 48 08          	add    %cx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  804be0:	89 d0                	mov    %edx,%eax
  804be2:	8b 10                	mov    (%eax),%edx
  804be4:	85 d2                	test   %edx,%edx
  804be6:	75 f0                	jne    804bd8 <pbuf_cat+0x2c>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804be8:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804bec:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804bf0:	74 17                	je     804c09 <pbuf_cat+0x5d>
  804bf2:	83 ec 04             	sub    $0x4,%esp
  804bf5:	68 20 18 81 00       	push   $0x811820
  804bfa:	68 4a 02 00 00       	push   $0x24a
  804bff:	68 00 16 81 00       	push   $0x811600
  804c04:	e8 4f 97 00 00       	call   80e358 <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804c09:	66 03 53 08          	add    0x8(%ebx),%dx
  804c0d:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804c11:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804c13:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804c16:	c9                   	leave  
  804c17:	c3                   	ret    

00804c18 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804c18:	55                   	push   %ebp
  804c19:	89 e5                	mov    %esp,%ebp
  804c1b:	53                   	push   %ebx
  804c1c:	83 ec 0c             	sub    $0xc,%esp
  804c1f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804c22:	53                   	push   %ebx
  804c23:	ff 75 08             	pushl  0x8(%ebp)
  804c26:	e8 81 ff ff ff       	call   804bac <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804c2b:	89 1c 24             	mov    %ebx,(%esp)
  804c2e:	e8 68 ff ff ff       	call   804b9b <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804c33:	83 c4 10             	add    $0x10,%esp
  804c36:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804c39:	c9                   	leave  
  804c3a:	c3                   	ret    

00804c3b <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804c3b:	55                   	push   %ebp
  804c3c:	89 e5                	mov    %esp,%ebp
  804c3e:	57                   	push   %edi
  804c3f:	56                   	push   %esi
  804c40:	53                   	push   %ebx
  804c41:	83 ec 1c             	sub    $0x1c,%esp
  804c44:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804c47:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804c49:	85 f6                	test   %esi,%esi
  804c4b:	0f 84 80 00 00 00    	je     804cd1 <pbuf_dechain+0x96>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804c51:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804c55:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804c59:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804c5d:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804c60:	0f b7 d0             	movzwl %ax,%edx
  804c63:	0f b7 f9             	movzwl %cx,%edi
  804c66:	29 fa                	sub    %edi,%edx
  804c68:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804c6b:	74 17                	je     804c84 <pbuf_dechain+0x49>
  804c6d:	83 ec 04             	sub    $0x4,%esp
  804c70:	68 50 18 81 00       	push   $0x811850
  804c75:	68 80 02 00 00       	push   $0x280
  804c7a:	68 00 16 81 00       	push   $0x811600
  804c7f:	e8 d4 96 00 00       	call   80e358 <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804c84:	29 c8                	sub    %ecx,%eax
  804c86:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804c8a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804c90:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804c94:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804c98:	83 ec 0c             	sub    $0xc,%esp
  804c9b:	56                   	push   %esi
  804c9c:	e8 83 fa ff ff       	call   804724 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804ca1:	83 c4 10             	add    $0x10,%esp
  804ca4:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804ca8:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804cac:	74 17                	je     804cc5 <pbuf_dechain+0x8a>
  804cae:	83 ec 04             	sub    $0x4,%esp
  804cb1:	68 2d 17 81 00       	push   $0x81172d
  804cb6:	68 91 02 00 00       	push   $0x291
  804cbb:	68 00 16 81 00       	push   $0x811600
  804cc0:	e8 93 96 00 00       	call   80e358 <_panic>
  return ((tail_gone > 0) ? NULL : q);
  804cc5:	84 c0                	test   %al,%al
  804cc7:	b8 00 00 00 00       	mov    $0x0,%eax
  804ccc:	0f 44 c6             	cmove  %esi,%eax
  804ccf:	eb 0f                	jmp    804ce0 <pbuf_dechain+0xa5>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804cd1:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804cd5:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804cd9:	75 d3                	jne    804cae <pbuf_dechain+0x73>
  return ((tail_gone > 0) ? NULL : q);
  804cdb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804ce0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804ce3:	5b                   	pop    %ebx
  804ce4:	5e                   	pop    %esi
  804ce5:	5f                   	pop    %edi
  804ce6:	5d                   	pop    %ebp
  804ce7:	c3                   	ret    

00804ce8 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804ce8:	55                   	push   %ebp
  804ce9:	89 e5                	mov    %esp,%ebp
  804ceb:	57                   	push   %edi
  804cec:	56                   	push   %esi
  804ced:	53                   	push   %ebx
  804cee:	83 ec 1c             	sub    $0x1c,%esp
  804cf1:	8b 75 08             	mov    0x8(%ebp),%esi
  804cf4:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804cf7:	85 f6                	test   %esi,%esi
  804cf9:	74 0e                	je     804d09 <pbuf_copy+0x21>
  804cfb:	85 db                	test   %ebx,%ebx
  804cfd:	74 0a                	je     804d09 <pbuf_copy+0x21>
  804cff:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804d03:	66 39 46 08          	cmp    %ax,0x8(%esi)
  804d07:	73 17                	jae    804d20 <pbuf_copy+0x38>
  804d09:	83 ec 04             	sub    $0x4,%esp
  804d0c:	68 74 18 81 00       	push   $0x811874
  804d11:	68 b1 02 00 00       	push   $0x2b1
  804d16:	68 00 16 81 00       	push   $0x811600
  804d1b:	e8 38 96 00 00       	call   80e358 <_panic>
  804d20:	bf 00 00 00 00       	mov    $0x0,%edi
  804d25:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804d2b:	66 89 7d e6          	mov    %di,-0x1a(%ebp)
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  804d2f:	85 f6                	test   %esi,%esi
  804d31:	75 17                	jne    804d4a <pbuf_copy+0x62>
  804d33:	83 ec 04             	sub    $0x4,%esp
  804d36:	68 42 17 81 00       	push   $0x811742
  804d3b:	68 b6 02 00 00       	push   $0x2b6
  804d40:	68 00 16 81 00       	push   $0x811600
  804d45:	e8 0e 96 00 00       	call   80e358 <_panic>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  804d4a:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  804d4e:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804d52:	29 c1                	sub    %eax,%ecx
  804d54:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  804d58:	0f b7 7d e6          	movzwl -0x1a(%ebp),%edi
  804d5c:	0f b7 c7             	movzwl %di,%eax
  804d5f:	29 c2                	sub    %eax,%edx
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  804d61:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d65:	29 f8                	sub    %edi,%eax
  804d67:	0f b7 7e 0a          	movzwl 0xa(%esi),%edi
  804d6b:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  804d6f:	39 d1                	cmp    %edx,%ecx
  804d71:	89 c1                	mov    %eax,%ecx
  804d73:	0f 4c cf             	cmovl  %edi,%ecx
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  804d76:	83 ec 04             	sub    $0x4,%esp
  804d79:	66 89 4d e2          	mov    %cx,-0x1e(%ebp)
  804d7d:	0f b7 c1             	movzwl %cx,%eax
  804d80:	50                   	push   %eax
  804d81:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804d85:	03 43 04             	add    0x4(%ebx),%eax
  804d88:	50                   	push   %eax
  804d89:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  804d8d:	0f b7 c7             	movzwl %di,%eax
  804d90:	03 46 04             	add    0x4(%esi),%eax
  804d93:	50                   	push   %eax
  804d94:	e8 17 9e 00 00       	call   80ebb0 <memcpy>
    offset_to += len;
  804d99:	89 f8                	mov    %edi,%eax
  804d9b:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  804d9f:	01 c8                	add    %ecx,%eax
  804da1:	89 c2                	mov    %eax,%edx
  804da3:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    offset_from += len;
  804da7:	66 01 4d e6          	add    %cx,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804dab:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  804daf:	83 c4 10             	add    $0x10,%esp
  804db2:	66 39 c2             	cmp    %ax,%dx
  804db5:	76 17                	jbe    804dce <pbuf_copy+0xe6>
  804db7:	83 ec 04             	sub    $0x4,%esp
  804dba:	68 4f 17 81 00       	push   $0x81174f
  804dbf:	68 c2 02 00 00       	push   $0x2c2
  804dc4:	68 00 16 81 00       	push   $0x811600
  804dc9:	e8 8a 95 00 00       	call   80e358 <_panic>
    if (offset_to == p_to->len) {
  804dce:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
  804dd2:	75 08                	jne    804ddc <pbuf_copy+0xf4>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  804dd4:	8b 36                	mov    (%esi),%esi
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
  804dd6:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804ddc:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804de0:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  804de4:	76 17                	jbe    804dfd <pbuf_copy+0x115>
  804de6:	83 ec 04             	sub    $0x4,%esp
  804de9:	68 66 17 81 00       	push   $0x811766
  804dee:	68 c8 02 00 00       	push   $0x2c8
  804df3:	68 00 16 81 00       	push   $0x811600
  804df8:	e8 5b 95 00 00       	call   80e358 <_panic>
    if (offset_from >= p_from->len) {
  804dfd:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  804e01:	72 08                	jb     804e0b <pbuf_copy+0x123>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  804e03:	8b 1b                	mov    (%ebx),%ebx
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  804e05:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804e0b:	85 db                	test   %ebx,%ebx
  804e0d:	74 26                	je     804e35 <pbuf_copy+0x14d>
  804e0f:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804e13:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  804e17:	75 1c                	jne    804e35 <pbuf_copy+0x14d>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804e19:	83 3b 00             	cmpl   $0x0,(%ebx)
  804e1c:	74 17                	je     804e35 <pbuf_copy+0x14d>
  804e1e:	83 ec 04             	sub    $0x4,%esp
  804e21:	68 a4 18 81 00       	push   $0x8118a4
  804e26:	68 d2 02 00 00       	push   $0x2d2
  804e2b:	68 00 16 81 00       	push   $0x811600
  804e30:	e8 23 95 00 00       	call   80e358 <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804e35:	85 f6                	test   %esi,%esi
  804e37:	74 26                	je     804e5f <pbuf_copy+0x177>
  804e39:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  804e3d:	66 39 46 0a          	cmp    %ax,0xa(%esi)
  804e41:	75 1c                	jne    804e5f <pbuf_copy+0x177>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804e43:	83 3e 00             	cmpl   $0x0,(%esi)
  804e46:	74 17                	je     804e5f <pbuf_copy+0x177>
  804e48:	83 ec 04             	sub    $0x4,%esp
  804e4b:	68 a4 18 81 00       	push   $0x8118a4
  804e50:	68 d7 02 00 00       	push   $0x2d7
  804e55:	68 00 16 81 00       	push   $0x811600
  804e5a:	e8 f9 94 00 00       	call   80e358 <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  804e5f:	85 db                	test   %ebx,%ebx
  804e61:	0f 85 c8 fe ff ff    	jne    804d2f <pbuf_copy+0x47>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  804e67:	b8 00 00 00 00       	mov    $0x0,%eax
  804e6c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804e6f:	5b                   	pop    %ebx
  804e70:	5e                   	pop    %esi
  804e71:	5f                   	pop    %edi
  804e72:	5d                   	pop    %ebp
  804e73:	c3                   	ret    

00804e74 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  804e74:	55                   	push   %ebp
  804e75:	89 e5                	mov    %esp,%ebp
  804e77:	57                   	push   %edi
  804e78:	56                   	push   %esi
  804e79:	53                   	push   %ebx
  804e7a:	83 ec 1c             	sub    $0x1c,%esp
  804e7d:	8b 75 08             	mov    0x8(%ebp),%esi
  804e80:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  804e84:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804e88:	85 f6                	test   %esi,%esi
  804e8a:	75 17                	jne    804ea3 <pbuf_copy_partial+0x2f>
  804e8c:	83 ec 04             	sub    $0x4,%esp
  804e8f:	68 d0 18 81 00       	push   $0x8118d0
  804e94:	68 ef 02 00 00       	push   $0x2ef
  804e99:	68 00 16 81 00       	push   $0x811600
  804e9e:	e8 b5 94 00 00       	call   80e358 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  804ea3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  804ea7:	75 66                	jne    804f0f <pbuf_copy_partial+0x9b>
  804ea9:	83 ec 04             	sub    $0x4,%esp
  804eac:	68 f4 18 81 00       	push   $0x8118f4
  804eb1:	68 f0 02 00 00       	push   $0x2f0
  804eb6:	68 00 16 81 00       	push   $0x811600
  804ebb:	e8 98 94 00 00       	call   80e358 <_panic>
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  804ec0:	66 85 c0             	test   %ax,%ax
  804ec3:	74 0d                	je     804ed2 <pbuf_copy_partial+0x5e>
  804ec5:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  804ec9:	66 39 d0             	cmp    %dx,%ax
  804ecc:	72 04                	jb     804ed2 <pbuf_copy_partial+0x5e>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  804ece:	29 d0                	sub    %edx,%eax
  804ed0:	eb 39                	jmp    804f0b <pbuf_copy_partial+0x97>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  804ed2:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  804ed6:	29 c3                	sub    %eax,%ebx
  804ed8:	66 39 df             	cmp    %bx,%di
  804edb:	0f 46 df             	cmovbe %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  804ede:	83 ec 04             	sub    $0x4,%esp
  804ee1:	0f b7 d3             	movzwl %bx,%edx
  804ee4:	52                   	push   %edx
  804ee5:	0f b7 c0             	movzwl %ax,%eax
  804ee8:	03 46 04             	add    0x4(%esi),%eax
  804eeb:	50                   	push   %eax
  804eec:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804ef0:	03 45 0c             	add    0xc(%ebp),%eax
  804ef3:	50                   	push   %eax
  804ef4:	e8 b7 9c 00 00       	call   80ebb0 <memcpy>
      copied_total += buf_copy_len;
  804ef9:	66 01 5d e4          	add    %bx,-0x1c(%ebp)
      left += buf_copy_len;
  804efd:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      len -= buf_copy_len;
  804f01:	29 df                	sub    %ebx,%edi
  804f03:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  804f06:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  804f0b:	8b 36                	mov    (%esi),%esi
  804f0d:	eb 0c                	jmp    804f1b <pbuf_copy_partial+0xa7>
  804f0f:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804f15:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804f1b:	66 85 ff             	test   %di,%di
  804f1e:	74 04                	je     804f24 <pbuf_copy_partial+0xb0>
  804f20:	85 f6                	test   %esi,%esi
  804f22:	75 9c                	jne    804ec0 <pbuf_copy_partial+0x4c>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  804f24:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804f28:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804f2b:	5b                   	pop    %ebx
  804f2c:	5e                   	pop    %esi
  804f2d:	5f                   	pop    %edi
  804f2e:	5d                   	pop    %ebp
  804f2f:	c3                   	ret    

00804f30 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  804f30:	55                   	push   %ebp
  804f31:	89 e5                	mov    %esp,%ebp
  804f33:	83 ec 14             	sub    $0x14,%esp
  804f36:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  804f39:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  804f3e:	8b 40 04             	mov    0x4(%eax),%eax
  804f41:	ff 30                	pushl  (%eax)
  804f43:	e8 8f 4f 00 00       	call   809ed7 <sys_sem_signal>
}
  804f48:	83 c4 10             	add    $0x10,%esp
  804f4b:	c9                   	leave  
  804f4c:	c3                   	ret    

00804f4d <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  804f4d:	55                   	push   %ebp
  804f4e:	89 e5                	mov    %esp,%ebp
  804f50:	57                   	push   %edi
  804f51:	56                   	push   %esi
  804f52:	53                   	push   %ebx
  804f53:	83 ec 0c             	sub    $0xc,%esp
  804f56:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  804f59:	e8 7b 53 00 00       	call   80a2d9 <sys_arch_timeouts>
  804f5e:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  804f60:	85 c0                	test   %eax,%eax
  804f62:	74 06                	je     804f6a <sys_mbox_fetch+0x1d>
  804f64:	8b 00                	mov    (%eax),%eax
  804f66:	85 c0                	test   %eax,%eax
  804f68:	75 13                	jne    804f7d <sys_mbox_fetch+0x30>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  804f6a:	83 ec 04             	sub    $0x4,%esp
  804f6d:	6a 00                	push   $0x0
  804f6f:	57                   	push   %edi
  804f70:	ff 75 08             	pushl  0x8(%ebp)
  804f73:	e8 ce 51 00 00       	call   80a146 <sys_arch_mbox_fetch>
  804f78:	83 c4 10             	add    $0x10,%esp
  804f7b:	eb 5c                	jmp    804fd9 <sys_mbox_fetch+0x8c>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  804f7d:	8b 40 04             	mov    0x4(%eax),%eax
  804f80:	85 c0                	test   %eax,%eax
  804f82:	74 15                	je     804f99 <sys_mbox_fetch+0x4c>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  804f84:	83 ec 04             	sub    $0x4,%esp
  804f87:	50                   	push   %eax
  804f88:	57                   	push   %edi
  804f89:	ff 75 08             	pushl  0x8(%ebp)
  804f8c:	e8 b5 51 00 00       	call   80a146 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  804f91:	83 c4 10             	add    $0x10,%esp
  804f94:	83 f8 ff             	cmp    $0xffffffff,%eax
  804f97:	75 29                	jne    804fc2 <sys_mbox_fetch+0x75>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  804f99:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  804f9b:	8b 10                	mov    (%eax),%edx
  804f9d:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  804f9f:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  804fa2:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  804fa5:	83 ec 08             	sub    $0x8,%esp
  804fa8:	50                   	push   %eax
  804fa9:	6a 0b                	push   $0xb
  804fab:	e8 01 f4 ff ff       	call   8043b1 <memp_free>
      if (h != NULL) {
  804fb0:	83 c4 10             	add    $0x10,%esp
  804fb3:	85 db                	test   %ebx,%ebx
  804fb5:	74 a2                	je     804f59 <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  804fb7:	83 ec 0c             	sub    $0xc,%esp
  804fba:	56                   	push   %esi
  804fbb:	ff d3                	call   *%ebx
  804fbd:	83 c4 10             	add    $0x10,%esp
  804fc0:	eb 97                	jmp    804f59 <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  804fc2:	8b 0b                	mov    (%ebx),%ecx
  804fc4:	8b 51 04             	mov    0x4(%ecx),%edx
  804fc7:	39 d0                	cmp    %edx,%eax
  804fc9:	73 07                	jae    804fd2 <sys_mbox_fetch+0x85>
        timeouts->next->time -= time_needed;
  804fcb:	29 c2                	sub    %eax,%edx
  804fcd:	89 51 04             	mov    %edx,0x4(%ecx)
  804fd0:	eb 07                	jmp    804fd9 <sys_mbox_fetch+0x8c>
      } else {
        timeouts->next->time = 0;
  804fd2:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
      }
    }
  }
}
  804fd9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804fdc:	5b                   	pop    %ebx
  804fdd:	5e                   	pop    %esi
  804fde:	5f                   	pop    %edi
  804fdf:	5d                   	pop    %ebp
  804fe0:	c3                   	ret    

00804fe1 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  804fe1:	55                   	push   %ebp
  804fe2:	89 e5                	mov    %esp,%ebp
  804fe4:	57                   	push   %edi
  804fe5:	56                   	push   %esi
  804fe6:	53                   	push   %ebx
  804fe7:	83 ec 0c             	sub    $0xc,%esp
  804fea:	8b 75 08             	mov    0x8(%ebp),%esi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  804fed:	e8 e7 52 00 00       	call   80a2d9 <sys_arch_timeouts>
  804ff2:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  804ff4:	85 c0                	test   %eax,%eax
  804ff6:	74 06                	je     804ffe <sys_sem_wait+0x1d>
  804ff8:	8b 00                	mov    (%eax),%eax
  804ffa:	85 c0                	test   %eax,%eax
  804ffc:	75 10                	jne    80500e <sys_sem_wait+0x2d>
    sys_arch_sem_wait(sem, 0);
  804ffe:	83 ec 08             	sub    $0x8,%esp
  805001:	6a 00                	push   $0x0
  805003:	56                   	push   %esi
  805004:	e8 3c 4f 00 00       	call   809f45 <sys_arch_sem_wait>
  805009:	83 c4 10             	add    $0x10,%esp
  80500c:	eb 59                	jmp    805067 <sys_sem_wait+0x86>
  } else {
    if (timeouts->next->time > 0) {
  80500e:	8b 40 04             	mov    0x4(%eax),%eax
  805011:	85 c0                	test   %eax,%eax
  805013:	74 12                	je     805027 <sys_sem_wait+0x46>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  805015:	83 ec 08             	sub    $0x8,%esp
  805018:	50                   	push   %eax
  805019:	56                   	push   %esi
  80501a:	e8 26 4f 00 00       	call   809f45 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80501f:	83 c4 10             	add    $0x10,%esp
  805022:	83 f8 ff             	cmp    $0xffffffff,%eax
  805025:	75 29                	jne    805050 <sys_sem_wait+0x6f>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  805027:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805029:	8b 10                	mov    (%eax),%edx
  80502b:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  80502d:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805030:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805033:	83 ec 08             	sub    $0x8,%esp
  805036:	50                   	push   %eax
  805037:	6a 0b                	push   $0xb
  805039:	e8 73 f3 ff ff       	call   8043b1 <memp_free>
      if (h != NULL) {
  80503e:	83 c4 10             	add    $0x10,%esp
  805041:	85 db                	test   %ebx,%ebx
  805043:	74 a8                	je     804fed <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  805045:	83 ec 0c             	sub    $0xc,%esp
  805048:	57                   	push   %edi
  805049:	ff d3                	call   *%ebx
  80504b:	83 c4 10             	add    $0x10,%esp
  80504e:	eb 9d                	jmp    804fed <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805050:	8b 0b                	mov    (%ebx),%ecx
  805052:	8b 51 04             	mov    0x4(%ecx),%edx
  805055:	39 d0                	cmp    %edx,%eax
  805057:	73 07                	jae    805060 <sys_sem_wait+0x7f>
        timeouts->next->time -= time_needed;
  805059:	29 c2                	sub    %eax,%edx
  80505b:	89 51 04             	mov    %edx,0x4(%ecx)
  80505e:	eb 07                	jmp    805067 <sys_sem_wait+0x86>
      } else {
        timeouts->next->time = 0;
  805060:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
      }
    }
  }
}
  805067:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80506a:	5b                   	pop    %ebx
  80506b:	5e                   	pop    %esi
  80506c:	5f                   	pop    %edi
  80506d:	5d                   	pop    %ebp
  80506e:	c3                   	ret    

0080506f <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80506f:	55                   	push   %ebp
  805070:	89 e5                	mov    %esp,%ebp
  805072:	56                   	push   %esi
  805073:	53                   	push   %ebx
  805074:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  805077:	83 ec 0c             	sub    $0xc,%esp
  80507a:	6a 0b                	push   $0xb
  80507c:	e8 da f2 ff ff       	call   80435b <memp_malloc>
  if (timeout == NULL) {
  805081:	83 c4 10             	add    $0x10,%esp
  805084:	85 c0                	test   %eax,%eax
  805086:	75 17                	jne    80509f <sys_timeout+0x30>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  805088:	83 ec 04             	sub    $0x4,%esp
  80508b:	68 19 19 81 00       	push   $0x811919
  805090:	68 c3 00 00 00       	push   $0xc3
  805095:	68 36 19 81 00       	push   $0x811936
  80509a:	e8 b9 92 00 00       	call   80e358 <_panic>
  80509f:	89 c3                	mov    %eax,%ebx
    return;
  }
  timeout->next = NULL;
  8050a1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8050a7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8050aa:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  8050ad:	8b 45 10             	mov    0x10(%ebp),%eax
  8050b0:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  8050b3:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  8050b6:	e8 1e 52 00 00       	call   80a2d9 <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  8050bb:	85 c0                	test   %eax,%eax
  8050bd:	75 17                	jne    8050d6 <sys_timeout+0x67>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  8050bf:	83 ec 04             	sub    $0x4,%esp
  8050c2:	68 4a 19 81 00       	push   $0x81194a
  8050c7:	68 d1 00 00 00       	push   $0xd1
  8050cc:	68 36 19 81 00       	push   $0x811936
  8050d1:	e8 82 92 00 00       	call   80e358 <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  8050d6:	8b 08                	mov    (%eax),%ecx
  8050d8:	85 c9                	test   %ecx,%ecx
  8050da:	75 04                	jne    8050e0 <sys_timeout+0x71>
    timeouts->next = timeout;
  8050dc:	89 18                	mov    %ebx,(%eax)
    return;
  8050de:	eb 37                	jmp    805117 <sys_timeout+0xa8>
  }

  if (timeouts->next->time > msecs) {
  8050e0:	8b 51 04             	mov    0x4(%ecx),%edx
  8050e3:	39 d6                	cmp    %edx,%esi
  8050e5:	73 0f                	jae    8050f6 <sys_timeout+0x87>
    timeouts->next->time -= msecs;
  8050e7:	29 f2                	sub    %esi,%edx
  8050e9:	89 51 04             	mov    %edx,0x4(%ecx)
    timeout->next = timeouts->next;
  8050ec:	8b 10                	mov    (%eax),%edx
  8050ee:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  8050f0:	89 18                	mov    %ebx,(%eax)
  8050f2:	eb 23                	jmp    805117 <sys_timeout+0xa8>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
  8050f4:	89 d1                	mov    %edx,%ecx
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  8050f6:	8b 43 04             	mov    0x4(%ebx),%eax
  8050f9:	2b 41 04             	sub    0x4(%ecx),%eax
  8050fc:	89 43 04             	mov    %eax,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  8050ff:	8b 11                	mov    (%ecx),%edx
  805101:	85 d2                	test   %edx,%edx
  805103:	74 0c                	je     805111 <sys_timeout+0xa2>
  805105:	8b 72 04             	mov    0x4(%edx),%esi
  805108:	39 f0                	cmp    %esi,%eax
  80510a:	73 e8                	jae    8050f4 <sys_timeout+0x85>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  80510c:	29 c6                	sub    %eax,%esi
  80510e:	89 72 04             	mov    %esi,0x4(%edx)
        }
        timeout->next = t->next;
  805111:	8b 01                	mov    (%ecx),%eax
  805113:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  805115:	89 19                	mov    %ebx,(%ecx)
        break;
      }
    }
  }
}
  805117:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80511a:	5b                   	pop    %ebx
  80511b:	5e                   	pop    %esi
  80511c:	5d                   	pop    %ebp
  80511d:	c3                   	ret    

0080511e <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80511e:	55                   	push   %ebp
  80511f:	89 e5                	mov    %esp,%ebp
  805121:	57                   	push   %edi
  805122:	56                   	push   %esi
  805123:	53                   	push   %ebx
  805124:	83 ec 0c             	sub    $0xc,%esp
  805127:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80512a:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80512d:	e8 a7 51 00 00       	call   80a2d9 <sys_arch_timeouts>

  if (timeouts == NULL) {
  805132:	85 c0                	test   %eax,%eax
  805134:	75 17                	jne    80514d <sys_untimeout+0x2f>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  805136:	83 ec 04             	sub    $0x4,%esp
  805139:	68 68 19 81 00       	push   $0x811968
  80513e:	68 00 01 00 00       	push   $0x100
  805143:	68 36 19 81 00       	push   $0x811936
  805148:	e8 0b 92 00 00       	call   80e358 <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  80514d:	8b 10                	mov    (%eax),%edx
  80514f:	85 d2                	test   %edx,%edx
  805151:	74 45                	je     805198 <sys_untimeout+0x7a>
  805153:	bf 00 00 00 00       	mov    $0x0,%edi
  805158:	eb 02                	jmp    80515c <sys_untimeout+0x3e>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80515a:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  80515c:	39 5a 08             	cmp    %ebx,0x8(%edx)
  80515f:	75 2f                	jne    805190 <sys_untimeout+0x72>
  805161:	39 72 0c             	cmp    %esi,0xc(%edx)
  805164:	75 2a                	jne    805190 <sys_untimeout+0x72>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  805166:	85 ff                	test   %edi,%edi
  805168:	75 06                	jne    805170 <sys_untimeout+0x52>
        timeouts->next = t->next;
  80516a:	8b 0a                	mov    (%edx),%ecx
  80516c:	89 08                	mov    %ecx,(%eax)
  80516e:	eb 04                	jmp    805174 <sys_untimeout+0x56>
      else
        prev_t->next = t->next;
  805170:	8b 02                	mov    (%edx),%eax
  805172:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  805174:	8b 02                	mov    (%edx),%eax
  805176:	85 c0                	test   %eax,%eax
  805178:	74 06                	je     805180 <sys_untimeout+0x62>
        t->next->time += t->time;
  80517a:	8b 4a 04             	mov    0x4(%edx),%ecx
  80517d:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  805180:	83 ec 08             	sub    $0x8,%esp
  805183:	52                   	push   %edx
  805184:	6a 0b                	push   $0xb
  805186:	e8 26 f2 ff ff       	call   8043b1 <memp_free>
      return;
  80518b:	83 c4 10             	add    $0x10,%esp
  80518e:	eb 08                	jmp    805198 <sys_untimeout+0x7a>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805190:	8b 0a                	mov    (%edx),%ecx
  805192:	89 d7                	mov    %edx,%edi
  805194:	85 c9                	test   %ecx,%ecx
  805196:	75 c2                	jne    80515a <sys_untimeout+0x3c>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  805198:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80519b:	5b                   	pop    %ebx
  80519c:	5e                   	pop    %esi
  80519d:	5f                   	pop    %edi
  80519e:	5d                   	pop    %ebp
  80519f:	c3                   	ret    

008051a0 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8051a0:	55                   	push   %ebp
  8051a1:	89 e5                	mov    %esp,%ebp
  8051a3:	83 ec 18             	sub    $0x18,%esp
  8051a6:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  8051a9:	8d 4d 08             	lea    0x8(%ebp),%ecx
  8051ac:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8051af:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8051b5:	85 c0                	test   %eax,%eax
  8051b7:	74 15                	je     8051ce <sys_sem_wait_timeout+0x2e>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  8051b9:	83 ec 04             	sub    $0x4,%esp
  8051bc:	8d 55 f0             	lea    -0x10(%ebp),%edx
  8051bf:	52                   	push   %edx
  8051c0:	68 30 4f 80 00       	push   $0x804f30
  8051c5:	50                   	push   %eax
  8051c6:	e8 a4 fe ff ff       	call   80506f <sys_timeout>
  8051cb:	83 c4 10             	add    $0x10,%esp
  }
  sys_sem_wait(sem);
  8051ce:	83 ec 0c             	sub    $0xc,%esp
  8051d1:	ff 75 08             	pushl  0x8(%ebp)
  8051d4:	e8 08 fe ff ff       	call   804fe1 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8051d9:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  8051dc:	b8 00 00 00 00       	mov    $0x0,%eax
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8051e1:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  8051e6:	75 19                	jne    805201 <sys_sem_wait_timeout+0x61>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  8051e8:	83 ec 08             	sub    $0x8,%esp
  8051eb:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8051ee:	50                   	push   %eax
  8051ef:	68 30 4f 80 00       	push   $0x804f30
  8051f4:	e8 25 ff ff ff       	call   80511e <sys_untimeout>
    return 1;
  8051f9:	83 c4 10             	add    $0x10,%esp
  8051fc:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  805201:	c9                   	leave  
  805202:	c3                   	ret    

00805203 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  805203:	55                   	push   %ebp
  805204:	89 e5                	mov    %esp,%ebp
  805206:	53                   	push   %ebx
  805207:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  80520a:	6a 00                	push   $0x0
  80520c:	e8 1a 4a 00 00       	call   809c2b <sys_sem_new>
  805211:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  805213:	83 c4 08             	add    $0x8,%esp
  805216:	ff 75 08             	pushl  0x8(%ebp)
  805219:	50                   	push   %eax
  80521a:	e8 81 ff ff ff       	call   8051a0 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  80521f:	89 1c 24             	mov    %ebx,(%esp)
  805222:	e8 85 4a 00 00       	call   809cac <sys_sem_free>
}
  805227:	83 c4 10             	add    $0x10,%esp
  80522a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80522d:	c9                   	leave  
  80522e:	c3                   	ret    

0080522f <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80522f:	55                   	push   %ebp
  805230:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805232:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  805237:	5d                   	pop    %ebp
  805238:	c3                   	ret    

00805239 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  805239:	55                   	push   %ebp
  80523a:	89 e5                	mov    %esp,%ebp
  80523c:	57                   	push   %edi
  80523d:	56                   	push   %esi
  80523e:	53                   	push   %ebx
  80523f:	83 ec 04             	sub    $0x4,%esp
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805242:	8b 35 3c b2 b3 00    	mov    0xb3b23c,%esi
  805248:	0f b7 0d 0c 40 81 00 	movzwl 0x81400c,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80524f:	8b 3d 50 b2 b3 00    	mov    0xb3b250,%edi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805255:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80525a:	89 45 f0             	mov    %eax,-0x10(%ebp)
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  80525d:	bb 00 10 00 00       	mov    $0x1000,%ebx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  805262:	89 c8                	mov    %ecx,%eax
  805264:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  805268:	0f 48 c3             	cmovs  %ebx,%eax
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80526b:	89 f2                	mov    %esi,%edx
  80526d:	eb 0c                	jmp    80527b <tcp_new_port+0x42>
    if (pcb->local_port == port) {
  80526f:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  805273:	66 39 c8             	cmp    %cx,%ax
  805276:	74 ea                	je     805262 <tcp_new_port+0x29>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805278:	8b 52 0c             	mov    0xc(%edx),%edx
  80527b:	85 d2                	test   %edx,%edx
  80527d:	75 f0                	jne    80526f <tcp_new_port+0x36>
  80527f:	89 fa                	mov    %edi,%edx
  805281:	eb 0c                	jmp    80528f <tcp_new_port+0x56>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  805283:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  805287:	66 39 c8             	cmp    %cx,%ax
  80528a:	74 d6                	je     805262 <tcp_new_port+0x29>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80528c:	8b 52 0c             	mov    0xc(%edx),%edx
  80528f:	85 d2                	test   %edx,%edx
  805291:	75 f0                	jne    805283 <tcp_new_port+0x4a>
  805293:	8b 55 f0             	mov    -0x10(%ebp),%edx
  805296:	eb 0c                	jmp    8052a4 <tcp_new_port+0x6b>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  805298:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80529c:	66 39 c8             	cmp    %cx,%ax
  80529f:	74 c1                	je     805262 <tcp_new_port+0x29>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8052a1:	8b 52 0c             	mov    0xc(%edx),%edx
  8052a4:	85 d2                	test   %edx,%edx
  8052a6:	75 f0                	jne    805298 <tcp_new_port+0x5f>
  8052a8:	66 a3 0c 40 81 00    	mov    %ax,0x81400c
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  8052ae:	83 c4 04             	add    $0x4,%esp
  8052b1:	5b                   	pop    %ebx
  8052b2:	5e                   	pop    %esi
  8052b3:	5f                   	pop    %edi
  8052b4:	5d                   	pop    %ebp
  8052b5:	c3                   	ret    

008052b6 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8052b6:	55                   	push   %ebp
  8052b7:	89 e5                	mov    %esp,%ebp
  8052b9:	57                   	push   %edi
  8052ba:	56                   	push   %esi
  8052bb:	53                   	push   %ebx
  8052bc:	83 ec 0c             	sub    $0xc,%esp
  8052bf:	8b 75 08             	mov    0x8(%ebp),%esi
  8052c2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8052c5:	8b 55 10             	mov    0x10(%ebp),%edx
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8052c8:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  8052cc:	74 17                	je     8052e5 <tcp_bind+0x2f>
  8052ce:	83 ec 04             	sub    $0x4,%esp
  8052d1:	68 88 19 81 00       	push   $0x811988
  8052d6:	68 05 01 00 00       	push   $0x105
  8052db:	68 6a 1b 81 00       	push   $0x811b6a
  8052e0:	e8 73 90 00 00       	call   80e358 <_panic>
  8052e5:	89 d0                	mov    %edx,%eax

  if (port == 0) {
  8052e7:	66 85 d2             	test   %dx,%dx
  8052ea:	75 05                	jne    8052f1 <tcp_bind+0x3b>
    port = tcp_new_port();
  8052ec:	e8 48 ff ff ff       	call   805239 <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8052f1:	8b 15 44 b2 b3 00    	mov    0xb3b244,%edx
  8052f7:	eb 35                	jmp    80532e <tcp_bind+0x78>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  8052f9:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  8052fd:	75 2c                	jne    80532b <tcp_bind+0x75>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8052ff:	85 d2                	test   %edx,%edx
  805301:	0f 84 f3 00 00 00    	je     8053fa <tcp_bind+0x144>
  805307:	8b 0a                	mov    (%edx),%ecx
  805309:	85 db                	test   %ebx,%ebx
  80530b:	0f 84 f0 00 00 00    	je     805401 <tcp_bind+0x14b>
  805311:	85 c9                	test   %ecx,%ecx
  805313:	0f 84 e8 00 00 00    	je     805401 <tcp_bind+0x14b>
          ip_addr_isany(ipaddr) ||
  805319:	8b 3b                	mov    (%ebx),%edi
  80531b:	39 f9                	cmp    %edi,%ecx
  80531d:	0f 84 e5 00 00 00    	je     805408 <tcp_bind+0x152>
  805323:	85 ff                	test   %edi,%edi
  805325:	0f 84 dd 00 00 00    	je     805408 <tcp_bind+0x152>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80532b:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80532e:	85 d2                	test   %edx,%edx
  805330:	75 c7                	jne    8052f9 <tcp_bind+0x43>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805332:	8b 15 3c b2 b3 00    	mov    0xb3b23c,%edx
  805338:	eb 35                	jmp    80536f <tcp_bind+0xb9>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80533a:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  80533e:	75 2c                	jne    80536c <tcp_bind+0xb6>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805340:	85 d2                	test   %edx,%edx
  805342:	0f 84 c7 00 00 00    	je     80540f <tcp_bind+0x159>
  805348:	8b 0a                	mov    (%edx),%ecx
  80534a:	85 db                	test   %ebx,%ebx
  80534c:	0f 84 c4 00 00 00    	je     805416 <tcp_bind+0x160>
  805352:	85 c9                	test   %ecx,%ecx
  805354:	0f 84 bc 00 00 00    	je     805416 <tcp_bind+0x160>
          ip_addr_isany(ipaddr) ||
  80535a:	8b 3b                	mov    (%ebx),%edi
  80535c:	39 f9                	cmp    %edi,%ecx
  80535e:	0f 84 b9 00 00 00    	je     80541d <tcp_bind+0x167>
  805364:	85 ff                	test   %edi,%edi
  805366:	0f 84 b1 00 00 00    	je     80541d <tcp_bind+0x167>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80536c:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80536f:	85 d2                	test   %edx,%edx
  805371:	75 c7                	jne    80533a <tcp_bind+0x84>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805373:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  805379:	eb 35                	jmp    8053b0 <tcp_bind+0xfa>
    if (cpcb->local_port == port) {
  80537b:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  80537f:	75 2c                	jne    8053ad <tcp_bind+0xf7>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805381:	85 d2                	test   %edx,%edx
  805383:	0f 84 9b 00 00 00    	je     805424 <tcp_bind+0x16e>
  805389:	8b 0a                	mov    (%edx),%ecx
  80538b:	85 db                	test   %ebx,%ebx
  80538d:	0f 84 98 00 00 00    	je     80542b <tcp_bind+0x175>
  805393:	85 c9                	test   %ecx,%ecx
  805395:	0f 84 90 00 00 00    	je     80542b <tcp_bind+0x175>
          ip_addr_isany(ipaddr) ||
  80539b:	8b 3b                	mov    (%ebx),%edi
  80539d:	39 f9                	cmp    %edi,%ecx
  80539f:	0f 84 8d 00 00 00    	je     805432 <tcp_bind+0x17c>
  8053a5:	85 ff                	test   %edi,%edi
  8053a7:	0f 84 85 00 00 00    	je     805432 <tcp_bind+0x17c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8053ad:	8b 52 0c             	mov    0xc(%edx),%edx
  8053b0:	85 d2                	test   %edx,%edx
  8053b2:	75 c7                	jne    80537b <tcp_bind+0xc5>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8053b4:	8b 15 50 b2 b3 00    	mov    0xb3b250,%edx
  8053ba:	eb 0f                	jmp    8053cb <tcp_bind+0x115>
    if (cpcb->local_port == port) {
  8053bc:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  8053c0:	75 06                	jne    8053c8 <tcp_bind+0x112>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  8053c2:	8b 3b                	mov    (%ebx),%edi
  8053c4:	39 3a                	cmp    %edi,(%edx)
  8053c6:	74 71                	je     805439 <tcp_bind+0x183>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8053c8:	8b 52 0c             	mov    0xc(%edx),%edx
  8053cb:	85 d2                	test   %edx,%edx
  8053cd:	75 ed                	jne    8053bc <tcp_bind+0x106>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  8053cf:	85 db                	test   %ebx,%ebx
  8053d1:	74 09                	je     8053dc <tcp_bind+0x126>
  8053d3:	83 3b 00             	cmpl   $0x0,(%ebx)
  8053d6:	74 04                	je     8053dc <tcp_bind+0x126>
    pcb->local_ip = *ipaddr;
  8053d8:	8b 13                	mov    (%ebx),%edx
  8053da:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  8053dc:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  8053e0:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  8053e5:	89 46 0c             	mov    %eax,0xc(%esi)
  8053e8:	89 35 4c b2 b3 00    	mov    %esi,0xb3b24c
  8053ee:	e8 70 cd ff ff       	call   802163 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  8053f3:	b8 00 00 00 00       	mov    $0x0,%eax
  8053f8:	eb 44                	jmp    80543e <tcp_bind+0x188>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  8053fa:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8053ff:	eb 3d                	jmp    80543e <tcp_bind+0x188>
  805401:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805406:	eb 36                	jmp    80543e <tcp_bind+0x188>
  805408:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80540d:	eb 2f                	jmp    80543e <tcp_bind+0x188>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80540f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805414:	eb 28                	jmp    80543e <tcp_bind+0x188>
  805416:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80541b:	eb 21                	jmp    80543e <tcp_bind+0x188>
  80541d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805422:	eb 1a                	jmp    80543e <tcp_bind+0x188>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805424:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805429:	eb 13                	jmp    80543e <tcp_bind+0x188>
  80542b:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805430:	eb 0c                	jmp    80543e <tcp_bind+0x188>
  805432:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805437:	eb 05                	jmp    80543e <tcp_bind+0x188>
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805439:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
  80543e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805441:	5b                   	pop    %ebx
  805442:	5e                   	pop    %esi
  805443:	5f                   	pop    %edi
  805444:	5d                   	pop    %ebp
  805445:	c3                   	ret    

00805446 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  805446:	55                   	push   %ebp
  805447:	89 e5                	mov    %esp,%ebp
  805449:	57                   	push   %edi
  80544a:	56                   	push   %esi
  80544b:	53                   	push   %ebx
  80544c:	83 ec 1c             	sub    $0x1c,%esp
  80544f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805452:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  805456:	74 17                	je     80546f <tcp_listen_with_backlog+0x29>
  805458:	83 ec 04             	sub    $0x4,%esp
  80545b:	68 b4 19 81 00       	push   $0x8119b4
  805460:	68 60 01 00 00       	push   $0x160
  805465:	68 6a 1b 81 00       	push   $0x811b6a
  80546a:	e8 e9 8e 00 00       	call   80e358 <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80546f:	83 ec 0c             	sub    $0xc,%esp
  805472:	6a 03                	push   $0x3
  805474:	e8 e2 ee ff ff       	call   80435b <memp_malloc>
  805479:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  80547b:	83 c4 10             	add    $0x10,%esp
  80547e:	85 c0                	test   %eax,%eax
  805480:	0f 84 d2 00 00 00    	je     805558 <tcp_listen_with_backlog+0x112>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  805486:	8b 43 18             	mov    0x18(%ebx),%eax
  805489:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  80548c:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805490:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  805494:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  80549b:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80549f:	83 c8 02             	or     $0x2,%eax
  8054a2:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  8054a6:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  8054aa:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  8054ad:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  8054b1:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  8054b4:	85 db                	test   %ebx,%ebx
  8054b6:	74 04                	je     8054bc <tcp_listen_with_backlog+0x76>
  8054b8:	8b 03                	mov    (%ebx),%eax
  8054ba:	eb 05                	jmp    8054c1 <tcp_listen_with_backlog+0x7b>
  8054bc:	b8 00 00 00 00       	mov    $0x0,%eax
  8054c1:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8054c3:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  8054c8:	39 c3                	cmp    %eax,%ebx
  8054ca:	75 0a                	jne    8054d6 <tcp_listen_with_backlog+0x90>
  8054cc:	8b 43 0c             	mov    0xc(%ebx),%eax
  8054cf:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  8054d4:	eb 4f                	jmp    805525 <tcp_listen_with_backlog+0xdf>
  8054d6:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  8054db:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  8054df:	89 df                	mov    %ebx,%edi
  8054e1:	eb 2c                	jmp    80550f <tcp_listen_with_backlog+0xc9>
  8054e3:	8b 50 0c             	mov    0xc(%eax),%edx
  8054e6:	39 d7                	cmp    %edx,%edi
  8054e8:	0f 94 c3             	sete   %bl
  8054eb:	85 d2                	test   %edx,%edx
  8054ed:	0f 95 c1             	setne  %cl
  8054f0:	84 cb                	test   %cl,%bl
  8054f2:	74 15                	je     805509 <tcp_listen_with_backlog+0xc3>
  8054f4:	89 fb                	mov    %edi,%ebx
  8054f6:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8054fa:	74 05                	je     805501 <tcp_listen_with_backlog+0xbb>
  8054fc:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  805501:	8b 53 0c             	mov    0xc(%ebx),%edx
  805504:	89 50 0c             	mov    %edx,0xc(%eax)
  805507:	eb 1c                	jmp    805525 <tcp_listen_with_backlog+0xdf>
  805509:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  80550d:	89 d0                	mov    %edx,%eax
  80550f:	85 c0                	test   %eax,%eax
  805511:	75 d0                	jne    8054e3 <tcp_listen_with_backlog+0x9d>
  805513:	89 fb                	mov    %edi,%ebx
  805515:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  805519:	74 0a                	je     805525 <tcp_listen_with_backlog+0xdf>
  80551b:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805522:	00 00 00 
  805525:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  80552c:	83 ec 08             	sub    $0x8,%esp
  80552f:	53                   	push   %ebx
  805530:	6a 02                	push   $0x2
  805532:	e8 7a ee ff ff       	call   8043b1 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  805537:	c7 46 20 2f 52 80 00 	movl   $0x80522f,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  80553e:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  805543:	89 46 0c             	mov    %eax,0xc(%esi)
  805546:	89 35 44 b2 b3 00    	mov    %esi,0xb3b244
  80554c:	e8 12 cc ff ff       	call   802163 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  805551:	83 c4 10             	add    $0x10,%esp
  805554:	89 f0                	mov    %esi,%eax
  805556:	eb 05                	jmp    80555d <tcp_listen_with_backlog+0x117>
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  805558:	b8 00 00 00 00       	mov    $0x0,%eax
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  return (struct tcp_pcb *)lpcb;
}
  80555d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805560:	5b                   	pop    %ebx
  805561:	5e                   	pop    %esi
  805562:	5f                   	pop    %edi
  805563:	5d                   	pop    %ebp
  805564:	c3                   	ret    

00805565 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  805565:	55                   	push   %ebp
  805566:	89 e5                	mov    %esp,%ebp
  805568:	56                   	push   %esi
  805569:	53                   	push   %ebx
  80556a:	8b 45 08             	mov    0x8(%ebp),%eax
  80556d:	8b 55 0c             	mov    0xc(%ebp),%edx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805570:	0f b7 58 28          	movzwl 0x28(%eax),%ebx
  805574:	0f b7 f3             	movzwl %bx,%esi
  805577:	0f b7 ca             	movzwl %dx,%ecx
  80557a:	01 f1                	add    %esi,%ecx
  80557c:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  805582:	76 0e                	jbe    805592 <tcp_recved+0x2d>
    pcb->rcv_wnd = TCP_WND;
  805584:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  80558a:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  805590:	eb 10                	jmp    8055a2 <tcp_recved+0x3d>
  } else {
    pcb->rcv_wnd += len;
  805592:	01 da                	add    %ebx,%edx
  805594:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805598:	66 3b 50 34          	cmp    0x34(%eax),%dx
  80559c:	72 04                	jb     8055a2 <tcp_recved+0x3d>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  80559e:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  8055a2:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  8055a6:	f6 c2 03             	test   $0x3,%dl
  8055a9:	75 24                	jne    8055cf <tcp_recved+0x6a>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  8055ab:	f6 c2 01             	test   $0x1,%dl
  8055ae:	74 17                	je     8055c7 <tcp_recved+0x62>
  8055b0:	83 e2 fe             	and    $0xfffffffe,%edx
  8055b3:	83 ca 02             	or     $0x2,%edx
  8055b6:	88 50 20             	mov    %dl,0x20(%eax)
  8055b9:	83 ec 0c             	sub    $0xc,%esp
  8055bc:	50                   	push   %eax
  8055bd:	e8 37 29 00 00       	call   807ef9 <tcp_output>
  8055c2:	83 c4 10             	add    $0x10,%esp
  8055c5:	eb 27                	jmp    8055ee <tcp_recved+0x89>
  8055c7:	83 ca 01             	or     $0x1,%edx
  8055ca:	88 50 20             	mov    %dl,0x20(%eax)
  8055cd:	eb 1f                	jmp    8055ee <tcp_recved+0x89>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  8055cf:	f6 c2 01             	test   $0x1,%dl
  8055d2:	74 1a                	je     8055ee <tcp_recved+0x89>
  8055d4:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  8055da:	76 12                	jbe    8055ee <tcp_recved+0x89>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  8055dc:	83 ca 02             	or     $0x2,%edx
  8055df:	88 50 20             	mov    %dl,0x20(%eax)
  8055e2:	83 ec 0c             	sub    $0xc,%esp
  8055e5:	50                   	push   %eax
  8055e6:	e8 0e 29 00 00       	call   807ef9 <tcp_output>
  8055eb:	83 c4 10             	add    $0x10,%esp
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  8055ee:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8055f1:	5b                   	pop    %ebx
  8055f2:	5e                   	pop    %esi
  8055f3:	5d                   	pop    %ebp
  8055f4:	c3                   	ret    

008055f5 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  8055f5:	55                   	push   %ebp
  8055f6:	89 e5                	mov    %esp,%ebp
  8055f8:	53                   	push   %ebx
  8055f9:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8055fc:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  805602:	eb 5d                	jmp    805661 <tcp_fasttmr+0x6c>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  805604:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80560a:	85 c0                	test   %eax,%eax
  80560c:	74 32                	je     805640 <tcp_fasttmr+0x4b>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80560e:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  805614:	85 d2                	test   %edx,%edx
  805616:	74 12                	je     80562a <tcp_fasttmr+0x35>
  805618:	6a 00                	push   $0x0
  80561a:	50                   	push   %eax
  80561b:	53                   	push   %ebx
  80561c:	ff 73 18             	pushl  0x18(%ebx)
  80561f:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805621:	83 c4 10             	add    $0x10,%esp
  805624:	84 c0                	test   %al,%al
  805626:	75 18                	jne    805640 <tcp_fasttmr+0x4b>
  805628:	eb 0c                	jmp    805636 <tcp_fasttmr+0x41>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80562a:	83 ec 0c             	sub    $0xc,%esp
  80562d:	50                   	push   %eax
  80562e:	e8 f1 f0 ff ff       	call   804724 <pbuf_free>
  805633:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  805636:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80563d:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  805640:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  805644:	a8 01                	test   $0x1,%al
  805646:	74 16                	je     80565e <tcp_fasttmr+0x69>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805648:	83 c8 02             	or     $0x2,%eax
  80564b:	88 43 20             	mov    %al,0x20(%ebx)
  80564e:	83 ec 0c             	sub    $0xc,%esp
  805651:	53                   	push   %ebx
  805652:	e8 a2 28 00 00       	call   807ef9 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805657:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  80565b:	83 c4 10             	add    $0x10,%esp
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80565e:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  805661:	85 db                	test   %ebx,%ebx
  805663:	75 9f                	jne    805604 <tcp_fasttmr+0xf>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  805665:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805668:	c9                   	leave  
  805669:	c3                   	ret    

0080566a <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  80566a:	55                   	push   %ebp
  80566b:	89 e5                	mov    %esp,%ebp
  80566d:	56                   	push   %esi
  80566e:	53                   	push   %ebx
  80566f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  
  if (seg != NULL) {
  805672:	85 db                	test   %ebx,%ebx
  805674:	74 2a                	je     8056a0 <tcp_seg_free+0x36>
    if (seg->p != NULL) {
  805676:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  805679:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
    if (seg->p != NULL) {
  80567e:	85 c0                	test   %eax,%eax
  805680:	74 0e                	je     805690 <tcp_seg_free+0x26>
      count = pbuf_free(seg->p);
  805682:	83 ec 0c             	sub    $0xc,%esp
  805685:	50                   	push   %eax
  805686:	e8 99 f0 ff ff       	call   804724 <pbuf_free>
  80568b:	89 c6                	mov    %eax,%esi
  80568d:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805690:	83 ec 08             	sub    $0x8,%esp
  805693:	53                   	push   %ebx
  805694:	6a 04                	push   $0x4
  805696:	e8 16 ed ff ff       	call   8043b1 <memp_free>
  80569b:	83 c4 10             	add    $0x10,%esp
  80569e:	eb 05                	jmp    8056a5 <tcp_seg_free+0x3b>
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  8056a0:	be 00 00 00 00       	mov    $0x0,%esi
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  }
  return count;
}
  8056a5:	89 f0                	mov    %esi,%eax
  8056a7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8056aa:	5b                   	pop    %ebx
  8056ab:	5e                   	pop    %esi
  8056ac:	5d                   	pop    %ebp
  8056ad:	c3                   	ret    

008056ae <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  8056ae:	55                   	push   %ebp
  8056af:	89 e5                	mov    %esp,%ebp
  8056b1:	56                   	push   %esi
  8056b2:	53                   	push   %ebx
  8056b3:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  8056b6:	bb 00 00 00 00       	mov    $0x0,%ebx
  struct tcp_seg *next;
  while (seg != NULL) {
  8056bb:	eb 12                	jmp    8056cf <tcp_segs_free+0x21>
    next = seg->next;
  8056bd:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  8056bf:	83 ec 0c             	sub    $0xc,%esp
  8056c2:	50                   	push   %eax
  8056c3:	e8 a2 ff ff ff       	call   80566a <tcp_seg_free>
  8056c8:	01 c3                	add    %eax,%ebx
  8056ca:	83 c4 10             	add    $0x10,%esp
    seg = next;
  8056cd:	89 f0                	mov    %esi,%eax
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  8056cf:	85 c0                	test   %eax,%eax
  8056d1:	75 ea                	jne    8056bd <tcp_segs_free+0xf>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  8056d3:	89 d8                	mov    %ebx,%eax
  8056d5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8056d8:	5b                   	pop    %ebx
  8056d9:	5e                   	pop    %esi
  8056da:	5d                   	pop    %ebp
  8056db:	c3                   	ret    

008056dc <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8056dc:	55                   	push   %ebp
  8056dd:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  8056df:	8b 55 0c             	mov    0xc(%ebp),%edx
  8056e2:	8b 45 08             	mov    0x8(%ebp),%eax
  8056e5:	88 50 14             	mov    %dl,0x14(%eax)
}
  8056e8:	5d                   	pop    %ebp
  8056e9:	c3                   	ret    

008056ea <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8056ea:	55                   	push   %ebp
  8056eb:	89 e5                	mov    %esp,%ebp
  8056ed:	53                   	push   %ebx
  8056ee:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  8056f1:	6a 04                	push   $0x4
  8056f3:	e8 63 ec ff ff       	call   80435b <memp_malloc>
  8056f8:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  8056fa:	83 c4 10             	add    $0x10,%esp
  8056fd:	85 c0                	test   %eax,%eax
  8056ff:	74 1c                	je     80571d <tcp_seg_copy+0x33>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805701:	83 ec 04             	sub    $0x4,%esp
  805704:	6a 14                	push   $0x14
  805706:	ff 75 08             	pushl  0x8(%ebp)
  805709:	50                   	push   %eax
  80570a:	e8 a1 94 00 00       	call   80ebb0 <memcpy>
  pbuf_ref(cseg->p);
  80570f:	83 c4 04             	add    $0x4,%esp
  805712:	ff 73 04             	pushl  0x4(%ebx)
  805715:	e8 81 f4 ff ff       	call   804b9b <pbuf_ref>
  return cseg;
  80571a:	83 c4 10             	add    $0x10,%esp
}
  80571d:	89 d8                	mov    %ebx,%eax
  80571f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805722:	c9                   	leave  
  805723:	c3                   	ret    

00805724 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805724:	55                   	push   %ebp
  805725:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  805727:	8b 55 0c             	mov    0xc(%ebp),%edx
  80572a:	8b 45 08             	mov    0x8(%ebp),%eax
  80572d:	89 50 18             	mov    %edx,0x18(%eax)
}
  805730:	5d                   	pop    %ebp
  805731:	c3                   	ret    

00805732 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805732:	55                   	push   %ebp
  805733:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  805735:	8b 55 0c             	mov    0xc(%ebp),%edx
  805738:	8b 45 08             	mov    0x8(%ebp),%eax
  80573b:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805741:	5d                   	pop    %ebp
  805742:	c3                   	ret    

00805743 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805743:	55                   	push   %ebp
  805744:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805746:	8b 55 0c             	mov    0xc(%ebp),%edx
  805749:	8b 45 08             	mov    0x8(%ebp),%eax
  80574c:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805752:	5d                   	pop    %ebp
  805753:	c3                   	ret    

00805754 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805754:	55                   	push   %ebp
  805755:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805757:	8b 55 0c             	mov    0xc(%ebp),%edx
  80575a:	8b 45 08             	mov    0x8(%ebp),%eax
  80575d:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805763:	5d                   	pop    %ebp
  805764:	c3                   	ret    

00805765 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805765:	55                   	push   %ebp
  805766:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805768:	8b 55 0c             	mov    0xc(%ebp),%edx
  80576b:	8b 45 08             	mov    0x8(%ebp),%eax
  80576e:	89 50 20             	mov    %edx,0x20(%eax)
}
  805771:	5d                   	pop    %ebp
  805772:	c3                   	ret    

00805773 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805773:	55                   	push   %ebp
  805774:	89 e5                	mov    %esp,%ebp
  805776:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805779:	8b 55 0c             	mov    0xc(%ebp),%edx
  80577c:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805782:	8b 55 10             	mov    0x10(%ebp),%edx
  805785:	88 50 31             	mov    %dl,0x31(%eax)
}
  805788:	5d                   	pop    %ebp
  805789:	c3                   	ret    

0080578a <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  80578a:	55                   	push   %ebp
  80578b:	89 e5                	mov    %esp,%ebp
  80578d:	53                   	push   %ebx
  80578e:	83 ec 04             	sub    $0x4,%esp
  805791:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805794:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  805797:	83 f8 0a             	cmp    $0xa,%eax
  80579a:	74 64                	je     805800 <tcp_pcb_purge+0x76>
  80579c:	83 f8 01             	cmp    $0x1,%eax
  80579f:	76 5f                	jbe    805800 <tcp_pcb_purge+0x76>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  8057a1:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8057a7:	85 c0                	test   %eax,%eax
  8057a9:	74 16                	je     8057c1 <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  8057ab:	83 ec 0c             	sub    $0xc,%esp
  8057ae:	50                   	push   %eax
  8057af:	e8 70 ef ff ff       	call   804724 <pbuf_free>
      pcb->refused_data = NULL;
  8057b4:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8057bb:	00 00 00 
  8057be:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  8057c1:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  8057c7:	83 ec 0c             	sub    $0xc,%esp
  8057ca:	ff 73 7c             	pushl  0x7c(%ebx)
  8057cd:	e8 dc fe ff ff       	call   8056ae <tcp_segs_free>
    pcb->ooseq = NULL;
  8057d2:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  8057d9:	83 c4 04             	add    $0x4,%esp
  8057dc:	ff 73 74             	pushl  0x74(%ebx)
  8057df:	e8 ca fe ff ff       	call   8056ae <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  8057e4:	83 c4 04             	add    $0x4,%esp
  8057e7:	ff 73 78             	pushl  0x78(%ebx)
  8057ea:	e8 bf fe ff ff       	call   8056ae <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  8057ef:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  8057f6:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  8057fd:	83 c4 10             	add    $0x10,%esp
  }
}
  805800:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805803:	c9                   	leave  
  805804:	c3                   	ret    

00805805 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805805:	55                   	push   %ebp
  805806:	89 e5                	mov    %esp,%ebp
  805808:	57                   	push   %edi
  805809:	56                   	push   %esi
  80580a:	53                   	push   %ebx
  80580b:	83 ec 1c             	sub    $0x1c,%esp
  80580e:	8b 45 08             	mov    0x8(%ebp),%eax
  805811:	8b 7d 0c             	mov    0xc(%ebp),%edi
  805814:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  TCP_RMV(pcblist, pcb);
  805817:	8b 10                	mov    (%eax),%edx
  805819:	39 fa                	cmp    %edi,%edx
  80581b:	75 07                	jne    805824 <tcp_pcb_remove+0x1f>
  80581d:	8b 52 0c             	mov    0xc(%edx),%edx
  805820:	89 10                	mov    %edx,(%eax)
  805822:	eb 55                	jmp    805879 <tcp_pcb_remove+0x74>
  805824:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80582a:	bf 00 00 00 00       	mov    $0x0,%edi
  80582f:	eb 34                	jmp    805865 <tcp_pcb_remove+0x60>
  805831:	8b 42 0c             	mov    0xc(%edx),%eax
  805834:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  805837:	0f 94 c1             	sete   %cl
  80583a:	89 ce                	mov    %ecx,%esi
  80583c:	85 c0                	test   %eax,%eax
  80583e:	0f 95 c1             	setne  %cl
  805841:	89 f3                	mov    %esi,%ebx
  805843:	84 cb                	test   %cl,%bl
  805845:	74 17                	je     80585e <tcp_pcb_remove+0x59>
  805847:	89 f8                	mov    %edi,%eax
  805849:	84 c0                	test   %al,%al
  80584b:	74 06                	je     805853 <tcp_pcb_remove+0x4e>
  80584d:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805853:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805856:	8b 40 0c             	mov    0xc(%eax),%eax
  805859:	89 42 0c             	mov    %eax,0xc(%edx)
  80585c:	eb 1b                	jmp    805879 <tcp_pcb_remove+0x74>
  80585e:	bf 01 00 00 00       	mov    $0x1,%edi
  805863:	89 c2                	mov    %eax,%edx
  805865:	85 d2                	test   %edx,%edx
  805867:	75 c8                	jne    805831 <tcp_pcb_remove+0x2c>
  805869:	89 f8                	mov    %edi,%eax
  80586b:	84 c0                	test   %al,%al
  80586d:	74 0a                	je     805879 <tcp_pcb_remove+0x74>
  80586f:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805876:	00 00 00 
  805879:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80587c:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)

  tcp_pcb_purge(pcb);
  805883:	83 ec 0c             	sub    $0xc,%esp
  805886:	57                   	push   %edi
  805887:	e8 fe fe ff ff       	call   80578a <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  80588c:	8b 47 10             	mov    0x10(%edi),%eax
  80588f:	83 c4 10             	add    $0x10,%esp
  805892:	83 f8 0a             	cmp    $0xa,%eax
  805895:	74 22                	je     8058b9 <tcp_pcb_remove+0xb4>
  805897:	83 f8 01             	cmp    $0x1,%eax
  80589a:	74 1d                	je     8058b9 <tcp_pcb_remove+0xb4>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  80589c:	0f b6 47 20          	movzbl 0x20(%edi),%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  8058a0:	a8 01                	test   $0x1,%al
  8058a2:	74 15                	je     8058b9 <tcp_pcb_remove+0xb4>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  8058a4:	83 c8 02             	or     $0x2,%eax
  8058a7:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8058aa:	88 46 20             	mov    %al,0x20(%esi)
    tcp_output(pcb);
  8058ad:	83 ec 0c             	sub    $0xc,%esp
  8058b0:	56                   	push   %esi
  8058b1:	e8 43 26 00 00       	call   807ef9 <tcp_output>
  8058b6:	83 c4 10             	add    $0x10,%esp
  }

  if (pcb->state != LISTEN) {
  8058b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8058bc:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  8058c0:	74 5d                	je     80591f <tcp_pcb_remove+0x11a>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  8058c2:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
  8058c6:	74 17                	je     8058df <tcp_pcb_remove+0xda>
  8058c8:	83 ec 04             	sub    $0x4,%esp
  8058cb:	68 7e 1b 81 00       	push   $0x811b7e
  8058d0:	68 b4 04 00 00       	push   $0x4b4
  8058d5:	68 6a 1b 81 00       	push   $0x811b6a
  8058da:	e8 79 8a 00 00       	call   80e358 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  8058df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8058e2:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  8058e6:	74 17                	je     8058ff <tcp_pcb_remove+0xfa>
  8058e8:	83 ec 04             	sub    $0x4,%esp
  8058eb:	68 96 1b 81 00       	push   $0x811b96
  8058f0:	68 b5 04 00 00       	push   $0x4b5
  8058f5:	68 6a 1b 81 00       	push   $0x811b6a
  8058fa:	e8 59 8a 00 00       	call   80e358 <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  8058ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805902:	83 78 7c 00          	cmpl   $0x0,0x7c(%eax)
  805906:	74 17                	je     80591f <tcp_pcb_remove+0x11a>
  805908:	83 ec 04             	sub    $0x4,%esp
  80590b:	68 af 1b 81 00       	push   $0x811baf
  805910:	68 b7 04 00 00       	push   $0x4b7
  805915:	68 6a 1b 81 00       	push   $0x811b6a
  80591a:	e8 39 8a 00 00       	call   80e358 <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  80591f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805922:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805929:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80592c:	5b                   	pop    %ebx
  80592d:	5e                   	pop    %esi
  80592e:	5f                   	pop    %edi
  80592f:	5d                   	pop    %ebp
  805930:	c3                   	ret    

00805931 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  805931:	55                   	push   %ebp
  805932:	89 e5                	mov    %esp,%ebp
  805934:	57                   	push   %edi
  805935:	56                   	push   %esi
  805936:	53                   	push   %ebx
  805937:	83 ec 1c             	sub    $0x1c,%esp
  80593a:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  80593d:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  805941:	0f 87 37 01 00 00    	ja     805a7e <tcp_close+0x14d>
  805947:	8b 43 10             	mov    0x10(%ebx),%eax
  80594a:	ff 24 85 c8 1b 81 00 	jmp    *0x811bc8(,%eax,4)
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805951:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  805956:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  805959:	39 c3                	cmp    %eax,%ebx
  80595b:	75 0a                	jne    805967 <tcp_close+0x36>
  80595d:	8b 43 0c             	mov    0xc(%ebx),%eax
  805960:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805965:	eb 5e                	jmp    8059c5 <tcp_close+0x94>
  805967:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80596a:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80596f:	bf 00 00 00 00       	mov    $0x0,%edi
  805974:	eb 39                	jmp    8059af <tcp_close+0x7e>
  805976:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805979:	8b 40 0c             	mov    0xc(%eax),%eax
  80597c:	39 c3                	cmp    %eax,%ebx
  80597e:	0f 94 c1             	sete   %cl
  805981:	89 ce                	mov    %ecx,%esi
  805983:	85 c0                	test   %eax,%eax
  805985:	0f 95 c1             	setne  %cl
  805988:	89 f2                	mov    %esi,%edx
  80598a:	84 ca                	test   %cl,%dl
  80598c:	74 19                	je     8059a7 <tcp_close+0x76>
  80598e:	89 f8                	mov    %edi,%eax
  805990:	84 c0                	test   %al,%al
  805992:	74 08                	je     80599c <tcp_close+0x6b>
  805994:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805997:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80599c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80599f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8059a2:	89 47 0c             	mov    %eax,0xc(%edi)
  8059a5:	eb 1e                	jmp    8059c5 <tcp_close+0x94>
  8059a7:	bf 01 00 00 00       	mov    $0x1,%edi
  8059ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8059af:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  8059b3:	75 c1                	jne    805976 <tcp_close+0x45>
  8059b5:	89 f8                	mov    %edi,%eax
  8059b7:	84 c0                	test   %al,%al
  8059b9:	74 0a                	je     8059c5 <tcp_close+0x94>
  8059bb:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  8059c2:	00 00 00 
  8059c5:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  8059cc:	83 ec 08             	sub    $0x8,%esp
  8059cf:	53                   	push   %ebx
  8059d0:	6a 02                	push   $0x2
  8059d2:	e8 da e9 ff ff       	call   8043b1 <memp_free>
    pcb = NULL;
    break;
  8059d7:	83 c4 10             	add    $0x10,%esp
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  8059da:	b8 00 00 00 00       	mov    $0x0,%eax
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  8059df:	e9 bb 00 00 00       	jmp    805a9f <tcp_close+0x16e>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  8059e4:	83 ec 08             	sub    $0x8,%esp
  8059e7:	53                   	push   %ebx
  8059e8:	68 44 b2 b3 00       	push   $0xb3b244
  8059ed:	e8 13 fe ff ff       	call   805805 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  8059f2:	83 c4 08             	add    $0x8,%esp
  8059f5:	53                   	push   %ebx
  8059f6:	6a 03                	push   $0x3
  8059f8:	e8 b4 e9 ff ff       	call   8043b1 <memp_free>
    pcb = NULL;
    break;
  8059fd:	83 c4 10             	add    $0x10,%esp
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
  805a00:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  805a05:	e9 95 00 00 00       	jmp    805a9f <tcp_close+0x16e>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805a0a:	83 ec 08             	sub    $0x8,%esp
  805a0d:	53                   	push   %ebx
  805a0e:	68 3c b2 b3 00       	push   $0xb3b23c
  805a13:	e8 ed fd ff ff       	call   805805 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805a18:	83 c4 08             	add    $0x8,%esp
  805a1b:	53                   	push   %ebx
  805a1c:	6a 02                	push   $0x2
  805a1e:	e8 8e e9 ff ff       	call   8043b1 <memp_free>
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  805a23:	83 c4 10             	add    $0x10,%esp
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
  805a26:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  805a2b:	eb 72                	jmp    805a9f <tcp_close+0x16e>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805a2d:	83 ec 08             	sub    $0x8,%esp
  805a30:	6a 01                	push   $0x1
  805a32:	53                   	push   %ebx
  805a33:	e8 4f 24 00 00       	call   807e87 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805a38:	83 c4 10             	add    $0x10,%esp
  805a3b:	84 c0                	test   %al,%al
  805a3d:	75 60                	jne    805a9f <tcp_close+0x16e>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  805a3f:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805a46:	eb 3b                	jmp    805a83 <tcp_close+0x152>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805a48:	83 ec 08             	sub    $0x8,%esp
  805a4b:	6a 01                	push   $0x1
  805a4d:	53                   	push   %ebx
  805a4e:	e8 34 24 00 00       	call   807e87 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805a53:	83 c4 10             	add    $0x10,%esp
  805a56:	84 c0                	test   %al,%al
  805a58:	75 45                	jne    805a9f <tcp_close+0x16e>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  805a5a:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805a61:	eb 20                	jmp    805a83 <tcp_close+0x152>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805a63:	83 ec 08             	sub    $0x8,%esp
  805a66:	6a 01                	push   $0x1
  805a68:	53                   	push   %ebx
  805a69:	e8 19 24 00 00       	call   807e87 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805a6e:	83 c4 10             	add    $0x10,%esp
  805a71:	84 c0                	test   %al,%al
  805a73:	75 2a                	jne    805a9f <tcp_close+0x16e>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  805a75:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805a7c:	eb 05                	jmp    805a83 <tcp_close+0x152>
    }
    break;
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
    pcb = NULL;
  805a7e:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  805a83:	85 db                	test   %ebx,%ebx
  805a85:	74 13                	je     805a9a <tcp_close+0x169>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  805a87:	83 ec 0c             	sub    $0xc,%esp
  805a8a:	53                   	push   %ebx
  805a8b:	e8 69 24 00 00       	call   807ef9 <tcp_output>
  805a90:	83 c4 10             	add    $0x10,%esp
  805a93:	b8 00 00 00 00       	mov    $0x0,%eax
  805a98:	eb 05                	jmp    805a9f <tcp_close+0x16e>
  805a9a:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  805a9f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805aa2:	5b                   	pop    %ebx
  805aa3:	5e                   	pop    %esi
  805aa4:	5f                   	pop    %edi
  805aa5:	5d                   	pop    %ebp
  805aa6:	c3                   	ret    

00805aa7 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  805aa7:	55                   	push   %ebp
  805aa8:	89 e5                	mov    %esp,%ebp
  805aaa:	83 ec 08             	sub    $0x8,%esp
  805aad:	8b 45 10             	mov    0x10(%ebp),%eax
  805ab0:	8b 55 14             	mov    0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  805ab3:	85 c0                	test   %eax,%eax
  805ab5:	74 13                	je     805aca <tcp_recv_null+0x23>
    pbuf_free(p);
  805ab7:	83 ec 0c             	sub    $0xc,%esp
  805aba:	50                   	push   %eax
  805abb:	e8 64 ec ff ff       	call   804724 <pbuf_free>
  805ac0:	83 c4 10             	add    $0x10,%esp
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
  805ac3:	b8 00 00 00 00       	mov    $0x0,%eax
  805ac8:	eb 17                	jmp    805ae1 <tcp_recv_null+0x3a>
  805aca:	b8 00 00 00 00       	mov    $0x0,%eax
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  arg = arg;
  if (p != NULL) {
    pbuf_free(p);
  } else if (err == ERR_OK) {
  805acf:	84 d2                	test   %dl,%dl
  805ad1:	75 0e                	jne    805ae1 <tcp_recv_null+0x3a>
    return tcp_close(pcb);
  805ad3:	83 ec 0c             	sub    $0xc,%esp
  805ad6:	ff 75 0c             	pushl  0xc(%ebp)
  805ad9:	e8 53 fe ff ff       	call   805931 <tcp_close>
  805ade:	83 c4 10             	add    $0x10,%esp
  }
  return ERR_OK;
}
  805ae1:	c9                   	leave  
  805ae2:	c3                   	ret    

00805ae3 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  805ae3:	55                   	push   %ebp
  805ae4:	89 e5                	mov    %esp,%ebp
  805ae6:	57                   	push   %edi
  805ae7:	56                   	push   %esi
  805ae8:	53                   	push   %ebx
  805ae9:	83 ec 2c             	sub    $0x2c,%esp
  805aec:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  805aef:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805af3:	75 21                	jne    805b16 <tcp_abort+0x33>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805af5:	83 ec 08             	sub    $0x8,%esp
  805af8:	53                   	push   %ebx
  805af9:	68 50 b2 b3 00       	push   $0xb3b250
  805afe:	e8 02 fd ff ff       	call   805805 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805b03:	83 c4 08             	add    $0x8,%esp
  805b06:	53                   	push   %ebx
  805b07:	6a 02                	push   $0x2
  805b09:	e8 a3 e8 ff ff       	call   8043b1 <memp_free>
  805b0e:	83 c4 10             	add    $0x10,%esp
  805b11:	e9 d1 00 00 00       	jmp    805be7 <tcp_abort+0x104>
  } else {
    seqno = pcb->snd_nxt;
  805b16:	8b 43 54             	mov    0x54(%ebx),%eax
  805b19:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805b1c:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805b1f:	85 db                	test   %ebx,%ebx
  805b21:	74 04                	je     805b27 <tcp_abort+0x44>
  805b23:	8b 03                	mov    (%ebx),%eax
  805b25:	eb 05                	jmp    805b2c <tcp_abort+0x49>
  805b27:	b8 00 00 00 00       	mov    $0x0,%eax
  805b2c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805b2f:	83 fb fc             	cmp    $0xfffffffc,%ebx
  805b32:	74 05                	je     805b39 <tcp_abort+0x56>
  805b34:	8b 43 04             	mov    0x4(%ebx),%eax
  805b37:	eb 05                	jmp    805b3e <tcp_abort+0x5b>
  805b39:	b8 00 00 00 00       	mov    $0x0,%eax
  805b3e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805b41:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805b45:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805b49:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805b4d:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  805b51:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  805b57:	8b 43 18             	mov    0x18(%ebx),%eax
  805b5a:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805b5d:	83 ec 08             	sub    $0x8,%esp
  805b60:	53                   	push   %ebx
  805b61:	68 3c b2 b3 00       	push   $0xb3b23c
  805b66:	e8 9a fc ff ff       	call   805805 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805b6b:	8b 43 78             	mov    0x78(%ebx),%eax
  805b6e:	83 c4 10             	add    $0x10,%esp
  805b71:	85 c0                	test   %eax,%eax
  805b73:	74 0c                	je     805b81 <tcp_abort+0x9e>
      tcp_segs_free(pcb->unacked);
  805b75:	83 ec 0c             	sub    $0xc,%esp
  805b78:	50                   	push   %eax
  805b79:	e8 30 fb ff ff       	call   8056ae <tcp_segs_free>
  805b7e:	83 c4 10             	add    $0x10,%esp
    }
    if (pcb->unsent != NULL) {
  805b81:	8b 43 74             	mov    0x74(%ebx),%eax
  805b84:	85 c0                	test   %eax,%eax
  805b86:	74 0c                	je     805b94 <tcp_abort+0xb1>
      tcp_segs_free(pcb->unsent);
  805b88:	83 ec 0c             	sub    $0xc,%esp
  805b8b:	50                   	push   %eax
  805b8c:	e8 1d fb ff ff       	call   8056ae <tcp_segs_free>
  805b91:	83 c4 10             	add    $0x10,%esp
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  805b94:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805b97:	85 c0                	test   %eax,%eax
  805b99:	74 0c                	je     805ba7 <tcp_abort+0xc4>
      tcp_segs_free(pcb->ooseq);
  805b9b:	83 ec 0c             	sub    $0xc,%esp
  805b9e:	50                   	push   %eax
  805b9f:	e8 0a fb ff ff       	call   8056ae <tcp_segs_free>
  805ba4:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  805ba7:	83 ec 08             	sub    $0x8,%esp
  805baa:	53                   	push   %ebx
  805bab:	6a 02                	push   $0x2
  805bad:	e8 ff e7 ff ff       	call   8043b1 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805bb2:	83 c4 10             	add    $0x10,%esp
  805bb5:	85 f6                	test   %esi,%esi
  805bb7:	74 0d                	je     805bc6 <tcp_abort+0xe3>
  805bb9:	83 ec 08             	sub    $0x8,%esp
  805bbc:	6a fb                	push   $0xfffffffb
  805bbe:	ff 75 cc             	pushl  -0x34(%ebp)
  805bc1:	ff d6                	call   *%esi
  805bc3:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805bc6:	83 ec 08             	sub    $0x8,%esp
  805bc9:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805bcd:	50                   	push   %eax
  805bce:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805bd2:	50                   	push   %eax
  805bd3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805bd6:	50                   	push   %eax
  805bd7:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805bda:	50                   	push   %eax
  805bdb:	57                   	push   %edi
  805bdc:	ff 75 d4             	pushl  -0x2c(%ebp)
  805bdf:	e8 8c 27 00 00       	call   808370 <tcp_rst>
  805be4:	83 c4 20             	add    $0x20,%esp
  }
}
  805be7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805bea:	5b                   	pop    %ebx
  805beb:	5e                   	pop    %esi
  805bec:	5f                   	pop    %edi
  805bed:	5d                   	pop    %ebp
  805bee:	c3                   	ret    

00805bef <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  805bef:	55                   	push   %ebp
  805bf0:	89 e5                	mov    %esp,%ebp
  805bf2:	57                   	push   %edi
  805bf3:	56                   	push   %esi
  805bf4:	53                   	push   %ebx
  805bf5:	83 ec 1c             	sub    $0x1c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  805bf8:	83 05 40 b2 b3 00 01 	addl   $0x1,0xb3b240

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  805bff:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  805c05:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)

  ++tcp_ticks;

  /* Steps through all of the active PCBs. */
  prev = NULL;
  805c09:	bf 00 00 00 00       	mov    $0x0,%edi
  805c0e:	e9 53 03 00 00       	jmp    805f66 <tcp_slowtmr+0x377>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805c13:	8b 43 10             	mov    0x10(%ebx),%eax
  805c16:	85 c0                	test   %eax,%eax
  805c18:	75 17                	jne    805c31 <tcp_slowtmr+0x42>
  805c1a:	83 ec 04             	sub    $0x4,%esp
  805c1d:	68 d8 19 81 00       	push   $0x8119d8
  805c22:	68 36 02 00 00       	push   $0x236
  805c27:	68 6a 1b 81 00       	push   $0x811b6a
  805c2c:	e8 27 87 00 00       	call   80e358 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805c31:	83 f8 01             	cmp    $0x1,%eax
  805c34:	75 17                	jne    805c4d <tcp_slowtmr+0x5e>
  805c36:	83 ec 04             	sub    $0x4,%esp
  805c39:	68 04 1a 81 00       	push   $0x811a04
  805c3e:	68 37 02 00 00       	push   $0x237
  805c43:	68 6a 1b 81 00       	push   $0x811b6a
  805c48:	e8 0b 87 00 00       	call   80e358 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805c4d:	83 f8 0a             	cmp    $0xa,%eax
  805c50:	75 17                	jne    805c69 <tcp_slowtmr+0x7a>
  805c52:	83 ec 04             	sub    $0x4,%esp
  805c55:	68 30 1a 81 00       	push   $0x811a30
  805c5a:	68 38 02 00 00       	push   $0x238
  805c5f:	68 6a 1b 81 00       	push   $0x811b6a
  805c64:	e8 ef 86 00 00       	call   80e358 <_panic>

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805c69:	83 f8 02             	cmp    $0x2,%eax
  805c6c:	75 12                	jne    805c80 <tcp_slowtmr+0x91>
  805c6e:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805c72:	80 fa 06             	cmp    $0x6,%dl
  805c75:	0f 85 ac 03 00 00    	jne    806027 <tcp_slowtmr+0x438>
  805c7b:	e9 a0 01 00 00       	jmp    805e20 <tcp_slowtmr+0x231>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805c80:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  805c84:	be 01 00 00 00       	mov    $0x1,%esi

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805c89:	80 fa 0c             	cmp    $0xc,%dl
  805c8c:	0f 84 ee 00 00 00    	je     805d80 <tcp_slowtmr+0x191>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  805c92:	0f b6 8b a4 00 00 00 	movzbl 0xa4(%ebx),%ecx
  805c99:	84 c9                	test   %cl,%cl
  805c9b:	74 54                	je     805cf1 <tcp_slowtmr+0x102>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  805c9d:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  805ca3:	83 c0 01             	add    $0x1,%eax
  805ca6:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805cac:	0f b6 d1             	movzbl %cl,%edx
  805caf:	0f b6 92 e7 1b 81 00 	movzbl 0x811be7(%edx),%edx
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805cb6:	be 00 00 00 00       	mov    $0x0,%esi
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805cbb:	39 d0                	cmp    %edx,%eax
  805cbd:	0f 82 bd 00 00 00    	jb     805d80 <tcp_slowtmr+0x191>
          pcb->persist_cnt = 0;
  805cc3:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  805cca:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  805ccd:	80 f9 06             	cmp    $0x6,%cl
  805cd0:	77 09                	ja     805cdb <tcp_slowtmr+0xec>
            pcb->persist_backoff++;
  805cd2:	83 c1 01             	add    $0x1,%ecx
  805cd5:	88 8b a4 00 00 00    	mov    %cl,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  805cdb:	83 ec 0c             	sub    $0xc,%esp
  805cde:	53                   	push   %ebx
  805cdf:	e8 79 29 00 00       	call   80865d <tcp_zero_window_probe>
  805ce4:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805ce7:	be 00 00 00 00       	mov    $0x0,%esi
  805cec:	e9 8f 00 00 00       	jmp    805d80 <tcp_slowtmr+0x191>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  805cf1:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805cf5:	66 85 c9             	test   %cx,%cx
  805cf8:	78 07                	js     805d01 <tcp_slowtmr+0x112>
          ++pcb->rtime;
  805cfa:	83 c1 01             	add    $0x1,%ecx
  805cfd:	66 89 4b 32          	mov    %cx,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805d01:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805d05:	74 74                	je     805d7b <tcp_slowtmr+0x18c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805d07:	be 00 00 00 00       	mov    $0x0,%esi
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
          ++pcb->rtime;

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805d0c:	0f b7 4b 44          	movzwl 0x44(%ebx),%ecx
  805d10:	66 39 4b 32          	cmp    %cx,0x32(%ebx)
  805d14:	7c 6a                	jl     805d80 <tcp_slowtmr+0x191>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  805d16:	83 f8 02             	cmp    $0x2,%eax
  805d19:	74 1f                	je     805d3a <tcp_slowtmr+0x14b>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805d1b:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805d1f:	66 c1 f8 03          	sar    $0x3,%ax
  805d23:	98                   	cwtl   
  805d24:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805d28:	01 c8                	add    %ecx,%eax
  805d2a:	0f b6 d2             	movzbl %dl,%edx
  805d2d:	0f b6 8a f0 1b 81 00 	movzbl 0x811bf0(%edx),%ecx
  805d34:	d3 e0                	shl    %cl,%eax
  805d36:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  805d3a:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  805d40:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  805d44:	66 39 43 5c          	cmp    %ax,0x5c(%ebx)
  805d48:	66 0f 46 43 5c       	cmovbe 0x5c(%ebx),%ax
  805d4d:	66 d1 e8             	shr    %ax
  805d50:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  805d54:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  805d58:	66 39 d0             	cmp    %dx,%ax
  805d5b:	73 07                	jae    805d64 <tcp_slowtmr+0x175>
            pcb->ssthresh = pcb->mss * 2;
  805d5d:	8d 04 12             	lea    (%edx,%edx,1),%eax
  805d60:	66 89 43 50          	mov    %ax,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  805d64:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  805d68:	83 ec 0c             	sub    $0xc,%esp
  805d6b:	53                   	push   %ebx
  805d6c:	e8 24 27 00 00       	call   808495 <tcp_rexmit_rto>
  805d71:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  805d74:	be 00 00 00 00       	mov    $0x0,%esi
  805d79:	eb 05                	jmp    805d80 <tcp_slowtmr+0x191>
  805d7b:	be 00 00 00 00       	mov    $0x0,%esi
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  805d80:	8b 43 10             	mov    0x10(%ebx),%eax
  805d83:	83 f8 06             	cmp    $0x6,%eax
  805d86:	75 21                	jne    805da9 <tcp_slowtmr+0x1ba>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805d88:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805d8d:	2b 43 2c             	sub    0x2c(%ebx),%eax
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  805d90:	83 f8 29             	cmp    $0x29,%eax
  805d93:	89 f0                	mov    %esi,%eax
  805d95:	1c ff                	sbb    $0xff,%al
  805d97:	89 c6                	mov    %eax,%esi

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  805d99:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805d9c:	85 c9                	test   %ecx,%ecx
  805d9e:	0f 85 8f 00 00 00    	jne    805e33 <tcp_slowtmr+0x244>
  805da4:	e9 e6 00 00 00       	jmp    805e8f <tcp_slowtmr+0x2a0>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  805da9:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  805dad:	74 7d                	je     805e2c <tcp_slowtmr+0x23d>
  805daf:	83 f8 04             	cmp    $0x4,%eax
  805db2:	74 05                	je     805db9 <tcp_slowtmr+0x1ca>
  805db4:	83 f8 07             	cmp    $0x7,%eax
  805db7:	75 73                	jne    805e2c <tcp_slowtmr+0x23d>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805db9:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805dbe:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805dc1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  805dc4:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805dca:	8d 91 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%edx
  805dd0:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805dd5:	f7 e2                	mul    %edx
  805dd7:	c1 ea 05             	shr    $0x5,%edx
  805dda:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805ddd:	76 0e                	jbe    805ded <tcp_slowtmr+0x1fe>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  805ddf:	83 ec 0c             	sub    $0xc,%esp
  805de2:	53                   	push   %ebx
  805de3:	e8 fb fc ff ff       	call   805ae3 <tcp_abort>
  805de8:	83 c4 10             	add    $0x10,%esp
  805deb:	eb 3f                	jmp    805e2c <tcp_slowtmr+0x23d>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  805ded:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  805df4:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  805dfa:	01 ca                	add    %ecx,%edx
  805dfc:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805e01:	f7 e2                	mul    %edx
  805e03:	c1 ea 05             	shr    $0x5,%edx
  805e06:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  805e09:	76 21                	jbe    805e2c <tcp_slowtmr+0x23d>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  805e0b:	83 ec 0c             	sub    $0xc,%esp
  805e0e:	53                   	push   %ebx
  805e0f:	e8 27 27 00 00       	call   80853b <tcp_keepalive>
        pcb->keep_cnt_sent++;
  805e14:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  805e1b:	83 c4 10             	add    $0x10,%esp
  805e1e:	eb 0c                	jmp    805e2c <tcp_slowtmr+0x23d>
  805e20:	be 01 00 00 00       	mov    $0x1,%esi
  805e25:	eb 05                	jmp    805e2c <tcp_slowtmr+0x23d>

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  805e27:	be 01 00 00 00       	mov    $0x1,%esi

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  805e2c:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805e2f:	85 c9                	test   %ecx,%ecx
  805e31:	74 29                	je     805e5c <tcp_slowtmr+0x26d>
  805e33:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  805e39:	2b 53 2c             	sub    0x2c(%ebx),%edx
  805e3c:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  805e40:	8d 04 40             	lea    (%eax,%eax,2),%eax
  805e43:	01 c0                	add    %eax,%eax
  805e45:	39 c2                	cmp    %eax,%edx
  805e47:	72 13                	jb     805e5c <tcp_slowtmr+0x26d>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  805e49:	83 ec 0c             	sub    $0xc,%esp
  805e4c:	51                   	push   %ecx
  805e4d:	e8 5c f8 ff ff       	call   8056ae <tcp_segs_free>
      pcb->ooseq = NULL;
  805e52:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  805e59:	83 c4 10             	add    $0x10,%esp
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  805e5c:	8b 43 10             	mov    0x10(%ebx),%eax
  805e5f:	83 f8 03             	cmp    $0x3,%eax
  805e62:	75 13                	jne    805e77 <tcp_slowtmr+0x288>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805e64:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805e69:	2b 43 2c             	sub    0x2c(%ebx),%eax
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  805e6c:	83 f8 29             	cmp    $0x29,%eax
  805e6f:	89 f0                	mov    %esi,%eax
  805e71:	1c ff                	sbb    $0xff,%al
  805e73:	89 c6                	mov    %eax,%esi
  805e75:	eb 18                	jmp    805e8f <tcp_slowtmr+0x2a0>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  805e77:	83 f8 09             	cmp    $0x9,%eax
  805e7a:	75 13                	jne    805e8f <tcp_slowtmr+0x2a0>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  805e7c:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805e81:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805e84:	3d f1 00 00 00       	cmp    $0xf1,%eax
  805e89:	89 f0                	mov    %esi,%eax
  805e8b:	1c ff                	sbb    $0xff,%al
  805e8d:	89 c6                	mov    %eax,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  805e8f:	89 f0                	mov    %esi,%eax
  805e91:	84 c0                	test   %al,%al
  805e93:	0f 84 8a 00 00 00    	je     805f23 <tcp_slowtmr+0x334>
      tcp_pcb_purge(pcb);      
  805e99:	83 ec 0c             	sub    $0xc,%esp
  805e9c:	53                   	push   %ebx
  805e9d:	e8 e8 f8 ff ff       	call   80578a <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  805ea2:	83 c4 10             	add    $0x10,%esp
  805ea5:	85 ff                	test   %edi,%edi
  805ea7:	74 27                	je     805ed0 <tcp_slowtmr+0x2e1>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805ea9:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805eaf:	75 17                	jne    805ec8 <tcp_slowtmr+0x2d9>
  805eb1:	83 ec 04             	sub    $0x4,%esp
  805eb4:	68 60 1a 81 00       	push   $0x811a60
  805eb9:	68 c1 02 00 00       	push   $0x2c1
  805ebe:	68 6a 1b 81 00       	push   $0x811b6a
  805ec3:	e8 90 84 00 00       	call   80e358 <_panic>
        prev->next = pcb->next;
  805ec8:	8b 43 0c             	mov    0xc(%ebx),%eax
  805ecb:	89 47 0c             	mov    %eax,0xc(%edi)
  805ece:	eb 27                	jmp    805ef7 <tcp_slowtmr+0x308>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  805ed0:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805ed6:	74 17                	je     805eef <tcp_slowtmr+0x300>
  805ed8:	83 ec 04             	sub    $0x4,%esp
  805edb:	68 8c 1a 81 00       	push   $0x811a8c
  805ee0:	68 c5 02 00 00       	push   $0x2c5
  805ee5:	68 6a 1b 81 00       	push   $0x811b6a
  805eea:	e8 69 84 00 00       	call   80e358 <_panic>
        tcp_active_pcbs = pcb->next;
  805eef:	8b 43 0c             	mov    0xc(%ebx),%eax
  805ef2:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  805ef7:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  805efd:	85 c0                	test   %eax,%eax
  805eff:	74 0d                	je     805f0e <tcp_slowtmr+0x31f>
  805f01:	83 ec 08             	sub    $0x8,%esp
  805f04:	6a fb                	push   $0xfffffffb
  805f06:	ff 73 18             	pushl  0x18(%ebx)
  805f09:	ff d0                	call   *%eax
  805f0b:	83 c4 10             	add    $0x10,%esp

      pcb2 = pcb->next;
  805f0e:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  805f11:	83 ec 08             	sub    $0x8,%esp
  805f14:	53                   	push   %ebx
  805f15:	6a 02                	push   $0x2
  805f17:	e8 95 e4 ff ff       	call   8043b1 <memp_free>
  805f1c:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  805f1f:	89 f3                	mov    %esi,%ebx
  805f21:	eb 43                	jmp    805f66 <tcp_slowtmr+0x377>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  805f23:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  805f27:	83 c0 01             	add    $0x1,%eax
  805f2a:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  805f2d:	3a 43 31             	cmp    0x31(%ebx),%al
  805f30:	72 2f                	jb     805f61 <tcp_slowtmr+0x372>
        pcb->polltmr = 0;
  805f32:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  805f36:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  805f3c:	85 c0                	test   %eax,%eax
  805f3e:	74 0f                	je     805f4f <tcp_slowtmr+0x360>
  805f40:	83 ec 08             	sub    $0x8,%esp
  805f43:	53                   	push   %ebx
  805f44:	ff 73 18             	pushl  0x18(%ebx)
  805f47:	ff d0                	call   *%eax
  805f49:	88 45 e3             	mov    %al,-0x1d(%ebp)
  805f4c:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  805f4f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  805f53:	75 0c                	jne    805f61 <tcp_slowtmr+0x372>
          tcp_output(pcb);
  805f55:	83 ec 0c             	sub    $0xc,%esp
  805f58:	53                   	push   %ebx
  805f59:	e8 9b 1f 00 00       	call   807ef9 <tcp_output>
  805f5e:	83 c4 10             	add    $0x10,%esp
        }
      }
      
      prev = pcb;
  805f61:	89 df                	mov    %ebx,%edi
      pcb = pcb->next;
  805f63:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  805f66:	85 db                	test   %ebx,%ebx
  805f68:	0f 85 a5 fc ff ff    	jne    805c13 <tcp_slowtmr+0x24>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  805f6e:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
  while (pcb != NULL) {
  805f74:	e9 a4 00 00 00       	jmp    80601d <tcp_slowtmr+0x42e>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  805f79:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  805f7d:	74 17                	je     805f96 <tcp_slowtmr+0x3a7>
  805f7f:	83 ec 04             	sub    $0x4,%esp
  805f82:	68 b8 1a 81 00       	push   $0x811ab8
  805f87:	68 e5 02 00 00       	push   $0x2e5
  805f8c:	68 6a 1b 81 00       	push   $0x811b6a
  805f91:	e8 c2 83 00 00       	call   80e358 <_panic>
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  805f96:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805f9b:	2b 46 2c             	sub    0x2c(%esi),%eax
  805f9e:	3d f0 00 00 00       	cmp    $0xf0,%eax
  805fa3:	76 73                	jbe    806018 <tcp_slowtmr+0x429>
      tcp_pcb_purge(pcb);      
  805fa5:	83 ec 0c             	sub    $0xc,%esp
  805fa8:	56                   	push   %esi
  805fa9:	e8 dc f7 ff ff       	call   80578a <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  805fae:	83 c4 10             	add    $0x10,%esp
  805fb1:	85 db                	test   %ebx,%ebx
  805fb3:	74 27                	je     805fdc <tcp_slowtmr+0x3ed>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  805fb5:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  805fbb:	75 17                	jne    805fd4 <tcp_slowtmr+0x3e5>
  805fbd:	83 ec 04             	sub    $0x4,%esp
  805fc0:	68 e8 1a 81 00       	push   $0x811ae8
  805fc5:	68 f4 02 00 00       	push   $0x2f4
  805fca:	68 6a 1b 81 00       	push   $0x811b6a
  805fcf:	e8 84 83 00 00       	call   80e358 <_panic>
        prev->next = pcb->next;
  805fd4:	8b 46 0c             	mov    0xc(%esi),%eax
  805fd7:	89 43 0c             	mov    %eax,0xc(%ebx)
  805fda:	eb 27                	jmp    806003 <tcp_slowtmr+0x414>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  805fdc:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  805fe2:	74 17                	je     805ffb <tcp_slowtmr+0x40c>
  805fe4:	83 ec 04             	sub    $0x4,%esp
  805fe7:	68 10 1b 81 00       	push   $0x811b10
  805fec:	68 f8 02 00 00       	push   $0x2f8
  805ff1:	68 6a 1b 81 00       	push   $0x811b6a
  805ff6:	e8 5d 83 00 00       	call   80e358 <_panic>
        tcp_tw_pcbs = pcb->next;
  805ffb:	8b 46 0c             	mov    0xc(%esi),%eax
  805ffe:	a3 50 b2 b3 00       	mov    %eax,0xb3b250
      }
      pcb2 = pcb->next;
  806003:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  806006:	83 ec 08             	sub    $0x8,%esp
  806009:	56                   	push   %esi
  80600a:	6a 02                	push   $0x2
  80600c:	e8 a0 e3 ff ff       	call   8043b1 <memp_free>
  806011:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  806014:	89 fe                	mov    %edi,%esi
  806016:	eb 05                	jmp    80601d <tcp_slowtmr+0x42e>
    } else {
      prev = pcb;
  806018:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  80601a:	8b 76 0c             	mov    0xc(%esi),%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  80601d:	85 f6                	test   %esi,%esi
  80601f:	0f 85 54 ff ff ff    	jne    805f79 <tcp_slowtmr+0x38a>
  806025:	eb 0e                	jmp    806035 <tcp_slowtmr+0x446>

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  806027:	80 fa 0c             	cmp    $0xc,%dl
  80602a:	0f 85 62 fc ff ff    	jne    805c92 <tcp_slowtmr+0xa3>
  806030:	e9 f2 fd ff ff       	jmp    805e27 <tcp_slowtmr+0x238>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  806035:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806038:	5b                   	pop    %ebx
  806039:	5e                   	pop    %esi
  80603a:	5f                   	pop    %edi
  80603b:	5d                   	pop    %ebp
  80603c:	c3                   	ret    

0080603d <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  80603d:	55                   	push   %ebp
  80603e:	89 e5                	mov    %esp,%ebp
  806040:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  806043:	e8 ad f5 ff ff       	call   8055f5 <tcp_fasttmr>

  if (++tcp_timer & 1) {
  806048:	0f b6 05 f9 43 b3 00 	movzbl 0xb343f9,%eax
  80604f:	83 c0 01             	add    $0x1,%eax
  806052:	a2 f9 43 b3 00       	mov    %al,0xb343f9
  806057:	a8 01                	test   $0x1,%al
  806059:	74 05                	je     806060 <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80605b:	e8 8f fb ff ff       	call   805bef <tcp_slowtmr>
  }
}
  806060:	c9                   	leave  
  806061:	c3                   	ret    

00806062 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  806062:	55                   	push   %ebp
  806063:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  806065:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80606a:	03 05 08 40 81 00    	add    0x814008,%eax
  806070:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  806075:	5d                   	pop    %ebp
  806076:	c3                   	ret    

00806077 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  806077:	55                   	push   %ebp
  806078:	89 e5                	mov    %esp,%ebp
  80607a:	57                   	push   %edi
  80607b:	56                   	push   %esi
  80607c:	53                   	push   %ebx
  80607d:	83 ec 28             	sub    $0x28,%esp
  806080:	0f b6 5d 08          	movzbl 0x8(%ebp),%ebx
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  806084:	6a 02                	push   $0x2
  806086:	e8 d0 e2 ff ff       	call   80435b <memp_malloc>
  80608b:	89 c6                	mov    %eax,%esi
  if (pcb == NULL) {
  80608d:	83 c4 10             	add    $0x10,%esp
  806090:	85 c0                	test   %eax,%eax
  806092:	0f 85 bd 00 00 00    	jne    806155 <tcp_alloc+0xde>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  806098:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80609d:	8b 35 40 b2 b3 00    	mov    0xb3b240,%esi
tcp_kill_timewait(void)
{
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  8060a3:	b9 00 00 00 00       	mov    $0x0,%ecx
  inactive = NULL;
  8060a8:	bf 00 00 00 00       	mov    $0x0,%edi
  8060ad:	eb 10                	jmp    8060bf <tcp_alloc+0x48>
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8060af:	89 f2                	mov    %esi,%edx
  8060b1:	2b 50 2c             	sub    0x2c(%eax),%edx
  8060b4:	39 ca                	cmp    %ecx,%edx
  8060b6:	72 04                	jb     8060bc <tcp_alloc+0x45>
      inactivity = tcp_ticks - pcb->tmr;
  8060b8:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  8060ba:	89 c7                	mov    %eax,%edi
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8060bc:	8b 40 0c             	mov    0xc(%eax),%eax
  8060bf:	85 c0                	test   %eax,%eax
  8060c1:	75 ec                	jne    8060af <tcp_alloc+0x38>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  8060c3:	85 ff                	test   %edi,%edi
  8060c5:	74 0c                	je     8060d3 <tcp_alloc+0x5c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8060c7:	83 ec 0c             	sub    $0xc,%esp
  8060ca:	57                   	push   %edi
  8060cb:	e8 13 fa ff ff       	call   805ae3 <tcp_abort>
  8060d0:	83 c4 10             	add    $0x10,%esp
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  8060d3:	83 ec 0c             	sub    $0xc,%esp
  8060d6:	6a 02                	push   $0x2
  8060d8:	e8 7e e2 ff ff       	call   80435b <memp_malloc>
  8060dd:	89 c6                	mov    %eax,%esi
    if (pcb == NULL) {
  8060df:	83 c4 10             	add    $0x10,%esp
  8060e2:	85 c0                	test   %eax,%eax
  8060e4:	75 6f                	jne    806155 <tcp_alloc+0xde>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8060e6:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8060eb:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  8060f1:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  8060f6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  inactive = NULL;
  8060fd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806104:	eb 21                	jmp    806127 <tcp_alloc+0xb0>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  806106:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  80610a:	38 d3                	cmp    %dl,%bl
  80610c:	72 16                	jb     806124 <tcp_alloc+0xad>
  80610e:	38 ca                	cmp    %cl,%dl
  806110:	77 12                	ja     806124 <tcp_alloc+0xad>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806112:	89 fe                	mov    %edi,%esi
  806114:	2b 70 2c             	sub    0x2c(%eax),%esi
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  806117:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  80611a:	72 08                	jb     806124 <tcp_alloc+0xad>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
  80611c:	89 d1                	mov    %edx,%ecx
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  80611e:	89 75 e4             	mov    %esi,-0x1c(%ebp)
      inactive = pcb;
  806121:	89 45 e0             	mov    %eax,-0x20(%ebp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806124:	8b 40 0c             	mov    0xc(%eax),%eax
  806127:	85 c0                	test   %eax,%eax
  806129:	75 db                	jne    806106 <tcp_alloc+0x8f>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  80612b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80612e:	85 c0                	test   %eax,%eax
  806130:	74 0c                	je     80613e <tcp_alloc+0xc7>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  806132:	83 ec 0c             	sub    $0xc,%esp
  806135:	50                   	push   %eax
  806136:	e8 a8 f9 ff ff       	call   805ae3 <tcp_abort>
  80613b:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  80613e:	83 ec 0c             	sub    $0xc,%esp
  806141:	6a 02                	push   $0x2
  806143:	e8 13 e2 ff ff       	call   80435b <memp_malloc>
  806148:	89 c6                	mov    %eax,%esi
    }
  }
  if (pcb != NULL) {
  80614a:	83 c4 10             	add    $0x10,%esp
  80614d:	85 c0                	test   %eax,%eax
  80614f:	0f 84 96 00 00 00    	je     8061eb <tcp_alloc+0x174>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  806155:	83 ec 04             	sub    $0x4,%esp
  806158:	68 a8 00 00 00       	push   $0xa8
  80615d:	6a 00                	push   $0x0
  80615f:	56                   	push   %esi
  806160:	e8 96 89 00 00       	call   80eafb <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  806165:	c6 46 14 40          	movb   $0x40,0x14(%esi)
    pcb->snd_buf = TCP_SND_BUF;
  806169:	66 c7 46 6e 40 5b    	movw   $0x5b40,0x6e(%esi)
    pcb->snd_queuelen = 0;
  80616f:	66 c7 46 70 00 00    	movw   $0x0,0x70(%esi)
    pcb->rcv_wnd = TCP_WND;
  806175:	66 c7 46 28 c0 5d    	movw   $0x5dc0,0x28(%esi)
    pcb->rcv_ann_wnd = TCP_WND;
  80617b:	66 c7 46 2a c0 5d    	movw   $0x5dc0,0x2a(%esi)
    pcb->tos = 0;
  806181:	c6 46 0a 00          	movb   $0x0,0xa(%esi)
    pcb->ttl = TCP_TTL;
  806185:	c6 46 0b ff          	movb   $0xff,0xb(%esi)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  806189:	66 c7 46 34 18 02    	movw   $0x218,0x34(%esi)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  80618f:	66 c7 46 44 06 00    	movw   $0x6,0x44(%esi)
    pcb->sa = 0;
  806195:	66 c7 46 40 00 00    	movw   $0x0,0x40(%esi)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  80619b:	66 c7 46 42 06 00    	movw   $0x6,0x42(%esi)
    pcb->rtime = -1;
  8061a1:	66 c7 46 32 ff ff    	movw   $0xffff,0x32(%esi)
    pcb->cwnd = 1;
  8061a7:	66 c7 46 4e 01 00    	movw   $0x1,0x4e(%esi)
    iss = tcp_next_iss();
  8061ad:	e8 b0 fe ff ff       	call   806062 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  8061b2:	89 46 64             	mov    %eax,0x64(%esi)
    pcb->snd_nxt = iss;
  8061b5:	89 46 54             	mov    %eax,0x54(%esi)
    pcb->snd_max = iss;
  8061b8:	89 46 58             	mov    %eax,0x58(%esi)
    pcb->lastack = iss;
  8061bb:	89 46 48             	mov    %eax,0x48(%esi)
    pcb->snd_lbb = iss;   
  8061be:	89 46 68             	mov    %eax,0x68(%esi)
    pcb->tmr = tcp_ticks;
  8061c1:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8061c6:	89 46 2c             	mov    %eax,0x2c(%esi)

    pcb->polltmr = 0;
  8061c9:	c6 46 30 00          	movb   $0x0,0x30(%esi)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  8061cd:	c7 86 88 00 00 00 a7 	movl   $0x805aa7,0x88(%esi)
  8061d4:	5a 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  8061d7:	c7 86 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%esi)
  8061de:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  8061e1:	c6 86 a5 00 00 00 00 	movb   $0x0,0xa5(%esi)
  8061e8:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  8061eb:	89 f0                	mov    %esi,%eax
  8061ed:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8061f0:	5b                   	pop    %ebx
  8061f1:	5e                   	pop    %esi
  8061f2:	5f                   	pop    %edi
  8061f3:	5d                   	pop    %ebp
  8061f4:	c3                   	ret    

008061f5 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  8061f5:	55                   	push   %ebp
  8061f6:	89 e5                	mov    %esp,%ebp
  8061f8:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  8061fb:	6a 40                	push   $0x40
  8061fd:	e8 75 fe ff ff       	call   806077 <tcp_alloc>
}
  806202:	c9                   	leave  
  806203:	c3                   	ret    

00806204 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  806204:	55                   	push   %ebp
  806205:	89 e5                	mov    %esp,%ebp
  806207:	56                   	push   %esi
  806208:	53                   	push   %ebx
  806209:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80620c:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  80620e:	83 ec 0c             	sub    $0xc,%esp
  806211:	ff 75 0c             	pushl  0xc(%ebp)
  806214:	e8 00 02 00 00       	call   806419 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  806219:	83 c4 10             	add    $0x10,%esp
  80621c:	85 c0                	test   %eax,%eax
  80621e:	74 14                	je     806234 <tcp_eff_send_mss+0x30>
  806220:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806224:	66 85 c0             	test   %ax,%ax
  806227:	74 0b                	je     806234 <tcp_eff_send_mss+0x30>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  806229:	83 e8 28             	sub    $0x28,%eax
  80622c:	66 39 c3             	cmp    %ax,%bx
  80622f:	0f 46 c3             	cmovbe %ebx,%eax
  806232:	89 c6                	mov    %eax,%esi
  }
  return sendmss;
}
  806234:	89 f0                	mov    %esi,%eax
  806236:	8d 65 f8             	lea    -0x8(%ebp),%esp
  806239:	5b                   	pop    %ebx
  80623a:	5e                   	pop    %esi
  80623b:	5d                   	pop    %ebp
  80623c:	c3                   	ret    

0080623d <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  80623d:	55                   	push   %ebp
  80623e:	89 e5                	mov    %esp,%ebp
  806240:	57                   	push   %edi
  806241:	56                   	push   %esi
  806242:	53                   	push   %ebx
  806243:	83 ec 1c             	sub    $0x1c,%esp
  806246:	8b 75 0c             	mov    0xc(%ebp),%esi
  806249:	8b 45 10             	mov    0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80624c:	8b 7d 08             	mov    0x8(%ebp),%edi
  80624f:	83 7f 10 00          	cmpl   $0x0,0x10(%edi)
  806253:	74 17                	je     80626c <tcp_connect+0x2f>
  806255:	83 ec 04             	sub    $0x4,%esp
  806258:	68 38 1b 81 00       	push   $0x811b38
  80625d:	68 ec 01 00 00       	push   $0x1ec
  806262:	68 6a 1b 81 00       	push   $0x811b6a
  806267:	e8 ec 80 00 00       	call   80e358 <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  80626c:	85 f6                	test   %esi,%esi
  80626e:	0f 84 4c 01 00 00    	je     8063c0 <tcp_connect+0x183>
    pcb->remote_ip = *ipaddr;
  806274:	8b 16                	mov    (%esi),%edx
  806276:	8b 7d 08             	mov    0x8(%ebp),%edi
  806279:	89 57 04             	mov    %edx,0x4(%edi)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80627c:	66 89 47 1e          	mov    %ax,0x1e(%edi)
  if (pcb->local_port == 0) {
  806280:	66 83 7f 1c 00       	cmpw   $0x0,0x1c(%edi)
  806285:	75 0c                	jne    806293 <tcp_connect+0x56>
    pcb->local_port = tcp_new_port();
  806287:	e8 ad ef ff ff       	call   805239 <tcp_new_port>
  80628c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80628f:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  806293:	e8 ca fd ff ff       	call   806062 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  806298:	8b 7d 08             	mov    0x8(%ebp),%edi
  80629b:	c7 47 24 00 00 00 00 	movl   $0x0,0x24(%edi)
  pcb->snd_nxt = iss;
  8062a2:	89 47 54             	mov    %eax,0x54(%edi)
  pcb->lastack = iss - 1;
  8062a5:	83 e8 01             	sub    $0x1,%eax
  8062a8:	89 47 48             	mov    %eax,0x48(%edi)
  pcb->snd_lbb = iss - 1;
  8062ab:	89 47 68             	mov    %eax,0x68(%edi)
  pcb->rcv_wnd = TCP_WND;
  8062ae:	66 c7 47 28 c0 5d    	movw   $0x5dc0,0x28(%edi)
  pcb->rcv_ann_wnd = TCP_WND;
  8062b4:	66 c7 47 2a c0 5d    	movw   $0x5dc0,0x2a(%edi)
  pcb->snd_wnd = TCP_WND;
  8062ba:	66 c7 47 5c c0 5d    	movw   $0x5dc0,0x5c(%edi)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8062c0:	66 c7 47 34 18 02    	movw   $0x218,0x34(%edi)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8062c6:	83 ec 08             	sub    $0x8,%esp
  8062c9:	56                   	push   %esi
  8062ca:	68 18 02 00 00       	push   $0x218
  8062cf:	e8 30 ff ff ff       	call   806204 <tcp_eff_send_mss>
  8062d4:	8b 7d 08             	mov    0x8(%ebp),%edi
  8062d7:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  8062db:	66 c7 47 4e 01 00    	movw   $0x1,0x4e(%edi)
  pcb->ssthresh = pcb->mss * 10;
  8062e1:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8062e4:	01 c0                	add    %eax,%eax
  8062e6:	66 89 47 50          	mov    %ax,0x50(%edi)
  pcb->state = SYN_SENT;
  8062ea:	c7 47 10 02 00 00 00 	movl   $0x2,0x10(%edi)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  8062f1:	8b 45 14             	mov    0x14(%ebp),%eax
  8062f4:	89 87 8c 00 00 00    	mov    %eax,0x8c(%edi)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8062fa:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  806300:	83 c4 10             	add    $0x10,%esp
  806303:	39 d7                	cmp    %edx,%edi
  806305:	75 0a                	jne    806311 <tcp_connect+0xd4>
  806307:	8b 47 0c             	mov    0xc(%edi),%eax
  80630a:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  80630f:	eb 55                	jmp    806366 <tcp_connect+0x129>
  806311:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  806317:	bf 00 00 00 00       	mov    $0x0,%edi
  80631c:	eb 34                	jmp    806352 <tcp_connect+0x115>
  80631e:	8b 42 0c             	mov    0xc(%edx),%eax
  806321:	39 45 08             	cmp    %eax,0x8(%ebp)
  806324:	0f 94 c1             	sete   %cl
  806327:	89 ce                	mov    %ecx,%esi
  806329:	85 c0                	test   %eax,%eax
  80632b:	0f 95 c1             	setne  %cl
  80632e:	89 f3                	mov    %esi,%ebx
  806330:	84 cb                	test   %cl,%bl
  806332:	74 17                	je     80634b <tcp_connect+0x10e>
  806334:	89 f8                	mov    %edi,%eax
  806336:	84 c0                	test   %al,%al
  806338:	74 06                	je     806340 <tcp_connect+0x103>
  80633a:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  806340:	8b 45 08             	mov    0x8(%ebp),%eax
  806343:	8b 40 0c             	mov    0xc(%eax),%eax
  806346:	89 42 0c             	mov    %eax,0xc(%edx)
  806349:	eb 1b                	jmp    806366 <tcp_connect+0x129>
  80634b:	bf 01 00 00 00       	mov    $0x1,%edi
  806350:	89 c2                	mov    %eax,%edx
  806352:	85 d2                	test   %edx,%edx
  806354:	75 c8                	jne    80631e <tcp_connect+0xe1>
  806356:	89 f8                	mov    %edi,%eax
  806358:	84 c0                	test   %al,%al
  80635a:	74 0a                	je     806366 <tcp_connect+0x129>
  80635c:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  806363:	00 00 00 
  TCP_REG(&tcp_active_pcbs, pcb);
  806366:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80636b:	8b 7d 08             	mov    0x8(%ebp),%edi
  80636e:	89 47 0c             	mov    %eax,0xc(%edi)
  806371:	89 3d 3c b2 b3 00    	mov    %edi,0xb3b23c
  806377:	e8 e7 bd ff ff       	call   802163 <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  80637c:	83 ec 0c             	sub    $0xc,%esp
  80637f:	68 b4 05 04 02       	push   $0x20405b4
  806384:	e8 66 12 00 00       	call   8075ef <htonl>
  806389:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  80638c:	83 c4 0c             	add    $0xc,%esp
  80638f:	6a 04                	push   $0x4
  806391:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  806394:	50                   	push   %eax
  806395:	6a 00                	push   $0x0
  806397:	6a 02                	push   $0x2
  806399:	6a 00                	push   $0x0
  80639b:	6a 00                	push   $0x0
  80639d:	ff 75 08             	pushl  0x8(%ebp)
  8063a0:	e8 7b 14 00 00       	call   807820 <tcp_enqueue>
  8063a5:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  8063a7:	83 c4 20             	add    $0x20,%esp
  8063aa:	84 c0                	test   %al,%al
  8063ac:	75 17                	jne    8063c5 <tcp_connect+0x188>
    tcp_output(pcb);
  8063ae:	83 ec 0c             	sub    $0xc,%esp
  8063b1:	ff 75 08             	pushl  0x8(%ebp)
  8063b4:	e8 40 1b 00 00       	call   807ef9 <tcp_output>
  8063b9:	83 c4 10             	add    $0x10,%esp
  }
  return ret;
  8063bc:	89 f0                	mov    %esi,%eax
  8063be:	eb 05                	jmp    8063c5 <tcp_connect+0x188>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  8063c0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  if (ret == ERR_OK) { 
    tcp_output(pcb);
  }
  return ret;
} 
  8063c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8063c8:	5b                   	pop    %ebx
  8063c9:	5e                   	pop    %esi
  8063ca:	5f                   	pop    %edi
  8063cb:	5d                   	pop    %ebp
  8063cc:	c3                   	ret    

008063cd <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  8063cd:	55                   	push   %ebp
  8063ce:	89 e5                	mov    %esp,%ebp
  8063d0:	53                   	push   %ebx
  8063d1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  8063d4:	8b 45 08             	mov    0x8(%ebp),%eax
  8063d7:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8063d9:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  8063dc:	b8 01 00 00 00       	mov    $0x1,%eax
{
  u32_t addr2test;

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8063e1:	83 fb fd             	cmp    $0xfffffffd,%ebx
  8063e4:	77 30                	ja     806416 <ip_addr_isbroadcast+0x49>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  8063e6:	0f b6 41 2e          	movzbl 0x2e(%ecx),%eax
  8063ea:	83 e0 02             	and    $0x2,%eax
  8063ed:	74 27                	je     806416 <ip_addr_isbroadcast+0x49>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  8063ef:	8b 41 04             	mov    0x4(%ecx),%eax
  8063f2:	39 c2                	cmp    %eax,%edx
  8063f4:	74 1b                	je     806411 <ip_addr_isbroadcast+0x44>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  8063f6:	8b 59 08             	mov    0x8(%ecx),%ebx
  8063f9:	31 d0                	xor    %edx,%eax
  8063fb:	89 c1                	mov    %eax,%ecx
          && ((addr2test & ~netif->netmask.addr) ==
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
  8063fd:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806402:	85 d9                	test   %ebx,%ecx
  806404:	75 10                	jne    806416 <ip_addr_isbroadcast+0x49>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806406:	f7 d3                	not    %ebx

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  806408:	21 da                	and    %ebx,%edx
  80640a:	39 da                	cmp    %ebx,%edx
  80640c:	0f 94 c0             	sete   %al
  80640f:	eb 05                	jmp    806416 <ip_addr_isbroadcast+0x49>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  806411:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  806416:	5b                   	pop    %ebx
  806417:	5d                   	pop    %ebp
  806418:	c3                   	ret    

00806419 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  806419:	55                   	push   %ebp
  80641a:	89 e5                	mov    %esp,%ebp
  80641c:	56                   	push   %esi
  80641d:	53                   	push   %ebx
  80641e:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806421:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  806427:	eb 1c                	jmp    806445 <ip_route+0x2c>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  806429:	83 ec 0c             	sub    $0xc,%esp
  80642c:	53                   	push   %ebx
  80642d:	e8 11 e2 ff ff       	call   804643 <netif_is_up>
  806432:	83 c4 10             	add    $0x10,%esp
  806435:	84 c0                	test   %al,%al
  806437:	74 0a                	je     806443 <ip_route+0x2a>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  806439:	8b 06                	mov    (%esi),%eax
  80643b:	33 43 04             	xor    0x4(%ebx),%eax
  80643e:	85 43 08             	test   %eax,0x8(%ebx)
  806441:	74 2b                	je     80646e <ip_route+0x55>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806443:	8b 1b                	mov    (%ebx),%ebx
  806445:	85 db                	test   %ebx,%ebx
  806447:	75 e0                	jne    806429 <ip_route+0x10>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  806449:	a1 38 b2 b3 00       	mov    0xb3b238,%eax
  80644e:	85 c0                	test   %eax,%eax
  806450:	74 1e                	je     806470 <ip_route+0x57>
  806452:	83 ec 0c             	sub    $0xc,%esp
  806455:	50                   	push   %eax
  806456:	e8 e8 e1 ff ff       	call   804643 <netif_is_up>
  80645b:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  80645e:	84 c0                	test   %al,%al
  806460:	b8 00 00 00 00       	mov    $0x0,%eax
  806465:	0f 45 05 38 b2 b3 00 	cmovne 0xb3b238,%eax
  80646c:	eb 02                	jmp    806470 <ip_route+0x57>
  80646e:	89 d8                	mov    %ebx,%eax
}
  806470:	8d 65 f8             	lea    -0x8(%ebp),%esp
  806473:	5b                   	pop    %ebx
  806474:	5e                   	pop    %esi
  806475:	5d                   	pop    %ebp
  806476:	c3                   	ret    

00806477 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  806477:	55                   	push   %ebp
  806478:	89 e5                	mov    %esp,%ebp
  80647a:	57                   	push   %edi
  80647b:	56                   	push   %esi
  80647c:	53                   	push   %ebx
  80647d:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806480:	8b 45 08             	mov    0x8(%ebp),%eax
  806483:	8b 70 04             	mov    0x4(%eax),%esi
  if (IPH_V(iphdr) != 4) {
  806486:	0f b7 06             	movzwl (%esi),%eax
  806489:	50                   	push   %eax
  80648a:	e8 53 11 00 00       	call   8075e2 <ntohs>
  80648f:	66 c1 e8 0c          	shr    $0xc,%ax
  806493:	83 c4 10             	add    $0x10,%esp
  806496:	66 83 f8 04          	cmp    $0x4,%ax
  80649a:	74 13                	je     8064af <ip_input+0x38>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  80649c:	83 ec 0c             	sub    $0xc,%esp
  80649f:	ff 75 08             	pushl  0x8(%ebp)
  8064a2:	e8 7d e2 ff ff       	call   804724 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  8064a7:	83 c4 10             	add    $0x10,%esp
  8064aa:	e9 bf 02 00 00       	jmp    80676e <ip_input+0x2f7>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  8064af:	83 ec 0c             	sub    $0xc,%esp
  8064b2:	0f b7 06             	movzwl (%esi),%eax
  8064b5:	50                   	push   %eax
  8064b6:	e8 27 11 00 00       	call   8075e2 <ntohs>
  8064bb:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  8064bf:	83 e0 3c             	and    $0x3c,%eax
  8064c2:	89 c7                	mov    %eax,%edi
  8064c4:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  8064c8:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8064cc:	89 04 24             	mov    %eax,(%esp)
  8064cf:	e8 0e 11 00 00       	call   8075e2 <ntohs>
  8064d4:	89 c3                	mov    %eax,%ebx

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  8064d6:	83 c4 10             	add    $0x10,%esp
  8064d9:	8b 55 08             	mov    0x8(%ebp),%edx
  8064dc:	66 3b 7a 0a          	cmp    0xa(%edx),%di
  8064e0:	77 06                	ja     8064e8 <ip_input+0x71>
  8064e2:	66 3b 5a 08          	cmp    0x8(%edx),%bx
  8064e6:	76 13                	jbe    8064fb <ip_input+0x84>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  8064e8:	83 ec 0c             	sub    $0xc,%esp
  8064eb:	ff 75 08             	pushl  0x8(%ebp)
  8064ee:	e8 31 e2 ff ff       	call   804724 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  8064f3:	83 c4 10             	add    $0x10,%esp
  8064f6:	e9 73 02 00 00       	jmp    80676e <ip_input+0x2f7>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  8064fb:	83 ec 08             	sub    $0x8,%esp
  8064fe:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806502:	50                   	push   %eax
  806503:	56                   	push   %esi
  806504:	e8 a7 0f 00 00       	call   8074b0 <inet_chksum>
  806509:	83 c4 10             	add    $0x10,%esp
  80650c:	66 85 c0             	test   %ax,%ax
  80650f:	74 13                	je     806524 <ip_input+0xad>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  806511:	83 ec 0c             	sub    $0xc,%esp
  806514:	ff 75 08             	pushl  0x8(%ebp)
  806517:	e8 08 e2 ff ff       	call   804724 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  80651c:	83 c4 10             	add    $0x10,%esp
  80651f:	e9 4a 02 00 00       	jmp    80676e <ip_input+0x2f7>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  806524:	83 ec 08             	sub    $0x8,%esp
  806527:	0f b7 db             	movzwl %bx,%ebx
  80652a:	53                   	push   %ebx
  80652b:	ff 75 08             	pushl  0x8(%ebp)
  80652e:	e8 3a e5 ff ff       	call   804a6d <pbuf_realloc>
  806533:	83 c4 10             	add    $0x10,%esp
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    netif = inp;
  806536:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  806539:	bf 01 00 00 00       	mov    $0x1,%edi
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  80653e:	8d 46 10             	lea    0x10(%esi),%eax
  806541:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806544:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  806547:	89 de                	mov    %ebx,%esi
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  806549:	83 ec 0c             	sub    $0xc,%esp
  80654c:	53                   	push   %ebx
  80654d:	e8 f1 e0 ff ff       	call   804643 <netif_is_up>
  806552:	83 c4 10             	add    $0x10,%esp
  806555:	84 c0                	test   %al,%al
  806557:	74 27                	je     806580 <ip_input+0x109>
  806559:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80655c:	74 22                	je     806580 <ip_input+0x109>
  80655e:	8b 43 04             	mov    0x4(%ebx),%eax
  806561:	85 c0                	test   %eax,%eax
  806563:	74 1b                	je     806580 <ip_input+0x109>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806565:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806568:	3b 41 10             	cmp    0x10(%ecx),%eax
  80656b:	74 35                	je     8065a2 <ip_input+0x12b>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  80656d:	83 ec 08             	sub    $0x8,%esp
  806570:	53                   	push   %ebx
  806571:	ff 75 dc             	pushl  -0x24(%ebp)
  806574:	e8 54 fe ff ff       	call   8063cd <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806579:	83 c4 10             	add    $0x10,%esp
  80657c:	84 c0                	test   %al,%al
  80657e:	75 22                	jne    8065a2 <ip_input+0x12b>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  806580:	85 ff                	test   %edi,%edi
  806582:	74 08                	je     80658c <ip_input+0x115>
        first = 0;
        netif = netif_list;
  806584:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  80658a:	eb 02                	jmp    80658e <ip_input+0x117>
      } else {
        netif = netif->next;
  80658c:	8b 1b                	mov    (%ebx),%ebx
      }
      if (netif == inp) {
  80658e:	39 f3                	cmp    %esi,%ebx
  806590:	75 02                	jne    806594 <ip_input+0x11d>
        netif = netif->next;
  806592:	8b 1e                	mov    (%esi),%ebx
  806594:	bf 00 00 00 00       	mov    $0x0,%edi
      }
    } while(netif != NULL);
  806599:	85 db                	test   %ebx,%ebx
  80659b:	75 ac                	jne    806549 <ip_input+0xd2>
  80659d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8065a0:	eb 0b                	jmp    8065ad <ip_input+0x136>
  8065a2:	8b 75 e4             	mov    -0x1c(%ebp),%esi
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  8065a5:	85 db                	test   %ebx,%ebx
  8065a7:	0f 85 a2 01 00 00    	jne    80674f <ip_input+0x2d8>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  8065ad:	83 ec 0c             	sub    $0xc,%esp
  8065b0:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8065b4:	50                   	push   %eax
  8065b5:	e8 28 10 00 00       	call   8075e2 <ntohs>
  8065ba:	83 c4 10             	add    $0x10,%esp
  8065bd:	bb 00 00 00 00       	mov    $0x0,%ebx
  8065c2:	3c 11                	cmp    $0x11,%al
  8065c4:	0f 85 85 01 00 00    	jne    80674f <ip_input+0x2d8>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  8065ca:	83 ec 0c             	sub    $0xc,%esp
  8065cd:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8065d1:	0f b7 44 06 02       	movzwl 0x2(%esi,%eax,1),%eax
  8065d6:	50                   	push   %eax
  8065d7:	e8 06 10 00 00       	call   8075e2 <ntohs>
  8065dc:	83 c4 10             	add    $0x10,%esp
  8065df:	66 83 f8 44          	cmp    $0x44,%ax
  8065e3:	74 3d                	je     806622 <ip_input+0x1ab>
  8065e5:	e9 65 01 00 00       	jmp    80674f <ip_input+0x2d8>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
         (ip_addr_ismulticast(&(iphdr->src)))) {
  8065ea:	8b 7e 0c             	mov    0xc(%esi),%edi
  8065ed:	83 ec 0c             	sub    $0xc,%esp
  8065f0:	68 00 00 00 f0       	push   $0xf0000000
  8065f5:	e8 16 12 00 00       	call   807810 <ntohl>
  8065fa:	21 c7                	and    %eax,%edi
  8065fc:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806603:	e8 08 12 00 00       	call   807810 <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806608:	83 c4 10             	add    $0x10,%esp
  80660b:	39 c7                	cmp    %eax,%edi
  80660d:	75 16                	jne    806625 <ip_input+0x1ae>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  80660f:	83 ec 0c             	sub    $0xc,%esp
  806612:	ff 75 08             	pushl  0x8(%ebp)
  806615:	e8 0a e1 ff ff       	call   804724 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  80661a:	83 c4 10             	add    $0x10,%esp
  80661d:	e9 4c 01 00 00       	jmp    80676e <ip_input+0x2f7>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  806622:	8b 5d 0c             	mov    0xc(%ebp),%ebx
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  806625:	85 db                	test   %ebx,%ebx
  806627:	75 13                	jne    80663c <ip_input+0x1c5>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  806629:	83 ec 0c             	sub    $0xc,%esp
  80662c:	ff 75 08             	pushl  0x8(%ebp)
  80662f:	e8 f0 e0 ff ff       	call   804724 <pbuf_free>
    return ERR_OK;
  806634:	83 c4 10             	add    $0x10,%esp
  806637:	e9 32 01 00 00       	jmp    80676e <ip_input+0x2f7>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  80663c:	0f b7 5e 06          	movzwl 0x6(%esi),%ebx
  806640:	83 ec 0c             	sub    $0xc,%esp
  806643:	68 ff 3f 00 00       	push   $0x3fff
  806648:	e8 88 0f 00 00       	call   8075d5 <htons>
  80664d:	83 c4 10             	add    $0x10,%esp
  806650:	66 85 c3             	test   %ax,%bx
  806653:	74 1c                	je     806671 <ip_input+0x1fa>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  806655:	83 ec 0c             	sub    $0xc,%esp
  806658:	ff 75 08             	pushl  0x8(%ebp)
  80665b:	e8 18 05 00 00       	call   806b78 <ip_reass>
  806660:	89 45 08             	mov    %eax,0x8(%ebp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  806663:	83 c4 10             	add    $0x10,%esp
  806666:	85 c0                	test   %eax,%eax
  806668:	0f 84 00 01 00 00    	je     80676e <ip_input+0x2f7>
      return ERR_OK;
    }
    iphdr = p->payload;
  80666e:	8b 70 04             	mov    0x4(%eax),%esi
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  806671:	83 ec 08             	sub    $0x8,%esp
  806674:	ff 75 0c             	pushl  0xc(%ebp)
  806677:	ff 75 08             	pushl  0x8(%ebp)
  80667a:	e8 e3 74 00 00       	call   80db62 <raw_input>
  80667f:	83 c4 10             	add    $0x10,%esp
  806682:	84 c0                	test   %al,%al
  806684:	0f 85 e4 00 00 00    	jne    80676e <ip_input+0x2f7>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  80668a:	83 ec 0c             	sub    $0xc,%esp
  80668d:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806691:	50                   	push   %eax
  806692:	e8 4b 0f 00 00       	call   8075e2 <ntohs>
  806697:	83 c4 10             	add    $0x10,%esp
  80669a:	0f b6 c0             	movzbl %al,%eax
  80669d:	66 83 f8 06          	cmp    $0x6,%ax
  8066a1:	74 24                	je     8066c7 <ip_input+0x250>
  8066a3:	66 83 f8 11          	cmp    $0x11,%ax
  8066a7:	74 08                	je     8066b1 <ip_input+0x23a>
  8066a9:	66 83 f8 01          	cmp    $0x1,%ax
  8066ad:	75 41                	jne    8066f0 <ip_input+0x279>
  8066af:	eb 2c                	jmp    8066dd <ip_input+0x266>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  8066b1:	83 ec 08             	sub    $0x8,%esp
  8066b4:	ff 75 0c             	pushl  0xc(%ebp)
  8066b7:	ff 75 08             	pushl  0x8(%ebp)
  8066ba:	e8 e5 20 00 00       	call   8087a4 <udp_input>
      break;
  8066bf:	83 c4 10             	add    $0x10,%esp
  8066c2:	e9 a7 00 00 00       	jmp    80676e <ip_input+0x2f7>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  8066c7:	83 ec 08             	sub    $0x8,%esp
  8066ca:	ff 75 0c             	pushl  0xc(%ebp)
  8066cd:	ff 75 08             	pushl  0x8(%ebp)
  8066d0:	e8 1a 67 00 00       	call   80cdef <tcp_input>
      break;
  8066d5:	83 c4 10             	add    $0x10,%esp
  8066d8:	e9 91 00 00 00       	jmp    80676e <ip_input+0x2f7>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  8066dd:	83 ec 08             	sub    $0x8,%esp
  8066e0:	ff 75 0c             	pushl  0xc(%ebp)
  8066e3:	ff 75 08             	pushl  0x8(%ebp)
  8066e6:	e8 33 77 00 00       	call   80de1e <icmp_input>
      break;
  8066eb:	83 c4 10             	add    $0x10,%esp
  8066ee:	eb 7e                	jmp    80676e <ip_input+0x2f7>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8066f0:	83 ec 08             	sub    $0x8,%esp
  8066f3:	ff 75 0c             	pushl  0xc(%ebp)
  8066f6:	8d 46 10             	lea    0x10(%esi),%eax
  8066f9:	50                   	push   %eax
  8066fa:	e8 ce fc ff ff       	call   8063cd <ip_addr_isbroadcast>
  8066ff:	83 c4 10             	add    $0x10,%esp
  806702:	84 c0                	test   %al,%al
  806704:	75 39                	jne    80673f <ip_input+0x2c8>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  806706:	8b 5e 10             	mov    0x10(%esi),%ebx
  806709:	83 ec 0c             	sub    $0xc,%esp
  80670c:	68 00 00 00 f0       	push   $0xf0000000
  806711:	e8 fa 10 00 00       	call   807810 <ntohl>
  806716:	21 c3                	and    %eax,%ebx
  806718:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80671f:	e8 ec 10 00 00       	call   807810 <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806724:	83 c4 10             	add    $0x10,%esp
  806727:	39 c3                	cmp    %eax,%ebx
  806729:	74 14                	je     80673f <ip_input+0x2c8>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  80672b:	8b 45 08             	mov    0x8(%ebp),%eax
  80672e:	89 70 04             	mov    %esi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  806731:	83 ec 08             	sub    $0x8,%esp
  806734:	6a 02                	push   $0x2
  806736:	50                   	push   %eax
  806737:	e8 f4 79 00 00       	call   80e130 <icmp_dest_unreach>
  80673c:	83 c4 10             	add    $0x10,%esp
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  80673f:	83 ec 0c             	sub    $0xc,%esp
  806742:	ff 75 08             	pushl  0x8(%ebp)
  806745:	e8 da df ff ff       	call   804724 <pbuf_free>
  80674a:	83 c4 10             	add    $0x10,%esp
  80674d:	eb 1f                	jmp    80676e <ip_input+0x2f7>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  80674f:	83 ec 08             	sub    $0x8,%esp
  806752:	ff 75 0c             	pushl  0xc(%ebp)
  806755:	8d 46 0c             	lea    0xc(%esi),%eax
  806758:	50                   	push   %eax
  806759:	e8 6f fc ff ff       	call   8063cd <ip_addr_isbroadcast>
  80675e:	83 c4 10             	add    $0x10,%esp
  806761:	84 c0                	test   %al,%al
  806763:	0f 84 81 fe ff ff    	je     8065ea <ip_input+0x173>
  806769:	e9 a1 fe ff ff       	jmp    80660f <ip_input+0x198>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  80676e:	b8 00 00 00 00       	mov    $0x0,%eax
  806773:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806776:	5b                   	pop    %ebx
  806777:	5e                   	pop    %esi
  806778:	5f                   	pop    %edi
  806779:	5d                   	pop    %ebp
  80677a:	c3                   	ret    

0080677b <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  80677b:	55                   	push   %ebp
  80677c:	89 e5                	mov    %esp,%ebp
  80677e:	57                   	push   %edi
  80677f:	56                   	push   %esi
  806780:	53                   	push   %ebx
  806781:	83 ec 1c             	sub    $0x1c,%esp
  806784:	8b 75 08             	mov    0x8(%ebp),%esi
  806787:	8b 7d 14             	mov    0x14(%ebp),%edi
  80678a:	8b 45 18             	mov    0x18(%ebp),%eax
  80678d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806790:	8b 45 1c             	mov    0x1c(%ebp),%eax
  806793:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  806796:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80679a:	0f 84 12 01 00 00    	je     8068b2 <ip_output_if+0x137>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  8067a0:	83 ec 08             	sub    $0x8,%esp
  8067a3:	6a 14                	push   $0x14
  8067a5:	56                   	push   %esi
  8067a6:	e8 a7 de ff ff       	call   804652 <pbuf_header>
  8067ab:	83 c4 10             	add    $0x10,%esp
  8067ae:	84 c0                	test   %al,%al
  8067b0:	0f 85 40 01 00 00    	jne    8068f6 <ip_output_if+0x17b>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  8067b6:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  8067b9:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  8067be:	77 17                	ja     8067d7 <ip_output_if+0x5c>
  8067c0:	83 ec 04             	sub    $0x4,%esp
  8067c3:	68 08 1c 81 00       	push   $0x811c08
  8067c8:	68 ee 01 00 00       	push   $0x1ee
  8067cd:	68 35 1c 81 00       	push   $0x811c35
  8067d2:	e8 81 7b 00 00       	call   80e358 <_panic>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  8067d7:	83 ec 0c             	sub    $0xc,%esp
  8067da:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8067de:	50                   	push   %eax
  8067df:	e8 fe 0d 00 00       	call   8075e2 <ntohs>
  8067e4:	0f b6 c0             	movzbl %al,%eax
  8067e7:	c1 e7 08             	shl    $0x8,%edi
  8067ea:	09 c7                	or     %eax,%edi
  8067ec:	0f b7 ff             	movzwl %di,%edi
  8067ef:	89 3c 24             	mov    %edi,(%esp)
  8067f2:	e8 de 0d 00 00       	call   8075d5 <htons>
  8067f7:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  8067fb:	0f b7 c0             	movzwl %ax,%eax
  8067fe:	89 04 24             	mov    %eax,(%esp)
  806801:	e8 dc 0d 00 00       	call   8075e2 <ntohs>
  806806:	25 00 ff 00 00       	and    $0xff00,%eax
  80680b:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  80680f:	09 d0                	or     %edx,%eax
  806811:	0f b7 c0             	movzwl %ax,%eax
  806814:	89 04 24             	mov    %eax,(%esp)
  806817:	e8 b9 0d 00 00       	call   8075d5 <htons>
  80681c:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806820:	8b 45 10             	mov    0x10(%ebp),%eax
  806823:	8b 00                	mov    (%eax),%eax
  806825:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806828:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80682c:	80 cc 45             	or     $0x45,%ah
  80682f:	89 04 24             	mov    %eax,(%esp)
  806832:	e8 9e 0d 00 00       	call   8075d5 <htons>
  806837:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  80683a:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80683e:	89 04 24             	mov    %eax,(%esp)
  806841:	e8 8f 0d 00 00       	call   8075d5 <htons>
  806846:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  80684a:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806850:	0f b7 05 fa 43 b3 00 	movzwl 0xb343fa,%eax
  806857:	89 04 24             	mov    %eax,(%esp)
  80685a:	e8 76 0d 00 00       	call   8075d5 <htons>
  80685f:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  806863:	66 83 05 fa 43 b3 00 	addw   $0x1,0xb343fa
  80686a:	01 

    if (ip_addr_isany(src)) {
  80686b:	83 c4 10             	add    $0x10,%esp
  80686e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806872:	74 09                	je     80687d <ip_output_if+0x102>
  806874:	8b 45 0c             	mov    0xc(%ebp),%eax
  806877:	8b 00                	mov    (%eax),%eax
  806879:	85 c0                	test   %eax,%eax
  80687b:	75 18                	jne    806895 <ip_output_if+0x11a>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  80687d:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  806881:	74 08                	je     80688b <ip_output_if+0x110>
  806883:	8b 45 20             	mov    0x20(%ebp),%eax
  806886:	8b 40 04             	mov    0x4(%eax),%eax
  806889:	eb 05                	jmp    806890 <ip_output_if+0x115>
  80688b:	b8 00 00 00 00       	mov    $0x0,%eax
  806890:	89 43 0c             	mov    %eax,0xc(%ebx)
  806893:	eb 03                	jmp    806898 <ip_output_if+0x11d>
    } else {
      ip_addr_set(&(iphdr->src), src);
  806895:	89 43 0c             	mov    %eax,0xc(%ebx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806898:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80689e:	83 ec 08             	sub    $0x8,%esp
  8068a1:	6a 14                	push   $0x14
  8068a3:	53                   	push   %ebx
  8068a4:	e8 07 0c 00 00       	call   8074b0 <inet_chksum>
  8068a9:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  8068ad:	83 c4 10             	add    $0x10,%esp
  8068b0:	eb 09                	jmp    8068bb <ip_output_if+0x140>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  8068b2:	8b 46 04             	mov    0x4(%esi),%eax
  8068b5:	83 c0 10             	add    $0x10,%eax
  8068b8:	89 45 10             	mov    %eax,0x10(%ebp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  8068bb:	8b 45 20             	mov    0x20(%ebp),%eax
  8068be:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  8068c2:	66 85 c0             	test   %ax,%ax
  8068c5:	74 1a                	je     8068e1 <ip_output_if+0x166>
  8068c7:	66 3b 46 08          	cmp    0x8(%esi),%ax
  8068cb:	73 14                	jae    8068e1 <ip_output_if+0x166>
    return ip_frag(p,netif,dest);
  8068cd:	83 ec 04             	sub    $0x4,%esp
  8068d0:	ff 75 10             	pushl  0x10(%ebp)
  8068d3:	ff 75 20             	pushl  0x20(%ebp)
  8068d6:	56                   	push   %esi
  8068d7:	e8 84 07 00 00       	call   807060 <ip_frag>
  8068dc:	83 c4 10             	add    $0x10,%esp
  8068df:	eb 1a                	jmp    8068fb <ip_output_if+0x180>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  8068e1:	83 ec 04             	sub    $0x4,%esp
  8068e4:	ff 75 10             	pushl  0x10(%ebp)
  8068e7:	56                   	push   %esi
  8068e8:	ff 75 20             	pushl  0x20(%ebp)
  8068eb:	8b 45 20             	mov    0x20(%ebp),%eax
  8068ee:	ff 50 14             	call   *0x14(%eax)
  8068f1:	83 c4 10             	add    $0x10,%esp
  8068f4:	eb 05                	jmp    8068fb <ip_output_if+0x180>
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  8068f6:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  }
}
  8068fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8068fe:	5b                   	pop    %ebx
  8068ff:	5e                   	pop    %esi
  806900:	5f                   	pop    %edi
  806901:	5d                   	pop    %ebp
  806902:	c3                   	ret    

00806903 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806903:	55                   	push   %ebp
  806904:	89 e5                	mov    %esp,%ebp
  806906:	57                   	push   %edi
  806907:	56                   	push   %esi
  806908:	53                   	push   %ebx
  806909:	83 ec 18             	sub    $0x18,%esp
  80690c:	8b 5d 14             	mov    0x14(%ebp),%ebx
  80690f:	8b 75 18             	mov    0x18(%ebp),%esi
  806912:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806915:	ff 75 10             	pushl  0x10(%ebp)
  806918:	e8 fc fa ff ff       	call   806419 <ip_route>
  80691d:	83 c4 10             	add    $0x10,%esp
  806920:	85 c0                	test   %eax,%eax
  806922:	74 27                	je     80694b <ip_output+0x48>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806924:	83 ec 04             	sub    $0x4,%esp
  806927:	50                   	push   %eax
  806928:	89 f8                	mov    %edi,%eax
  80692a:	0f b6 f8             	movzbl %al,%edi
  80692d:	57                   	push   %edi
  80692e:	89 f0                	mov    %esi,%eax
  806930:	0f b6 f0             	movzbl %al,%esi
  806933:	56                   	push   %esi
  806934:	0f b6 db             	movzbl %bl,%ebx
  806937:	53                   	push   %ebx
  806938:	ff 75 10             	pushl  0x10(%ebp)
  80693b:	ff 75 0c             	pushl  0xc(%ebp)
  80693e:	ff 75 08             	pushl  0x8(%ebp)
  806941:	e8 35 fe ff ff       	call   80677b <ip_output_if>
  806946:	83 c4 20             	add    $0x20,%esp
  806949:	eb 05                	jmp    806950 <ip_output+0x4d>
          u8_t ttl, u8_t tos, u8_t proto)
{
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
    return ERR_RTE;
  80694b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
}
  806950:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806953:	5b                   	pop    %ebx
  806954:	5e                   	pop    %esi
  806955:	5f                   	pop    %edi
  806956:	5d                   	pop    %ebp
  806957:	c3                   	ret    

00806958 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806958:	55                   	push   %ebp
  806959:	89 e5                	mov    %esp,%ebp
  80695b:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  80695e:	8b 0d e0 49 b3 00    	mov    0xb349e0,%ecx
  806964:	39 c1                	cmp    %eax,%ecx
  806966:	75 0a                	jne    806972 <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  806968:	8b 11                	mov    (%ecx),%edx
  80696a:	89 15 e0 49 b3 00    	mov    %edx,0xb349e0
  806970:	eb 1f                	jmp    806991 <ip_reass_dequeue_datagram+0x39>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806972:	85 d2                	test   %edx,%edx
  806974:	75 17                	jne    80698d <ip_reass_dequeue_datagram+0x35>
  806976:	83 ec 04             	sub    $0x4,%esp
  806979:	68 4d 1c 81 00       	push   $0x811c4d
  80697e:	68 29 01 00 00       	push   $0x129
  806983:	68 66 1c 81 00       	push   $0x811c66
  806988:	e8 cb 79 00 00       	call   80e358 <_panic>
    prev->next = ipr->next;
  80698d:	8b 08                	mov    (%eax),%ecx
  80698f:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806991:	83 ec 08             	sub    $0x8,%esp
  806994:	50                   	push   %eax
  806995:	6a 05                	push   $0x5
  806997:	e8 15 da ff ff       	call   8043b1 <memp_free>
}
  80699c:	83 c4 10             	add    $0x10,%esp
  80699f:	c9                   	leave  
  8069a0:	c3                   	ret    

008069a1 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  8069a1:	55                   	push   %ebp
  8069a2:	89 e5                	mov    %esp,%ebp
  8069a4:	57                   	push   %edi
  8069a5:	56                   	push   %esi
  8069a6:	53                   	push   %ebx
  8069a7:	83 ec 1c             	sub    $0x1c,%esp
  8069aa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8069ad:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  8069b0:	39 c2                	cmp    %eax,%edx
  8069b2:	75 17                	jne    8069cb <ip_reass_free_complete_datagram+0x2a>
  8069b4:	83 ec 04             	sub    $0x4,%esp
  8069b7:	68 83 1c 81 00       	push   $0x811c83
  8069bc:	68 99 00 00 00       	push   $0x99
  8069c1:	68 66 1c 81 00       	push   $0x811c66
  8069c6:	e8 8d 79 00 00       	call   80e358 <_panic>
  if (prev != NULL) {
  8069cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8069ce:	85 c0                	test   %eax,%eax
  8069d0:	74 1e                	je     8069f0 <ip_reass_free_complete_datagram+0x4f>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  8069d2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8069d5:	3b 10                	cmp    (%eax),%edx
  8069d7:	74 17                	je     8069f0 <ip_reass_free_complete_datagram+0x4f>
  8069d9:	83 ec 04             	sub    $0x4,%esp
  8069dc:	68 8f 1c 81 00       	push   $0x811c8f
  8069e1:	68 9b 00 00 00       	push   $0x9b
  8069e6:	68 66 1c 81 00       	push   $0x811c66
  8069eb:	e8 68 79 00 00       	call   80e358 <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  8069f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8069f3:	8b 58 04             	mov    0x4(%eax),%ebx
  8069f6:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  int pbufs_freed = 0;
  8069f9:	be 00 00 00 00       	mov    $0x0,%esi
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
  8069fe:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806a03:	75 3a                	jne    806a3f <ip_reass_free_complete_datagram+0x9e>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  806a05:	8b 00                	mov    (%eax),%eax
  806a07:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806a0a:	89 41 04             	mov    %eax,0x4(%ecx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806a0d:	83 ec 04             	sub    $0x4,%esp
  806a10:	6a 14                	push   $0x14
  806a12:	8d 41 08             	lea    0x8(%ecx),%eax
  806a15:	50                   	push   %eax
  806a16:	ff 73 04             	pushl  0x4(%ebx)
  806a19:	e8 92 81 00 00       	call   80ebb0 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806a1e:	83 c4 08             	add    $0x8,%esp
  806a21:	6a 01                	push   $0x1
  806a23:	53                   	push   %ebx
  806a24:	e8 e6 77 00 00       	call   80e20f <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806a29:	89 1c 24             	mov    %ebx,(%esp)
  806a2c:	e8 52 e1 ff ff       	call   804b83 <pbuf_clen>
  806a31:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806a34:	89 1c 24             	mov    %ebx,(%esp)
  806a37:	e8 e8 dc ff ff       	call   804724 <pbuf_free>
  806a3c:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  806a3f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806a42:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806a45:	eb 20                	jmp    806a67 <ip_reass_free_complete_datagram+0xc6>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  806a47:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  806a4a:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806a4c:	83 ec 0c             	sub    $0xc,%esp
  806a4f:	53                   	push   %ebx
  806a50:	e8 2e e1 ff ff       	call   804b83 <pbuf_clen>
  806a55:	0f b6 c0             	movzbl %al,%eax
  806a58:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806a5a:	89 1c 24             	mov    %ebx,(%esp)
  806a5d:	e8 c2 dc ff ff       	call   804724 <pbuf_free>
  806a62:	83 c4 10             	add    $0x10,%esp
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  806a65:	89 fb                	mov    %edi,%ebx
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  806a67:	85 db                	test   %ebx,%ebx
  806a69:	75 dc                	jne    806a47 <ip_reass_free_complete_datagram+0xa6>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  806a6b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806a6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806a71:	e8 e2 fe ff ff       	call   806958 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806a76:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806a7d:	0f b7 d0             	movzwl %ax,%edx
  806a80:	39 d6                	cmp    %edx,%esi
  806a82:	7e 17                	jle    806a9b <ip_reass_free_complete_datagram+0xfa>
  806a84:	83 ec 04             	sub    $0x4,%esp
  806a87:	68 a1 1c 81 00       	push   $0x811ca1
  806a8c:	68 bc 00 00 00       	push   $0xbc
  806a91:	68 66 1c 81 00       	push   $0x811c66
  806a96:	e8 bd 78 00 00       	call   80e358 <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  806a9b:	29 f0                	sub    %esi,%eax
  806a9d:	66 a3 dc 49 b3 00    	mov    %ax,0xb349dc

  return pbufs_freed;
}
  806aa3:	89 f0                	mov    %esi,%eax
  806aa5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806aa8:	5b                   	pop    %ebx
  806aa9:	5e                   	pop    %esi
  806aaa:	5f                   	pop    %edi
  806aab:	5d                   	pop    %ebp
  806aac:	c3                   	ret    

00806aad <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  806aad:	55                   	push   %ebp
  806aae:	89 e5                	mov    %esp,%ebp
  806ab0:	57                   	push   %edi
  806ab1:	56                   	push   %esi
  806ab2:	53                   	push   %ebx
  806ab3:	83 ec 1c             	sub    $0x1c,%esp
  806ab6:	89 c6                	mov    %eax,%esi
  806ab8:	89 55 dc             	mov    %edx,-0x24(%ebp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  806abb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  806ac2:	8b 0d e0 49 b3 00    	mov    0xb349e0,%ecx
  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
  806ac8:	bb 00 00 00 00       	mov    $0x0,%ebx

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
  806acd:	ba 00 00 00 00       	mov    $0x0,%edx
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  806ad2:	b8 00 00 00 00       	mov    $0x0,%eax
  806ad7:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  806ada:	eb 39                	jmp    806b15 <ip_reass_remove_oldest_datagram+0x68>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806adc:	8b 5e 0c             	mov    0xc(%esi),%ebx
  806adf:	39 59 14             	cmp    %ebx,0x14(%ecx)
  806ae2:	75 12                	jne    806af6 <ip_reass_remove_oldest_datagram+0x49>
  806ae4:	8b 7e 10             	mov    0x10(%esi),%edi
  806ae7:	39 79 18             	cmp    %edi,0x18(%ecx)
  806aea:	75 0a                	jne    806af6 <ip_reass_remove_oldest_datagram+0x49>
  806aec:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  806af0:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  806af4:	74 16                	je     806b0c <ip_reass_remove_oldest_datagram+0x5f>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  806af6:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  806afa:	85 c0                	test   %eax,%eax
  806afc:	74 0c                	je     806b0a <ip_reass_remove_oldest_datagram+0x5d>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
  806afe:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  806b02:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  806b05:	0f 46 c1             	cmovbe %ecx,%eax
  806b08:	eb 02                	jmp    806b0c <ip_reass_remove_oldest_datagram+0x5f>
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
        if (oldest == NULL) {
          oldest = r;
  806b0a:	89 c8                	mov    %ecx,%eax
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  806b0c:	8b 39                	mov    (%ecx),%edi
        prev = r;
  806b0e:	85 ff                	test   %edi,%edi
  806b10:	0f 45 d1             	cmovne %ecx,%edx
  806b13:	89 f9                	mov    %edi,%ecx
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  806b15:	85 c9                	test   %ecx,%ecx
  806b17:	75 c3                	jne    806adc <ip_reass_remove_oldest_datagram+0x2f>
  806b19:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  806b1c:	85 c0                	test   %eax,%eax
  806b1e:	74 08                	je     806b28 <ip_reass_remove_oldest_datagram+0x7b>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806b20:	e8 7c fe ff ff       	call   8069a1 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806b25:	01 45 e0             	add    %eax,-0x20(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806b28:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806b2b:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  806b2e:	7d 05                	jge    806b35 <ip_reass_remove_oldest_datagram+0x88>
  806b30:	83 fb 01             	cmp    $0x1,%ebx
  806b33:	7f 8d                	jg     806ac2 <ip_reass_remove_oldest_datagram+0x15>
  return pbufs_freed;
}
  806b35:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806b38:	83 c4 1c             	add    $0x1c,%esp
  806b3b:	5b                   	pop    %ebx
  806b3c:	5e                   	pop    %esi
  806b3d:	5f                   	pop    %edi
  806b3e:	5d                   	pop    %ebp
  806b3f:	c3                   	ret    

00806b40 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  806b40:	55                   	push   %ebp
  806b41:	89 e5                	mov    %esp,%ebp
  806b43:	56                   	push   %esi
  806b44:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  806b45:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;
  806b4a:	bb 00 00 00 00       	mov    $0x0,%ebx

  r = reassdatagrams;
  while (r != NULL) {
  806b4f:	eb 1f                	jmp    806b70 <ip_reass_tmr+0x30>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  806b51:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806b55:	84 d2                	test   %dl,%dl
  806b57:	74 0c                	je     806b65 <ip_reass_tmr+0x25>
      r->timer--;
  806b59:	83 ea 01             	sub    $0x1,%edx
  806b5c:	88 50 1f             	mov    %dl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  806b5f:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806b61:	8b 00                	mov    (%eax),%eax
  806b63:	eb 0b                	jmp    806b70 <ip_reass_tmr+0x30>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  806b65:	8b 30                	mov    (%eax),%esi
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  806b67:	89 da                	mov    %ebx,%edx
  806b69:	e8 33 fe ff ff       	call   8069a1 <ip_reass_free_complete_datagram>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  806b6e:	89 f0                	mov    %esi,%eax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  806b70:	85 c0                	test   %eax,%eax
  806b72:	75 dd                	jne    806b51 <ip_reass_tmr+0x11>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  806b74:	5b                   	pop    %ebx
  806b75:	5e                   	pop    %esi
  806b76:	5d                   	pop    %ebp
  806b77:	c3                   	ret    

00806b78 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806b78:	55                   	push   %ebp
  806b79:	89 e5                	mov    %esp,%ebp
  806b7b:	57                   	push   %edi
  806b7c:	56                   	push   %esi
  806b7d:	53                   	push   %ebx
  806b7e:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806b81:	8b 45 08             	mov    0x8(%ebp),%eax
  806b84:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806b87:	0f b7 03             	movzwl (%ebx),%eax
  806b8a:	50                   	push   %eax
  806b8b:	e8 52 0a 00 00       	call   8075e2 <ntohs>
  806b90:	66 c1 e8 08          	shr    $0x8,%ax
  806b94:	83 e0 0f             	and    $0xf,%eax
  806b97:	83 c4 10             	add    $0x10,%esp
  806b9a:	83 f8 05             	cmp    $0x5,%eax
  806b9d:	0f 85 71 04 00 00    	jne    807014 <ip_reass+0x49c>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806ba3:	83 ec 0c             	sub    $0xc,%esp
  806ba6:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806baa:	50                   	push   %eax
  806bab:	e8 32 0a 00 00       	call   8075e2 <ntohs>
  806bb0:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806bb4:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806bb8:	89 04 24             	mov    %eax,(%esp)
  806bbb:	e8 22 0a 00 00       	call   8075e2 <ntohs>
  806bc0:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  806bc4:	0f b7 03             	movzwl (%ebx),%eax
  806bc7:	89 04 24             	mov    %eax,(%esp)
  806bca:	e8 13 0a 00 00       	call   8075e2 <ntohs>
  806bcf:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806bd3:	83 c4 04             	add    $0x4,%esp
  806bd6:	ff 75 08             	pushl  0x8(%ebp)
  806bd9:	e8 a5 df ff ff       	call   804b83 <pbuf_clen>
  806bde:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806be1:	0f b6 f0             	movzbl %al,%esi
  806be4:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806beb:	01 f0                	add    %esi,%eax
  806bed:	83 c4 10             	add    $0x10,%esp
  806bf0:	83 f8 0a             	cmp    $0xa,%eax
  806bf3:	7e 23                	jle    806c18 <ip_reass+0xa0>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806bf5:	89 f2                	mov    %esi,%edx
  806bf7:	89 d8                	mov    %ebx,%eax
  806bf9:	e8 af fe ff ff       	call   806aad <ip_reass_remove_oldest_datagram>
  806bfe:	85 c0                	test   %eax,%eax
  806c00:	0f 84 0e 04 00 00    	je     807014 <ip_reass+0x49c>
  806c06:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806c0d:	01 f0                	add    %esi,%eax
  806c0f:	83 f8 0a             	cmp    $0xa,%eax
  806c12:	0f 8f fc 03 00 00    	jg     807014 <ip_reass+0x49c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806c18:	8b 3d e0 49 b3 00    	mov    0xb349e0,%edi
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  806c1e:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806c23:	eb 1e                	jmp    806c43 <ip_reass+0xcb>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806c25:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806c28:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806c2b:	75 12                	jne    806c3f <ip_reass+0xc7>
  806c2d:	8b 53 10             	mov    0x10(%ebx),%edx
  806c30:	39 57 18             	cmp    %edx,0x18(%edi)
  806c33:	75 0a                	jne    806c3f <ip_reass+0xc7>
  806c35:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  806c39:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  806c3d:	74 7f                	je     806cbe <ip_reass+0x146>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806c3f:	89 f8                	mov    %edi,%eax
  806c41:	8b 3f                	mov    (%edi),%edi
  806c43:	85 ff                	test   %edi,%edi
  806c45:	75 de                	jne    806c25 <ip_reass+0xad>
  806c47:	89 45 e0             	mov    %eax,-0x20(%ebp)
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  806c4a:	83 ec 0c             	sub    $0xc,%esp
  806c4d:	6a 05                	push   $0x5
  806c4f:	e8 07 d7 ff ff       	call   80435b <memp_malloc>
  806c54:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  806c56:	83 c4 10             	add    $0x10,%esp
  806c59:	85 c0                	test   %eax,%eax
  806c5b:	75 28                	jne    806c85 <ip_reass+0x10d>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  806c5d:	89 f2                	mov    %esi,%edx
  806c5f:	89 d8                	mov    %ebx,%eax
  806c61:	e8 47 fe ff ff       	call   806aad <ip_reass_remove_oldest_datagram>
  806c66:	39 c6                	cmp    %eax,%esi
  806c68:	0f 8f a6 03 00 00    	jg     807014 <ip_reass+0x49c>
      ipr = memp_malloc(MEMP_REASSDATA);
  806c6e:	83 ec 0c             	sub    $0xc,%esp
  806c71:	6a 05                	push   $0x5
  806c73:	e8 e3 d6 ff ff       	call   80435b <memp_malloc>
  806c78:	89 c7                	mov    %eax,%edi
    }
    if (ipr == NULL)
  806c7a:	83 c4 10             	add    $0x10,%esp
  806c7d:	85 c0                	test   %eax,%eax
  806c7f:	0f 84 8f 03 00 00    	je     807014 <ip_reass+0x49c>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  806c85:	83 ec 04             	sub    $0x4,%esp
  806c88:	6a 20                	push   $0x20
  806c8a:	6a 00                	push   $0x0
  806c8c:	57                   	push   %edi
  806c8d:	e8 69 7e 00 00       	call   80eafb <memset>
  ipr->timer = IP_REASS_MAXAGE;
  806c92:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  806c96:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  806c9b:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  806c9d:	89 3d e0 49 b3 00    	mov    %edi,0xb349e0
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  806ca3:	83 c4 0c             	add    $0xc,%esp
  806ca6:	6a 14                	push   $0x14
  806ca8:	53                   	push   %ebx
  806ca9:	8d 47 08             	lea    0x8(%edi),%eax
  806cac:	50                   	push   %eax
  806cad:	e8 fe 7e 00 00       	call   80ebb0 <memcpy>

  if (ipr == NULL) {
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  806cb2:	83 c4 10             	add    $0x10,%esp
  806cb5:	85 ff                	test   %edi,%edi
  806cb7:	75 46                	jne    806cff <ip_reass+0x187>
  806cb9:	e9 56 03 00 00       	jmp    807014 <ip_reass+0x49c>
  806cbe:	89 45 e0             	mov    %eax,-0x20(%ebp)
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806cc1:	83 ec 0c             	sub    $0xc,%esp
  806cc4:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806cc8:	50                   	push   %eax
  806cc9:	e8 14 09 00 00       	call   8075e2 <ntohs>
  806cce:	83 c4 10             	add    $0x10,%esp
  806cd1:	66 a9 ff 1f          	test   $0x1fff,%ax
  806cd5:	75 28                	jne    806cff <ip_reass+0x187>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  806cd7:	83 ec 0c             	sub    $0xc,%esp
  806cda:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  806cde:	50                   	push   %eax
  806cdf:	e8 fe 08 00 00       	call   8075e2 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806ce4:	83 c4 10             	add    $0x10,%esp
  806ce7:	66 a9 ff 1f          	test   $0x1fff,%ax
  806ceb:	74 12                	je     806cff <ip_reass+0x187>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  806ced:	83 ec 04             	sub    $0x4,%esp
  806cf0:	6a 14                	push   $0x14
  806cf2:	53                   	push   %ebx
  806cf3:	8d 47 08             	lea    0x8(%edi),%eax
  806cf6:	50                   	push   %eax
  806cf7:	e8 b4 7e 00 00       	call   80ebb0 <memcpy>
  806cfc:	83 c4 10             	add    $0x10,%esp
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806cff:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806d03:	66 01 05 dc 49 b3 00 	add    %ax,0xb349dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806d0a:	83 ec 0c             	sub    $0xc,%esp
  806d0d:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d11:	50                   	push   %eax
  806d12:	e8 cb 08 00 00       	call   8075e2 <ntohs>
  806d17:	83 c4 10             	add    $0x10,%esp
  806d1a:	f6 c4 20             	test   $0x20,%ah
  806d1d:	75 20                	jne    806d3f <ip_reass+0x1c7>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806d1f:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806d23:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  806d27:	0f b7 75 da          	movzwl -0x26(%ebp),%esi
  806d2b:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  806d2e:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
  806d32:	66 c1 ea 06          	shr    $0x6,%dx
  806d36:	83 e2 3c             	and    $0x3c,%edx
  806d39:	29 d0                	sub    %edx,%eax
  806d3b:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806d3f:	8b 45 08             	mov    0x8(%ebp),%eax
  806d42:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806d45:	83 ec 0c             	sub    $0xc,%esp
  806d48:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806d4c:	50                   	push   %eax
  806d4d:	e8 90 08 00 00       	call   8075e2 <ntohs>
  806d52:	89 c6                	mov    %eax,%esi
  806d54:	0f b7 03             	movzwl (%ebx),%eax
  806d57:	89 04 24             	mov    %eax,(%esp)
  806d5a:	e8 83 08 00 00       	call   8075e2 <ntohs>
  806d5f:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806d63:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d67:	89 04 24             	mov    %eax,(%esp)
  806d6a:	e8 73 08 00 00       	call   8075e2 <ntohs>
  806d6f:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  806d76:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806d79:	8b 51 04             	mov    0x4(%ecx),%edx
  806d7c:	89 55 dc             	mov    %edx,-0x24(%ebp)
  iprh->next_pbuf = NULL;
  806d7f:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  806d85:	66 89 5a 04          	mov    %bx,0x4(%edx)
  iprh->end = offset + len;
  806d89:	01 de                	add    %ebx,%esi
  806d8b:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806d8f:	66 c1 e8 06          	shr    $0x6,%ax
  806d93:	83 e0 3c             	and    $0x3c,%eax
  806d96:	29 c6                	sub    %eax,%esi
  806d98:	66 89 75 da          	mov    %si,-0x26(%ebp)
  806d9c:	66 89 72 06          	mov    %si,0x6(%edx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  806da0:	8b 47 04             	mov    0x4(%edi),%eax
  806da3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  806da6:	83 c4 10             	add    $0x10,%esp
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  806da9:	b9 01 00 00 00       	mov    $0x1,%ecx
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  806dae:	be 00 00 00 00       	mov    $0x0,%esi
  806db3:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806db6:	89 cf                	mov    %ecx,%edi
  806db8:	eb 6f                	jmp    806e29 <ip_reass+0x2b1>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806dba:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  806dbd:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  806dc1:	66 39 cb             	cmp    %cx,%bx
  806dc4:	73 3c                	jae    806e02 <ip_reass+0x28a>
  806dc6:	89 7d d0             	mov    %edi,-0x30(%ebp)
  806dc9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  806dcc:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  806dcf:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  806dd1:	85 f6                	test   %esi,%esi
  806dd3:	74 22                	je     806df7 <ip_reass+0x27f>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  806dd5:	66 3b 5e 06          	cmp    0x6(%esi),%bx
  806dd9:	0f 82 6c 01 00 00    	jb     806f4b <ip_reass+0x3d3>
  806ddf:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  806de3:	66 3b 42 04          	cmp    0x4(%edx),%ax
  806de7:	0f 87 5e 01 00 00    	ja     806f4b <ip_reass+0x3d3>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  806ded:	8b 45 08             	mov    0x8(%ebp),%eax
  806df0:	89 06                	mov    %eax,(%esi)
  806df2:	e9 92 00 00 00       	jmp    806e89 <ip_reass+0x311>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  806df7:	8b 45 08             	mov    0x8(%ebp),%eax
  806dfa:	89 47 04             	mov    %eax,0x4(%edi)
  806dfd:	e9 87 00 00 00       	jmp    806e89 <ip_reass+0x311>
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  806e02:	66 39 cb             	cmp    %cx,%bx
  806e05:	0f 84 40 01 00 00    	je     806f4b <ip_reass+0x3d3>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  806e0b:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  806e0f:	0f 82 36 01 00 00    	jb     806f4b <ip_reass+0x3d3>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  806e15:	85 f6                	test   %esi,%esi
  806e17:	74 0c                	je     806e25 <ip_reass+0x2ad>
        if (iprh_prev->end != iprh_tmp->start) {
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  806e19:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  806e1d:	b8 00 00 00 00       	mov    $0x0,%eax
  806e22:	0f 45 f8             	cmovne %eax,%edi
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  806e25:	8b 02                	mov    (%edx),%eax
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806e27:	89 d6                	mov    %edx,%esi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  806e29:	85 c0                	test   %eax,%eax
  806e2b:	75 8d                	jne    806dba <ip_reass+0x242>
  806e2d:	e9 fe 01 00 00       	jmp    807030 <ip_reass+0x4b8>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  806e32:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  806e36:	66 39 c3             	cmp    %ax,%bx
  806e39:	73 17                	jae    806e52 <ip_reass+0x2da>
  806e3b:	83 ec 04             	sub    $0x4,%esp
  806e3e:	68 bc 1c 81 00       	push   $0x811cbc
  806e43:	68 83 01 00 00       	push   $0x183
  806e48:	68 66 1c 81 00       	push   $0x811c66
  806e4d:	e8 06 75 00 00       	call   80e358 <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  806e52:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806e55:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  806e57:	8b 75 dc             	mov    -0x24(%ebp),%esi
  806e5a:	66 3b 46 04          	cmp    0x4(%esi),%ax
  806e5e:	0f 85 ef 01 00 00    	jne    807053 <ip_reass+0x4db>
  806e64:	eb 23                	jmp    806e89 <ip_reass+0x311>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  806e66:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  806e6a:	74 17                	je     806e83 <ip_reass+0x30b>
  806e6c:	83 ec 04             	sub    $0x4,%esp
  806e6f:	68 e8 1c 81 00       	push   $0x811ce8
  806e74:	68 8c 01 00 00       	push   $0x18c
  806e79:	68 66 1c 81 00       	push   $0x811c66
  806e7e:	e8 d5 74 00 00       	call   80e358 <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  806e83:	8b 45 08             	mov    0x8(%ebp),%eax
  806e86:	89 47 04             	mov    %eax,0x4(%edi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  806e89:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  806e8d:	0f 84 c0 01 00 00    	je     807053 <ip_reass+0x4db>
    /* and had no wholes so far */
    if (valid) {
  806e93:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  806e97:	0f 84 b6 01 00 00    	je     807053 <ip_reass+0x4db>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  806e9d:	8b 4f 04             	mov    0x4(%edi),%ecx
  806ea0:	8b 59 04             	mov    0x4(%ecx),%ebx
  806ea3:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  806ea8:	0f 85 a5 01 00 00    	jne    807053 <ip_reass+0x4db>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  806eae:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806eb1:	8b 10                	mov    (%eax),%edx
  806eb3:	89 c6                	mov    %eax,%esi
  806eb5:	eb 15                	jmp    806ecc <ip_reass+0x354>
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  806eb7:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  806eba:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  806ebe:	66 39 56 06          	cmp    %dx,0x6(%esi)
  806ec2:	0f 85 61 01 00 00    	jne    807029 <ip_reass+0x4b1>
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  806ec8:	8b 10                	mov    (%eax),%edx
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  806eca:	89 c6                	mov    %eax,%esi
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  806ecc:	85 d2                	test   %edx,%edx
  806ece:	75 e7                	jne    806eb7 <ip_reass+0x33f>
  806ed0:	e9 6e 01 00 00       	jmp    807043 <ip_reass+0x4cb>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  806ed5:	83 ec 04             	sub    $0x4,%esp
  806ed8:	68 da 1c 81 00       	push   $0x811cda
  806edd:	68 ac 01 00 00       	push   $0x1ac
  806ee2:	68 66 1c 81 00       	push   $0x811c66
  806ee7:	e8 6c 74 00 00       	call   80e358 <_panic>
          LWIP_ASSERT("sanity check",
  806eec:	3b 5d dc             	cmp    -0x24(%ebp),%ebx
  806eef:	75 17                	jne    806f08 <ip_reass+0x390>
  806ef1:	83 ec 04             	sub    $0x4,%esp
  806ef4:	68 da 1c 81 00       	push   $0x811cda
  806ef9:	68 ae 01 00 00       	push   $0x1ae
  806efe:	68 66 1c 81 00       	push   $0x811c66
  806f03:	e8 50 74 00 00       	call   80e358 <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  806f08:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806f0b:	83 38 00             	cmpl   $0x0,(%eax)
  806f0e:	74 17                	je     806f27 <ip_reass+0x3af>
  806f10:	83 ec 04             	sub    $0x4,%esp
  806f13:	68 20 1d 81 00       	push   $0x811d20
  806f18:	68 b0 01 00 00       	push   $0x1b0
  806f1d:	68 66 1c 81 00       	push   $0x811c66
  806f22:	e8 31 74 00 00       	call   80e358 <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  806f27:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806f2a:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  806f2e:	66 3b 47 1c          	cmp    0x1c(%edi),%ax
  806f32:	74 3f                	je     806f73 <ip_reass+0x3fb>
  806f34:	83 ec 04             	sub    $0x4,%esp
  806f37:	68 44 1d 81 00       	push   $0x811d44
  806f3c:	68 b2 01 00 00       	push   $0x1b2
  806f41:	68 66 1c 81 00       	push   $0x811c66
  806f46:	e8 0d 74 00 00       	call   80e358 <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  806f4b:	83 ec 0c             	sub    $0xc,%esp
  806f4e:	ff 75 08             	pushl  0x8(%ebp)
  806f51:	e8 2d dc ff ff       	call   804b83 <pbuf_clen>
  806f56:	0f b6 c0             	movzbl %al,%eax
  806f59:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
  pbuf_free(new_p);
  806f60:	83 c4 04             	add    $0x4,%esp
  806f63:	ff 75 08             	pushl  0x8(%ebp)
  806f66:	e8 b9 d7 ff ff       	call   804724 <pbuf_free>
  806f6b:	83 c4 10             	add    $0x10,%esp
  806f6e:	e9 e0 00 00 00       	jmp    807053 <ip_reass+0x4db>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  806f73:	83 c0 14             	add    $0x14,%eax
  806f76:	66 89 47 1c          	mov    %ax,0x1c(%edi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  806f7a:	8b 71 04             	mov    0x4(%ecx),%esi
  806f7d:	8b 1e                	mov    (%esi),%ebx

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  806f7f:	83 ec 04             	sub    $0x4,%esp
  806f82:	6a 14                	push   $0x14
  806f84:	8d 47 08             	lea    0x8(%edi),%eax
  806f87:	50                   	push   %eax
  806f88:	56                   	push   %esi
  806f89:	e8 22 7c 00 00       	call   80ebb0 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  806f8e:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  806f92:	89 04 24             	mov    %eax,(%esp)
  806f95:	e8 3b 06 00 00       	call   8075d5 <htons>
  806f9a:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  806f9e:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  806fa4:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  806faa:	83 c4 08             	add    $0x8,%esp
  806fad:	6a 14                	push   $0x14
  806faf:	56                   	push   %esi
  806fb0:	e8 fb 04 00 00       	call   8074b0 <inet_chksum>
  806fb5:	66 89 46 0a          	mov    %ax,0xa(%esi)

    p = ipr->p;
  806fb9:	8b 47 04             	mov    0x4(%edi),%eax
  806fbc:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  806fbf:	83 c4 10             	add    $0x10,%esp
  806fc2:	89 7d dc             	mov    %edi,-0x24(%ebp)
  806fc5:	89 c7                	mov    %eax,%edi
  806fc7:	eb 1d                	jmp    806fe6 <ip_reass+0x46e>
      iprh = (struct ip_reass_helper*)r->payload;
  806fc9:	8b 73 04             	mov    0x4(%ebx),%esi

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  806fcc:	83 ec 08             	sub    $0x8,%esp
  806fcf:	6a ec                	push   $0xffffffec
  806fd1:	53                   	push   %ebx
  806fd2:	e8 7b d6 ff ff       	call   804652 <pbuf_header>
      pbuf_cat(p, r);
  806fd7:	83 c4 08             	add    $0x8,%esp
  806fda:	53                   	push   %ebx
  806fdb:	57                   	push   %edi
  806fdc:	e8 cb db ff ff       	call   804bac <pbuf_cat>
      r = iprh->next_pbuf;
  806fe1:	8b 1e                	mov    (%esi),%ebx
  806fe3:	83 c4 10             	add    $0x10,%esp
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  806fe6:	85 db                	test   %ebx,%ebx
  806fe8:	75 df                	jne    806fc9 <ip_reass+0x451>
  806fea:	8b 7d dc             	mov    -0x24(%ebp),%edi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  806fed:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806ff0:	89 f8                	mov    %edi,%eax
  806ff2:	e8 61 f9 ff ff       	call   806958 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  806ff7:	83 ec 0c             	sub    $0xc,%esp
  806ffa:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  806ffd:	56                   	push   %esi
  806ffe:	e8 80 db ff ff       	call   804b83 <pbuf_clen>
  807003:	0f b6 c0             	movzbl %al,%eax
  807006:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc

    /* Return the pbuf chain */
    return p;
  80700d:	83 c4 10             	add    $0x10,%esp
  807010:	89 f0                	mov    %esi,%eax
  807012:	eb 44                	jmp    807058 <ip_reass+0x4e0>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  807014:	83 ec 0c             	sub    $0xc,%esp
  807017:	ff 75 08             	pushl  0x8(%ebp)
  80701a:	e8 05 d7 ff ff       	call   804724 <pbuf_free>
  return NULL;
  80701f:	83 c4 10             	add    $0x10,%esp
  807022:	b8 00 00 00 00       	mov    $0x0,%eax
  807027:	eb 2f                	jmp    807058 <ip_reass+0x4e0>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  807029:	b8 00 00 00 00       	mov    $0x0,%eax
  80702e:	eb 28                	jmp    807058 <ip_reass+0x4e0>
  807030:	89 7d d0             	mov    %edi,-0x30(%ebp)
  807033:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  807036:	85 f6                	test   %esi,%esi
  807038:	0f 85 f4 fd ff ff    	jne    806e32 <ip_reass+0x2ba>
  80703e:	e9 23 fe ff ff       	jmp    806e66 <ip_reass+0x2ee>
  807043:	89 75 dc             	mov    %esi,-0x24(%ebp)
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  807046:	85 c9                	test   %ecx,%ecx
  807048:	0f 85 9e fe ff ff    	jne    806eec <ip_reass+0x374>
  80704e:	e9 82 fe ff ff       	jmp    806ed5 <ip_reass+0x35d>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  807053:	b8 00 00 00 00       	mov    $0x0,%eax
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
  807058:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80705b:	5b                   	pop    %ebx
  80705c:	5e                   	pop    %esi
  80705d:	5f                   	pop    %edi
  80705e:	5d                   	pop    %ebp
  80705f:	c3                   	ret    

00807060 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  807060:	55                   	push   %ebp
  807061:	89 e5                	mov    %esp,%ebp
  807063:	57                   	push   %edi
  807064:	56                   	push   %esi
  807065:	53                   	push   %ebx
  807066:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  807069:	8b 45 0c             	mov    0xc(%ebp),%eax
  80706c:	0f b7 58 2c          	movzwl 0x2c(%eax),%ebx
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  807070:	6a 02                	push   $0x2
  807072:	6a 00                	push   $0x0
  807074:	6a 02                	push   $0x2
  807076:	e8 6f d7 ff ff       	call   8047ea <pbuf_alloc>
  80707b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (rambuf == NULL) {
  80707e:	83 c4 10             	add    $0x10,%esp
  807081:	85 c0                	test   %eax,%eax
  807083:	0f 84 9f 01 00 00    	je     807228 <ip_frag+0x1c8>
  807089:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  80708b:	66 89 58 0a          	mov    %bx,0xa(%eax)
  80708f:	66 89 58 08          	mov    %bx,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  807093:	b8 03 44 b3 00       	mov    $0xb34403,%eax
  807098:	83 e0 fc             	and    $0xfffffffc,%eax
  80709b:	89 c7                	mov    %eax,%edi
  80709d:	89 7e 04             	mov    %edi,0x4(%esi)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8070a0:	83 ec 04             	sub    $0x4,%esp
  8070a3:	6a 14                	push   $0x14
  8070a5:	8b 45 08             	mov    0x8(%ebp),%eax
  8070a8:	ff 70 04             	pushl  0x4(%eax)
  8070ab:	57                   	push   %edi
  8070ac:	e8 ff 7a 00 00       	call   80ebb0 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8070b1:	0f b7 47 06          	movzwl 0x6(%edi),%eax
  8070b5:	89 04 24             	mov    %eax,(%esp)
  8070b8:	e8 25 05 00 00       	call   8075e2 <ntohs>
  ofo = tmp & IP_OFFMASK;
  8070bd:	89 c6                	mov    %eax,%esi
  8070bf:	66 81 e6 ff 1f       	and    $0x1fff,%si
  8070c4:	66 89 75 de          	mov    %si,-0x22(%ebp)
  omf = tmp & IP_MF;
  8070c8:	66 25 00 20          	and    $0x2000,%ax
  8070cc:	66 89 45 dc          	mov    %ax,-0x24(%ebp)

  left = p->tot_len - IP_HLEN;
  8070d0:	8b 45 08             	mov    0x8(%ebp),%eax
  8070d3:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8070d7:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  8070db:	8d 70 ec             	lea    -0x14(%eax),%esi

  nfb = (mtu - IP_HLEN) / 8;
  8070de:	0f b7 db             	movzwl %bx,%ebx
  8070e1:	8d 43 f3             	lea    -0xd(%ebx),%eax
  8070e4:	83 c4 10             	add    $0x10,%esp
  8070e7:	83 eb 14             	sub    $0x14,%ebx
  8070ea:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  8070ed:	0f 49 c3             	cmovns %ebx,%eax
  8070f0:	c1 f8 03             	sar    $0x3,%eax
  8070f3:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  8070f7:	66 c7 45 e4 14 00    	movw   $0x14,-0x1c(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  8070fd:	c1 e0 03             	shl    $0x3,%eax
  807100:	66 89 45 cc          	mov    %ax,-0x34(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807104:	8d 47 14             	lea    0x14(%edi),%eax
  807107:	89 45 d0             	mov    %eax,-0x30(%ebp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  80710a:	e9 fb 00 00 00       	jmp    80720a <ip_frag+0x1aa>
    last = (left <= mtu - IP_HLEN);
  80710f:	0f b7 c6             	movzwl %si,%eax
  807112:	89 45 d8             	mov    %eax,-0x28(%ebp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  807115:	0f b7 5d de          	movzwl -0x22(%ebp),%ebx
  807119:	66 81 e3 ff 1f       	and    $0x1fff,%bx
  80711e:	66 0b 5d dc          	or     -0x24(%ebp),%bx
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807122:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
  while (left) {
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
  807126:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  807129:	7d 0b                	jge    807136 <ip_frag+0xd6>
      tmp = tmp | IP_MF;
  80712b:	80 cf 20             	or     $0x20,%bh

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  80712e:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax
  807132:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807136:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80713a:	50                   	push   %eax
  80713b:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80713f:	50                   	push   %eax
  807140:	ff 75 d0             	pushl  -0x30(%ebp)
  807143:	ff 75 08             	pushl  0x8(%ebp)
  807146:	e8 29 dd ff ff       	call   804e74 <pbuf_copy_partial>
  80714b:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  80714f:	0f b7 db             	movzwl %bx,%ebx
  807152:	89 1c 24             	mov    %ebx,(%esp)
  807155:	e8 7b 04 00 00       	call   8075d5 <htons>
  80715a:	66 89 47 06          	mov    %ax,0x6(%edi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  80715e:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
  807162:	8d 41 14             	lea    0x14(%ecx),%eax
  807165:	0f b7 c0             	movzwl %ax,%eax
  807168:	89 04 24             	mov    %eax,(%esp)
  80716b:	e8 65 04 00 00       	call   8075d5 <htons>
  807170:	66 89 47 02          	mov    %ax,0x2(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  807174:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80717a:	83 c4 08             	add    $0x8,%esp
  80717d:	6a 14                	push   $0x14
  80717f:	57                   	push   %edi
  807180:	e8 2b 03 00 00       	call   8074b0 <inet_chksum>
  807185:	66 89 47 0a          	mov    %ax,0xa(%edi)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  807189:	83 c4 10             	add    $0x10,%esp
  80718c:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80718f:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  807192:	7c 15                	jl     8071a9 <ip_frag+0x149>
      pbuf_realloc(rambuf, left + IP_HLEN);
  807194:	83 ec 08             	sub    $0x8,%esp
  807197:	8d 46 14             	lea    0x14(%esi),%eax
  80719a:	0f b7 c0             	movzwl %ax,%eax
  80719d:	50                   	push   %eax
  80719e:	ff 75 d4             	pushl  -0x2c(%ebp)
  8071a1:	e8 c7 d8 ff ff       	call   804a6d <pbuf_realloc>
  8071a6:	83 c4 10             	add    $0x10,%esp
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  8071a9:	83 ec 04             	sub    $0x4,%esp
  8071ac:	6a 00                	push   $0x0
  8071ae:	6a 00                	push   $0x0
  8071b0:	6a 02                	push   $0x2
  8071b2:	e8 33 d6 ff ff       	call   8047ea <pbuf_alloc>
  8071b7:	89 c3                	mov    %eax,%ebx
    if (header != NULL) {
  8071b9:	83 c4 10             	add    $0x10,%esp
  8071bc:	85 c0                	test   %eax,%eax
  8071be:	74 35                	je     8071f5 <ip_frag+0x195>
      pbuf_chain(header, rambuf);
  8071c0:	83 ec 08             	sub    $0x8,%esp
  8071c3:	ff 75 d4             	pushl  -0x2c(%ebp)
  8071c6:	50                   	push   %eax
  8071c7:	e8 4c da ff ff       	call   804c18 <pbuf_chain>
      netif->output(netif, header, dest);
  8071cc:	83 c4 0c             	add    $0xc,%esp
  8071cf:	ff 75 10             	pushl  0x10(%ebp)
  8071d2:	53                   	push   %ebx
  8071d3:	ff 75 0c             	pushl  0xc(%ebp)
  8071d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  8071d9:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  8071dc:	89 1c 24             	mov    %ebx,(%esp)
  8071df:	e8 40 d5 ff ff       	call   804724 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  8071e4:	66 2b 75 e6          	sub    -0x1a(%ebp),%si
    ofo += nfb;
  8071e8:	0f b7 4d ce          	movzwl -0x32(%ebp),%ecx
  8071ec:	66 01 4d de          	add    %cx,-0x22(%ebp)
  8071f0:	83 c4 10             	add    $0x10,%esp
  8071f3:	eb 15                	jmp    80720a <ip_frag+0x1aa>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  8071f5:	83 ec 0c             	sub    $0xc,%esp
  8071f8:	ff 75 d4             	pushl  -0x2c(%ebp)
  8071fb:	e8 24 d5 ff ff       	call   804724 <pbuf_free>
      return ERR_MEM;
  807200:	83 c4 10             	add    $0x10,%esp
  807203:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807208:	eb 23                	jmp    80722d <ip_frag+0x1cd>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  80720a:	66 85 f6             	test   %si,%si
  80720d:	0f 85 fc fe ff ff    	jne    80710f <ip_frag+0xaf>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  807213:	83 ec 0c             	sub    $0xc,%esp
  807216:	ff 75 d4             	pushl  -0x2c(%ebp)
  807219:	e8 06 d5 ff ff       	call   804724 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  80721e:	83 c4 10             	add    $0x10,%esp
  807221:	b8 00 00 00 00       	mov    $0x0,%eax
  807226:	eb 05                	jmp    80722d <ip_frag+0x1cd>
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  807228:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  80722d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807230:	5b                   	pop    %ebx
  807231:	5e                   	pop    %esi
  807232:	5f                   	pop    %edi
  807233:	5d                   	pop    %ebp
  807234:	c3                   	ret    

00807235 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  807235:	55                   	push   %ebp
  807236:	89 e5                	mov    %esp,%ebp
  807238:	57                   	push   %edi
  807239:	56                   	push   %esi
  80723a:	53                   	push   %ebx
  80723b:	83 ec 1c             	sub    $0x1c,%esp
  80723e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  807241:	89 c3                	mov    %eax,%ebx
  while (len > 1) {
  807243:	89 d7                	mov    %edx,%edi
{
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  807245:	be 00 00 00 00       	mov    $0x0,%esi
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80724a:	eb 17                	jmp    807263 <lwip_standard_chksum+0x2e>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80724c:	0f b6 03             	movzbl (%ebx),%eax
  80724f:	c1 e0 08             	shl    $0x8,%eax
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  807252:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  807256:	09 c8                	or     %ecx,%eax
  807258:	83 c3 02             	add    $0x2,%ebx
    octetptr++;
    acc += src;
  80725b:	0f b7 c0             	movzwl %ax,%eax
  80725e:	01 c6                	add    %eax,%esi
    len -= 2;
  807260:	83 ef 02             	sub    $0x2,%edi
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  807263:	66 83 ff 01          	cmp    $0x1,%di
  807267:	77 e3                	ja     80724c <lwip_standard_chksum+0x17>
  807269:	89 d0                	mov    %edx,%eax
  80726b:	66 d1 e8             	shr    %ax
  80726e:	0f b7 c8             	movzwl %ax,%ecx
  807271:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  807274:	8d 0c 4f             	lea    (%edi,%ecx,2),%ecx
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  807277:	f7 d8                	neg    %eax
  807279:	8d 14 42             	lea    (%edx,%eax,2),%edx
  80727c:	66 85 d2             	test   %dx,%dx
  80727f:	74 0b                	je     80728c <lwip_standard_chksum+0x57>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    acc += src;
  807281:	0f b6 01             	movzbl (%ecx),%eax
  807284:	c1 e0 08             	shl    $0x8,%eax
  807287:	0f b7 c0             	movzwl %ax,%eax
  80728a:	01 c6                	add    %eax,%esi
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80728c:	89 f0                	mov    %esi,%eax
  80728e:	c1 e8 10             	shr    $0x10,%eax
  807291:	0f b7 f6             	movzwl %si,%esi
  807294:	01 c6                	add    %eax,%esi
  if ((acc & 0xffff0000) != 0) {
  807296:	f7 c6 00 00 ff ff    	test   $0xffff0000,%esi
  80729c:	74 0a                	je     8072a8 <lwip_standard_chksum+0x73>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80729e:	89 f0                	mov    %esi,%eax
  8072a0:	c1 e8 10             	shr    $0x10,%eax
  8072a3:	0f b7 f6             	movzwl %si,%esi
  8072a6:	01 c6                	add    %eax,%esi
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  8072a8:	83 ec 0c             	sub    $0xc,%esp
  8072ab:	0f b7 f6             	movzwl %si,%esi
  8072ae:	56                   	push   %esi
  8072af:	e8 21 03 00 00       	call   8075d5 <htons>
}
  8072b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8072b7:	5b                   	pop    %ebx
  8072b8:	5e                   	pop    %esi
  8072b9:	5f                   	pop    %edi
  8072ba:	5d                   	pop    %ebp
  8072bb:	c3                   	ret    

008072bc <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  8072bc:	55                   	push   %ebp
  8072bd:	89 e5                	mov    %esp,%ebp
  8072bf:	57                   	push   %edi
  8072c0:	56                   	push   %esi
  8072c1:	53                   	push   %ebx
  8072c2:	83 ec 1c             	sub    $0x1c,%esp
  8072c5:	8b 75 08             	mov    0x8(%ebp),%esi
  8072c8:	8b 45 14             	mov    0x14(%ebp),%eax
  8072cb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8072ce:	8b 45 18             	mov    0x18(%ebp),%eax
  8072d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8072d4:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  8072d9:	bb 00 00 00 00       	mov    $0x0,%ebx
  8072de:	89 f8                	mov    %edi,%eax
  8072e0:	89 df                	mov    %ebx,%edi
  8072e2:	89 c3                	mov    %eax,%ebx
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8072e4:	eb 3d                	jmp    807323 <inet_chksum_pseudo+0x67>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  8072e6:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8072ea:	8b 46 04             	mov    0x4(%esi),%eax
  8072ed:	e8 43 ff ff ff       	call   807235 <lwip_standard_chksum>
  8072f2:	0f b7 c0             	movzwl %ax,%eax
  8072f5:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  8072f7:	89 c7                	mov    %eax,%edi
  8072f9:	c1 ef 10             	shr    $0x10,%edi
  8072fc:	0f b7 c0             	movzwl %ax,%eax
  8072ff:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  807301:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807305:	74 1a                	je     807321 <inet_chksum_pseudo+0x65>
      swapped = 1 - swapped;
  807307:	b8 01 00 00 00       	mov    $0x1,%eax
  80730c:	29 d8                	sub    %ebx,%eax
  80730e:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  807310:	89 fa                	mov    %edi,%edx
  807312:	c1 e2 08             	shl    $0x8,%edx
  807315:	0f b7 d2             	movzwl %dx,%edx
  807318:	89 f8                	mov    %edi,%eax
  80731a:	0f b6 c4             	movzbl %ah,%eax
  80731d:	09 c2                	or     %eax,%edx
  80731f:	89 d7                	mov    %edx,%edi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807321:	8b 36                	mov    (%esi),%esi
  807323:	85 f6                	test   %esi,%esi
  807325:	75 bf                	jne    8072e6 <inet_chksum_pseudo+0x2a>
  807327:	89 d8                	mov    %ebx,%eax
  807329:	89 fb                	mov    %edi,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80732b:	84 c0                	test   %al,%al
  80732d:	74 0d                	je     80733c <inet_chksum_pseudo+0x80>
    acc = SWAP_BYTES_IN_WORD(acc);
  80732f:	89 f8                	mov    %edi,%eax
  807331:	c1 e0 08             	shl    $0x8,%eax
  807334:	0f b7 c0             	movzwl %ax,%eax
  807337:	0f b6 df             	movzbl %bh,%ebx
  80733a:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  80733c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80733f:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807341:	8b 45 10             	mov    0x10(%ebp),%eax
  807344:	8b 00                	mov    (%eax),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807346:	0f b7 ca             	movzwl %dx,%ecx
  807349:	c1 ea 10             	shr    $0x10,%edx
  80734c:	01 ca                	add    %ecx,%edx
  80734e:	0f b7 c8             	movzwl %ax,%ecx
  807351:	01 ca                	add    %ecx,%edx
  807353:	c1 e8 10             	shr    $0x10,%eax
  807356:	01 d0                	add    %edx,%eax
  807358:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  80735a:	83 ec 0c             	sub    $0xc,%esp
  80735d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807361:	50                   	push   %eax
  807362:	e8 6e 02 00 00       	call   8075d5 <htons>
  807367:	0f b7 c0             	movzwl %ax,%eax
  80736a:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  80736c:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807370:	89 04 24             	mov    %eax,(%esp)
  807373:	e8 5d 02 00 00       	call   8075d5 <htons>
  807378:	0f b7 c0             	movzwl %ax,%eax
  80737b:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80737d:	89 d8                	mov    %ebx,%eax
  80737f:	c1 e8 10             	shr    $0x10,%eax
  807382:	0f b7 db             	movzwl %bx,%ebx
  807385:	01 d8                	add    %ebx,%eax
  acc = FOLD_U32T(acc);
  807387:	89 c2                	mov    %eax,%edx
  807389:	c1 ea 10             	shr    $0x10,%edx
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80738c:	01 d0                	add    %edx,%eax
  80738e:	f7 d0                	not    %eax
}
  807390:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807393:	5b                   	pop    %ebx
  807394:	5e                   	pop    %esi
  807395:	5f                   	pop    %edi
  807396:	5d                   	pop    %ebp
  807397:	c3                   	ret    

00807398 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  807398:	55                   	push   %ebp
  807399:	89 e5                	mov    %esp,%ebp
  80739b:	57                   	push   %edi
  80739c:	56                   	push   %esi
  80739d:	53                   	push   %ebx
  80739e:	83 ec 1c             	sub    $0x1c,%esp
  8073a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8073a4:	8b 45 14             	mov    0x14(%ebp),%eax
  8073a7:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8073aa:	8b 45 18             	mov    0x18(%ebp),%eax
  8073ad:	89 45 d8             	mov    %eax,-0x28(%ebp)
  8073b0:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  8073b4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  8073b8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8073bf:	eb 6d                	jmp    80742e <inet_chksum_pseudo_partial+0x96>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  8073c1:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  8073c5:	66 39 fe             	cmp    %di,%si
  8073c8:	0f 46 fe             	cmovbe %esi,%edi
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  8073cb:	0f b7 d7             	movzwl %di,%edx
  8073ce:	8b 43 04             	mov    0x4(%ebx),%eax
  8073d1:	e8 5f fe ff ff       	call   807235 <lwip_standard_chksum>
  8073d6:	0f b7 c0             	movzwl %ax,%eax
  8073d9:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  8073dc:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  8073de:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  8073e3:	76 17                	jbe    8073fc <inet_chksum_pseudo_partial+0x64>
  8073e5:	83 ec 04             	sub    $0x4,%esp
  8073e8:	68 71 1d 81 00       	push   $0x811d71
  8073ed:	68 60 01 00 00       	push   $0x160
  8073f2:	68 7c 1d 81 00       	push   $0x811d7c
  8073f7:	e8 5c 6f 00 00       	call   80e358 <_panic>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  8073fc:	89 c2                	mov    %eax,%edx
  8073fe:	c1 ea 10             	shr    $0x10,%edx
  807401:	0f b7 c0             	movzwl %ax,%eax
  807404:	01 d0                	add    %edx,%eax
  807406:	89 c2                	mov    %eax,%edx
  807408:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  80740b:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80740f:	74 1b                	je     80742c <inet_chksum_pseudo_partial+0x94>
      swapped = 1 - swapped;
  807411:	b8 01 00 00 00       	mov    $0x1,%eax
  807416:	2a 45 e3             	sub    -0x1d(%ebp),%al
  807419:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80741c:	89 d0                	mov    %edx,%eax
  80741e:	c1 e2 08             	shl    $0x8,%edx
  807421:	0f b7 d2             	movzwl %dx,%edx
  807424:	0f b6 c4             	movzbl %ah,%eax
  807427:	09 c2                	or     %eax,%edx
  807429:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80742c:	8b 1b                	mov    (%ebx),%ebx
  80742e:	85 db                	test   %ebx,%ebx
  807430:	74 05                	je     807437 <inet_chksum_pseudo_partial+0x9f>
  807432:	66 85 f6             	test   %si,%si
  807435:	75 8a                	jne    8073c1 <inet_chksum_pseudo_partial+0x29>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807437:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80743b:	74 13                	je     807450 <inet_chksum_pseudo_partial+0xb8>
    acc = SWAP_BYTES_IN_WORD(acc);
  80743d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807440:	89 c8                	mov    %ecx,%eax
  807442:	c1 e0 08             	shl    $0x8,%eax
  807445:	0f b7 c0             	movzwl %ax,%eax
  807448:	0f b6 d5             	movzbl %ch,%edx
  80744b:	09 d0                	or     %edx,%eax
  80744d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  807450:	8b 45 0c             	mov    0xc(%ebp),%eax
  807453:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807455:	8b 45 10             	mov    0x10(%ebp),%eax
  807458:	8b 00                	mov    (%eax),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80745a:	0f b7 ca             	movzwl %dx,%ecx
  80745d:	c1 ea 10             	shr    $0x10,%edx
  807460:	01 ca                	add    %ecx,%edx
  807462:	0f b7 d8             	movzwl %ax,%ebx
  807465:	01 d3                	add    %edx,%ebx
  807467:	c1 e8 10             	shr    $0x10,%eax
  80746a:	01 c3                	add    %eax,%ebx
  80746c:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80746f:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons((u16_t)proto);
  807471:	83 ec 0c             	sub    $0xc,%esp
  807474:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807478:	50                   	push   %eax
  807479:	e8 57 01 00 00       	call   8075d5 <htons>
  80747e:	0f b7 d0             	movzwl %ax,%edx
  807481:	8d 1c 32             	lea    (%edx,%esi,1),%ebx
  acc += (u32_t)htons(proto_len);
  807484:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  807488:	89 04 24             	mov    %eax,(%esp)
  80748b:	e8 45 01 00 00       	call   8075d5 <htons>
  807490:	0f b7 d0             	movzwl %ax,%edx
  807493:	01 da                	add    %ebx,%edx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807495:	89 d0                	mov    %edx,%eax
  807497:	c1 e8 10             	shr    $0x10,%eax
  80749a:	0f b7 d2             	movzwl %dx,%edx
  80749d:	01 d0                	add    %edx,%eax
  acc = FOLD_U32T(acc);
  80749f:	89 c2                	mov    %eax,%edx
  8074a1:	c1 ea 10             	shr    $0x10,%edx
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8074a4:	01 d0                	add    %edx,%eax
  8074a6:	f7 d0                	not    %eax
}
  8074a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8074ab:	5b                   	pop    %ebx
  8074ac:	5e                   	pop    %esi
  8074ad:	5f                   	pop    %edi
  8074ae:	5d                   	pop    %ebp
  8074af:	c3                   	ret    

008074b0 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  8074b0:	55                   	push   %ebp
  8074b1:	89 e5                	mov    %esp,%ebp
  8074b3:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  8074b6:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  8074ba:	8b 45 08             	mov    0x8(%ebp),%eax
  8074bd:	e8 73 fd ff ff       	call   807235 <lwip_standard_chksum>
  8074c2:	f7 d0                	not    %eax
}
  8074c4:	c9                   	leave  
  8074c5:	c3                   	ret    

008074c6 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  8074c6:	55                   	push   %ebp
  8074c7:	89 e5                	mov    %esp,%ebp
  8074c9:	57                   	push   %edi
  8074ca:	56                   	push   %esi
  8074cb:	53                   	push   %ebx
  8074cc:	83 ec 0c             	sub    $0xc,%esp
  8074cf:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8074d2:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  8074d7:	bb 00 00 00 00       	mov    $0x0,%ebx
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  8074dc:	eb 3b                	jmp    807519 <inet_chksum_pbuf+0x53>
    acc += LWIP_CHKSUM(q->payload, q->len);
  8074de:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8074e2:	8b 46 04             	mov    0x4(%esi),%eax
  8074e5:	e8 4b fd ff ff       	call   807235 <lwip_standard_chksum>
  8074ea:	0f b7 c0             	movzwl %ax,%eax
  8074ed:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  8074ef:	89 d8                	mov    %ebx,%eax
  8074f1:	c1 e8 10             	shr    $0x10,%eax
  8074f4:	0f b7 db             	movzwl %bx,%ebx
  8074f7:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  8074f9:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  8074fd:	74 18                	je     807517 <inet_chksum_pbuf+0x51>
      swapped = 1 - swapped;
  8074ff:	b8 01 00 00 00       	mov    $0x1,%eax
  807504:	89 f9                	mov    %edi,%ecx
  807506:	29 c8                	sub    %ecx,%eax
  807508:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80750a:	89 da                	mov    %ebx,%edx
  80750c:	c1 e2 08             	shl    $0x8,%edx
  80750f:	0f b7 d2             	movzwl %dx,%edx
  807512:	0f b6 df             	movzbl %bh,%ebx
  807515:	09 d3                	or     %edx,%ebx
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807517:	8b 36                	mov    (%esi),%esi
  807519:	85 f6                	test   %esi,%esi
  80751b:	75 c1                	jne    8074de <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  80751d:	89 f8                	mov    %edi,%eax
  80751f:	84 c0                	test   %al,%al
  807521:	74 0d                	je     807530 <inet_chksum_pbuf+0x6a>
    acc = SWAP_BYTES_IN_WORD(acc);
  807523:	89 da                	mov    %ebx,%edx
  807525:	c1 e2 08             	shl    $0x8,%edx
  807528:	0f b7 d2             	movzwl %dx,%edx
  80752b:	0f b6 df             	movzbl %bh,%ebx
  80752e:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  807530:	89 d8                	mov    %ebx,%eax
  807532:	f7 d0                	not    %eax
}
  807534:	83 c4 0c             	add    $0xc,%esp
  807537:	5b                   	pop    %ebx
  807538:	5e                   	pop    %esi
  807539:	5f                   	pop    %edi
  80753a:	5d                   	pop    %ebp
  80753b:	c3                   	ret    

0080753c <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80753c:	55                   	push   %ebp
  80753d:	89 e5                	mov    %esp,%ebp
  80753f:	57                   	push   %edi
  807540:	56                   	push   %esi
  807541:	53                   	push   %ebx
  807542:	83 ec 14             	sub    $0x14,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807545:	8b 45 08             	mov    0x8(%ebp),%eax
  807548:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  80754b:	8d 7d f0             	lea    -0x10(%ebp),%edi
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  80754e:	c7 45 e0 e4 49 b3 00 	movl   $0xb349e4,-0x20(%ebp)
  807555:	0f b6 0f             	movzbl (%edi),%ecx
  807558:	ba 00 00 00 00       	mov    $0x0,%edx
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80755d:	0f b6 d9             	movzbl %cl,%ebx
  807560:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  807563:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
  807566:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807569:	66 c1 e8 0b          	shr    $0xb,%ax
  80756d:	89 c3                	mov    %eax,%ebx
  80756f:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807572:	01 c0                	add    %eax,%eax
  807574:	29 c1                	sub    %eax,%ecx
  807576:	89 c8                	mov    %ecx,%eax
      *ap /= (u8_t)10;
  807578:	89 d9                	mov    %ebx,%ecx
      inv[i++] = '0' + rem;
  80757a:	8d 72 01             	lea    0x1(%edx),%esi
  80757d:	0f b6 d2             	movzbl %dl,%edx
  807580:	83 c0 30             	add    $0x30,%eax
  807583:	88 44 15 ed          	mov    %al,-0x13(%ebp,%edx,1)
  807587:	89 f2                	mov    %esi,%edx
    } while(*ap);
  807589:	84 db                	test   %bl,%bl
  80758b:	75 d0                	jne    80755d <inet_ntoa+0x21>
  80758d:	c6 07 00             	movb   $0x0,(%edi)
  807590:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  807593:	eb 0d                	jmp    8075a2 <inet_ntoa+0x66>
    while(i--)
      *rp++ = inv[i];
  807595:	0f b6 c2             	movzbl %dl,%eax
  807598:	0f b6 44 05 ed       	movzbl -0x13(%ebp,%eax,1),%eax
  80759d:	88 01                	mov    %al,(%ecx)
  80759f:	83 c1 01             	add    $0x1,%ecx
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  8075a2:	83 ea 01             	sub    $0x1,%edx
  8075a5:	80 fa ff             	cmp    $0xff,%dl
  8075a8:	75 eb                	jne    807595 <inet_ntoa+0x59>
  8075aa:	89 f0                	mov    %esi,%eax
  8075ac:	0f b6 f0             	movzbl %al,%esi
  8075af:	03 75 e0             	add    -0x20(%ebp),%esi
      *rp++ = inv[i];
    *rp++ = '.';
  8075b2:	8d 46 01             	lea    0x1(%esi),%eax
  8075b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8075b8:	c6 06 2e             	movb   $0x2e,(%esi)
    ap++;
  8075bb:	83 c7 01             	add    $0x1,%edi
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  8075be:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8075c1:	39 c7                	cmp    %eax,%edi
  8075c3:	75 90                	jne    807555 <inet_ntoa+0x19>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  8075c5:	c6 06 00             	movb   $0x0,(%esi)
  return str;
}
  8075c8:	b8 e4 49 b3 00       	mov    $0xb349e4,%eax
  8075cd:	83 c4 14             	add    $0x14,%esp
  8075d0:	5b                   	pop    %ebx
  8075d1:	5e                   	pop    %esi
  8075d2:	5f                   	pop    %edi
  8075d3:	5d                   	pop    %ebp
  8075d4:	c3                   	ret    

008075d5 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  8075d5:	55                   	push   %ebp
  8075d6:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  8075d8:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8075dc:	66 c1 c0 08          	rol    $0x8,%ax
}
  8075e0:	5d                   	pop    %ebp
  8075e1:	c3                   	ret    

008075e2 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  8075e2:	55                   	push   %ebp
  8075e3:	89 e5                	mov    %esp,%ebp
  return htons(n);
  8075e5:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8075e9:	66 c1 c0 08          	rol    $0x8,%ax
}
  8075ed:	5d                   	pop    %ebp
  8075ee:	c3                   	ret    

008075ef <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  8075ef:	55                   	push   %ebp
  8075f0:	89 e5                	mov    %esp,%ebp
  8075f2:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  8075f5:	89 d1                	mov    %edx,%ecx
  8075f7:	c1 e1 18             	shl    $0x18,%ecx
  8075fa:	89 d0                	mov    %edx,%eax
  8075fc:	c1 e8 18             	shr    $0x18,%eax
  8075ff:	09 c8                	or     %ecx,%eax
  807601:	89 d1                	mov    %edx,%ecx
  807603:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  807609:	c1 e1 08             	shl    $0x8,%ecx
  80760c:	09 c8                	or     %ecx,%eax
  80760e:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  807614:	c1 ea 08             	shr    $0x8,%edx
  807617:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  807619:	5d                   	pop    %ebp
  80761a:	c3                   	ret    

0080761b <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  80761b:	55                   	push   %ebp
  80761c:	89 e5                	mov    %esp,%ebp
  80761e:	57                   	push   %edi
  80761f:	56                   	push   %esi
  807620:	53                   	push   %ebx
  807621:	83 ec 20             	sub    $0x20,%esp
  807624:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  807627:	0f be 10             	movsbl (%eax),%edx
inet_aton(const char *cp, struct in_addr *addr)
{
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  80762a:	8d 5d e4             	lea    -0x1c(%ebp),%ebx
  80762d:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  807630:	0f b6 ca             	movzbl %dl,%ecx
  807633:	83 e9 30             	sub    $0x30,%ecx
  807636:	83 f9 09             	cmp    $0x9,%ecx
  807639:	0f 87 94 01 00 00    	ja     8077d3 <inet_aton+0x1b8>
      return (0);
    val = 0;
    base = 10;
  80763f:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
    if (c == '0') {
  807646:	83 fa 30             	cmp    $0x30,%edx
  807649:	75 2b                	jne    807676 <inet_aton+0x5b>
      c = *++cp;
  80764b:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  80764f:	89 d1                	mov    %edx,%ecx
  807651:	83 e1 df             	and    $0xffffffdf,%ecx
  807654:	80 f9 58             	cmp    $0x58,%cl
  807657:	74 0f                	je     807668 <inet_aton+0x4d>
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
  807659:	83 c0 01             	add    $0x1,%eax
  80765c:	0f be d2             	movsbl %dl,%edx
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
      } else
        base = 8;
  80765f:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  807666:	eb 0e                	jmp    807676 <inet_aton+0x5b>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
  807668:	0f be 50 02          	movsbl 0x2(%eax),%edx
  80766c:	8d 40 02             	lea    0x2(%eax),%eax
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
  80766f:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
  807676:	83 c0 01             	add    $0x1,%eax
  807679:	be 00 00 00 00       	mov    $0x0,%esi
  80767e:	eb 03                	jmp    807683 <inet_aton+0x68>
  807680:	83 c0 01             	add    $0x1,%eax
  807683:	8d 58 ff             	lea    -0x1(%eax),%ebx
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  807686:	89 55 e0             	mov    %edx,-0x20(%ebp)
  807689:	0f b6 fa             	movzbl %dl,%edi
  80768c:	8d 4f d0             	lea    -0x30(%edi),%ecx
  80768f:	83 f9 09             	cmp    $0x9,%ecx
  807692:	77 0d                	ja     8076a1 <inet_aton+0x86>
        val = (val * base) + (int)(c - '0');
  807694:	0f af 75 dc          	imul   -0x24(%ebp),%esi
  807698:	8d 74 32 d0          	lea    -0x30(%edx,%esi,1),%esi
        c = *++cp;
  80769c:	0f be 10             	movsbl (%eax),%edx
  80769f:	eb df                	jmp    807680 <inet_aton+0x65>
      } else if (base == 16 && isxdigit(c)) {
  8076a1:	83 7d dc 10          	cmpl   $0x10,-0x24(%ebp)
  8076a5:	75 32                	jne    8076d9 <inet_aton+0xbe>
  8076a7:	8d 4f 9f             	lea    -0x61(%edi),%ecx
  8076aa:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  8076ad:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8076b0:	81 e1 df 00 00 00    	and    $0xdf,%ecx
  8076b6:	83 e9 41             	sub    $0x41,%ecx
  8076b9:	83 f9 05             	cmp    $0x5,%ecx
  8076bc:	77 1b                	ja     8076d9 <inet_aton+0xbe>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  8076be:	c1 e6 04             	shl    $0x4,%esi
  8076c1:	83 c2 0a             	add    $0xa,%edx
  8076c4:	83 7d d8 1a          	cmpl   $0x1a,-0x28(%ebp)
  8076c8:	19 c9                	sbb    %ecx,%ecx
  8076ca:	83 e1 20             	and    $0x20,%ecx
  8076cd:	83 c1 41             	add    $0x41,%ecx
  8076d0:	29 ca                	sub    %ecx,%edx
  8076d2:	09 d6                	or     %edx,%esi
        c = *++cp;
  8076d4:	0f be 10             	movsbl (%eax),%edx
  8076d7:	eb a7                	jmp    807680 <inet_aton+0x65>
      } else
        break;
    }
    if (c == '.') {
  8076d9:	83 fa 2e             	cmp    $0x2e,%edx
  8076dc:	75 23                	jne    807701 <inet_aton+0xe6>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  8076de:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8076e1:	8d 7d f0             	lea    -0x10(%ebp),%edi
  8076e4:	39 f8                	cmp    %edi,%eax
  8076e6:	0f 84 ee 00 00 00    	je     8077da <inet_aton+0x1bf>
        return (0);
      *pp++ = val;
  8076ec:	83 c0 04             	add    $0x4,%eax
  8076ef:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8076f2:	89 70 fc             	mov    %esi,-0x4(%eax)
      c = *++cp;
  8076f5:	8d 43 01             	lea    0x1(%ebx),%eax
  8076f8:	0f be 53 01          	movsbl 0x1(%ebx),%edx
    } else
      break;
  }
  8076fc:	e9 2f ff ff ff       	jmp    807630 <inet_aton+0x15>
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807701:	85 d2                	test   %edx,%edx
  807703:	74 25                	je     80772a <inet_aton+0x10f>
  807705:	8d 4f e0             	lea    -0x20(%edi),%ecx
    return (0);
  807708:	b8 00 00 00 00       	mov    $0x0,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80770d:	83 f9 5f             	cmp    $0x5f,%ecx
  807710:	0f 87 d0 00 00 00    	ja     8077e6 <inet_aton+0x1cb>
  807716:	83 fa 20             	cmp    $0x20,%edx
  807719:	74 0f                	je     80772a <inet_aton+0x10f>
  80771b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80771e:	83 ea 09             	sub    $0x9,%edx
  807721:	83 fa 04             	cmp    $0x4,%edx
  807724:	0f 87 bc 00 00 00    	ja     8077e6 <inet_aton+0x1cb>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  80772a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80772d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807730:	29 c2                	sub    %eax,%edx
  807732:	c1 fa 02             	sar    $0x2,%edx
  807735:	83 c2 01             	add    $0x1,%edx
  807738:	83 fa 02             	cmp    $0x2,%edx
  80773b:	74 20                	je     80775d <inet_aton+0x142>
  80773d:	83 fa 02             	cmp    $0x2,%edx
  807740:	7f 0f                	jg     807751 <inet_aton+0x136>

  case 0:
    return (0);       /* initial nondigit */
  807742:	b8 00 00 00 00       	mov    $0x0,%eax
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  807747:	85 d2                	test   %edx,%edx
  807749:	0f 84 97 00 00 00    	je     8077e6 <inet_aton+0x1cb>
  80774f:	eb 67                	jmp    8077b8 <inet_aton+0x19d>
  807751:	83 fa 03             	cmp    $0x3,%edx
  807754:	74 1e                	je     807774 <inet_aton+0x159>
  807756:	83 fa 04             	cmp    $0x4,%edx
  807759:	74 38                	je     807793 <inet_aton+0x178>
  80775b:	eb 5b                	jmp    8077b8 <inet_aton+0x19d>
  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
      return (0);
  80775d:	b8 00 00 00 00       	mov    $0x0,%eax

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  807762:	81 fe ff ff ff 00    	cmp    $0xffffff,%esi
  807768:	77 7c                	ja     8077e6 <inet_aton+0x1cb>
      return (0);
    val |= parts[0] << 24;
  80776a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80776d:	c1 e0 18             	shl    $0x18,%eax
  807770:	09 c6                	or     %eax,%esi
    break;
  807772:	eb 44                	jmp    8077b8 <inet_aton+0x19d>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
      return (0);
  807774:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= parts[0] << 24;
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  807779:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  80777f:	77 65                	ja     8077e6 <inet_aton+0x1cb>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  807781:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807784:	c1 e2 18             	shl    $0x18,%edx
  807787:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80778a:	c1 e0 10             	shl    $0x10,%eax
  80778d:	09 d0                	or     %edx,%eax
  80778f:	09 c6                	or     %eax,%esi
    break;
  807791:	eb 25                	jmp    8077b8 <inet_aton+0x19d>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
      return (0);
  807793:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  807798:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  80779e:	77 46                	ja     8077e6 <inet_aton+0x1cb>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  8077a0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8077a3:	c1 e2 18             	shl    $0x18,%edx
  8077a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8077a9:	c1 e0 10             	shl    $0x10,%eax
  8077ac:	09 c2                	or     %eax,%edx
  8077ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8077b1:	c1 e0 08             	shl    $0x8,%eax
  8077b4:	09 d0                	or     %edx,%eax
  8077b6:	09 c6                	or     %eax,%esi
    break;
  }
  if (addr)
  8077b8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8077bc:	74 23                	je     8077e1 <inet_aton+0x1c6>
    addr->s_addr = htonl(val);
  8077be:	56                   	push   %esi
  8077bf:	e8 2b fe ff ff       	call   8075ef <htonl>
  8077c4:	83 c4 04             	add    $0x4,%esp
  8077c7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8077ca:	89 03                	mov    %eax,(%ebx)
  return (1);
  8077cc:	b8 01 00 00 00       	mov    $0x1,%eax
  8077d1:	eb 13                	jmp    8077e6 <inet_aton+0x1cb>
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
  8077d3:	b8 00 00 00 00       	mov    $0x0,%eax
  8077d8:	eb 0c                	jmp    8077e6 <inet_aton+0x1cb>
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
  8077da:	b8 00 00 00 00       	mov    $0x0,%eax
  8077df:	eb 05                	jmp    8077e6 <inet_aton+0x1cb>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
    addr->s_addr = htonl(val);
  return (1);
  8077e1:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8077e6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8077e9:	5b                   	pop    %ebx
  8077ea:	5e                   	pop    %esi
  8077eb:	5f                   	pop    %edi
  8077ec:	5d                   	pop    %ebp
  8077ed:	c3                   	ret    

008077ee <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  8077ee:	55                   	push   %ebp
  8077ef:	89 e5                	mov    %esp,%ebp
  8077f1:	83 ec 10             	sub    $0x10,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  8077f4:	8d 45 fc             	lea    -0x4(%ebp),%eax
  8077f7:	50                   	push   %eax
  8077f8:	ff 75 08             	pushl  0x8(%ebp)
  8077fb:	e8 1b fe ff ff       	call   80761b <inet_aton>
  807800:	83 c4 08             	add    $0x8,%esp
    return (val.s_addr);
  807803:	85 c0                	test   %eax,%eax
  807805:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80780a:	0f 45 45 fc          	cmovne -0x4(%ebp),%eax
  }
  return (INADDR_NONE);
}
  80780e:	c9                   	leave  
  80780f:	c3                   	ret    

00807810 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807810:	55                   	push   %ebp
  807811:	89 e5                	mov    %esp,%ebp
  return htonl(n);
  807813:	ff 75 08             	pushl  0x8(%ebp)
  807816:	e8 d4 fd ff ff       	call   8075ef <htonl>
  80781b:	83 c4 04             	add    $0x4,%esp
}
  80781e:	c9                   	leave  
  80781f:	c3                   	ret    

00807820 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807820:	55                   	push   %ebp
  807821:	89 e5                	mov    %esp,%ebp
  807823:	57                   	push   %edi
  807824:	56                   	push   %esi
  807825:	53                   	push   %ebx
  807826:	83 ec 3c             	sub    $0x3c,%esp
  807829:	8b 7d 08             	mov    0x8(%ebp),%edi
  80782c:	8b 45 10             	mov    0x10(%ebp),%eax
  80782f:	89 c6                	mov    %eax,%esi
  807831:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  807834:	8b 45 14             	mov    0x14(%ebp),%eax
  807837:	89 c2                	mov    %eax,%edx
  807839:	89 45 bc             	mov    %eax,-0x44(%ebp)
  80783c:	8b 45 18             	mov    0x18(%ebp),%eax
  80783f:	89 c3                	mov    %eax,%ebx
  807841:	89 45 b8             	mov    %eax,-0x48(%ebp)
  807844:	8b 45 20             	mov    0x20(%ebp),%eax
  807847:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  80784b:	88 55 dd             	mov    %dl,-0x23(%ebp)
  80784e:	89 da                	mov    %ebx,%edx
  807850:	88 45 dc             	mov    %al,-0x24(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807853:	66 85 f6             	test   %si,%si
  807856:	74 1b                	je     807873 <tcp_enqueue+0x53>
  807858:	84 c0                	test   %al,%al
  80785a:	74 17                	je     807873 <tcp_enqueue+0x53>
  80785c:	83 ec 04             	sub    $0x4,%esp
  80785f:	68 a0 1d 81 00       	push   $0x811da0
  807864:	68 90 00 00 00       	push   $0x90
  807869:	68 42 1f 81 00       	push   $0x811f42
  80786e:	e8 e5 6a 00 00       	call   80e358 <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807873:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807877:	74 1d                	je     807896 <tcp_enqueue+0x76>
  807879:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80787d:	74 17                	je     807896 <tcp_enqueue+0x76>
  80787f:	83 ec 04             	sub    $0x4,%esp
  807882:	68 e0 1d 81 00       	push   $0x811de0
  807887:	68 92 00 00 00       	push   $0x92
  80788c:	68 42 1f 81 00       	push   $0x811f42
  807891:	e8 c2 6a 00 00       	call   80e358 <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  807896:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  80789a:	66 3b 4f 6e          	cmp    0x6e(%edi),%cx
  80789e:	76 0e                	jbe    8078ae <tcp_enqueue+0x8e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  8078a0:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8078a4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8078a9:	e9 d1 05 00 00       	jmp    807e7f <tcp_enqueue+0x65f>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  8078ae:	8b 4f 68             	mov    0x68(%edi),%ecx
  8078b1:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  8078b4:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  8078b8:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  8078bc:	66 83 f9 1f          	cmp    $0x1f,%cx
  8078c0:	76 0e                	jbe    8078d0 <tcp_enqueue+0xb0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  8078c2:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8078c6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8078cb:	e9 af 05 00 00       	jmp    807e7f <tcp_enqueue+0x65f>
  }
  if (queuelen != 0) {
  8078d0:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  8078d5:	74 23                	je     8078fa <tcp_enqueue+0xda>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  8078d7:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8078db:	75 29                	jne    807906 <tcp_enqueue+0xe6>
  8078dd:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8078e1:	75 23                	jne    807906 <tcp_enqueue+0xe6>
  8078e3:	83 ec 04             	sub    $0x4,%esp
  8078e6:	68 28 1e 81 00       	push   $0x811e28
  8078eb:	68 ae 00 00 00       	push   $0xae
  8078f0:	68 42 1f 81 00       	push   $0x811f42
  8078f5:	e8 5e 6a 00 00       	call   80e358 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  8078fa:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8078fe:	75 41                	jne    807941 <tcp_enqueue+0x121>
  807900:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807904:	75 3b                	jne    807941 <tcp_enqueue+0x121>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807906:	c0 e8 02             	shr    $0x2,%al
  807909:	c1 e0 0c             	shl    $0xc,%eax
  80790c:	66 05 00 50          	add    $0x5000,%ax
  807910:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
  807914:	8b 45 0c             	mov    0xc(%ebp),%eax
  807917:	89 45 cc             	mov    %eax,-0x34(%ebp)
  80791a:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  80791e:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  807922:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
  807926:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  80792d:	be 00 00 00 00       	mov    $0x0,%esi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807932:	83 e2 01             	and    $0x1,%edx
  807935:	88 55 c9             	mov    %dl,-0x37(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807938:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  80793c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80793f:	eb 17                	jmp    807958 <tcp_enqueue+0x138>
  }
  if (queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807941:	83 ec 04             	sub    $0x4,%esp
  807944:	68 64 1e 81 00       	push   $0x811e64
  807949:	68 b1 00 00 00       	push   $0xb1
  80794e:	68 42 1f 81 00       	push   $0x811f42
  807953:	e8 00 6a 00 00       	call   80e358 <_panic>
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  807958:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  80795c:	66 39 47 34          	cmp    %ax,0x34(%edi)
  807960:	66 0f 46 47 34       	cmovbe 0x34(%edi),%ax
  807965:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  807969:	83 ec 0c             	sub    $0xc,%esp
  80796c:	6a 04                	push   $0x4
  80796e:	e8 e8 c9 ff ff       	call   80435b <memp_malloc>
  807973:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807975:	83 c4 10             	add    $0x10,%esp
  807978:	85 c0                	test   %eax,%eax
  80797a:	0f 84 91 04 00 00    	je     807e11 <tcp_enqueue+0x5f1>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  807980:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807986:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  80798d:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  807991:	75 1f                	jne    8079b2 <tcp_enqueue+0x192>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807993:	85 f6                	test   %esi,%esi
  807995:	75 17                	jne    8079ae <tcp_enqueue+0x18e>
  807997:	83 ec 04             	sub    $0x4,%esp
  80799a:	68 5a 1f 81 00       	push   $0x811f5a
  80799f:	68 ce 00 00 00       	push   $0xce
  8079a4:	68 42 1f 81 00       	push   $0x811f42
  8079a9:	e8 aa 69 00 00       	call   80e358 <_panic>
      useg->next = seg;
  8079ae:	89 06                	mov    %eax,(%esi)
  8079b0:	eb 03                	jmp    8079b5 <tcp_enqueue+0x195>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  8079b2:	89 45 d0             	mov    %eax,-0x30(%ebp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  8079b5:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8079b9:	74 5f                	je     807a1a <tcp_enqueue+0x1fa>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  8079bb:	83 ec 04             	sub    $0x4,%esp
  8079be:	6a 00                	push   $0x0
  8079c0:	ff 75 d4             	pushl  -0x2c(%ebp)
  8079c3:	6a 00                	push   $0x0
  8079c5:	e8 20 ce ff ff       	call   8047ea <pbuf_alloc>
  8079ca:	89 43 04             	mov    %eax,0x4(%ebx)
  8079cd:	83 c4 10             	add    $0x10,%esp
  8079d0:	85 c0                	test   %eax,%eax
  8079d2:	0f 84 39 04 00 00    	je     807e11 <tcp_enqueue+0x5f1>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  8079d8:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
  8079dc:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  8079e0:	73 17                	jae    8079f9 <tcp_enqueue+0x1d9>
  8079e2:	83 ec 04             	sub    $0x4,%esp
  8079e5:	68 98 1e 81 00       	push   $0x811e98
  8079ea:	68 df 00 00 00       	push   $0xdf
  8079ef:	68 42 1f 81 00       	push   $0x811f42
  8079f4:	e8 5f 69 00 00       	call   80e358 <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  8079f9:	83 ec 0c             	sub    $0xc,%esp
  8079fc:	50                   	push   %eax
  8079fd:	e8 81 d1 ff ff       	call   804b83 <pbuf_clen>
  807a02:	0f b6 c0             	movzbl %al,%eax
  807a05:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807a09:	8b 43 04             	mov    0x4(%ebx),%eax
  807a0c:	8b 40 04             	mov    0x4(%eax),%eax
  807a0f:	89 43 08             	mov    %eax,0x8(%ebx)
  807a12:	83 c4 10             	add    $0x10,%esp
  807a15:	e9 00 01 00 00       	jmp    807b1a <tcp_enqueue+0x2fa>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807a1a:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807a1e:	74 7c                	je     807a9c <tcp_enqueue+0x27c>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807a20:	83 ec 04             	sub    $0x4,%esp
  807a23:	6a 00                	push   $0x0
  807a25:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807a29:	0f b7 c6             	movzwl %si,%eax
  807a2c:	50                   	push   %eax
  807a2d:	6a 00                	push   $0x0
  807a2f:	e8 b6 cd ff ff       	call   8047ea <pbuf_alloc>
  807a34:	89 43 04             	mov    %eax,0x4(%ebx)
  807a37:	83 c4 10             	add    $0x10,%esp
  807a3a:	85 c0                	test   %eax,%eax
  807a3c:	0f 84 cf 03 00 00    	je     807e11 <tcp_enqueue+0x5f1>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807a42:	66 3b 70 0a          	cmp    0xa(%eax),%si
  807a46:	76 17                	jbe    807a5f <tcp_enqueue+0x23f>
  807a48:	83 ec 04             	sub    $0x4,%esp
  807a4b:	68 c0 1e 81 00       	push   $0x811ec0
  807a50:	68 ea 00 00 00       	push   $0xea
  807a55:	68 42 1f 81 00       	push   $0x811f42
  807a5a:	e8 f9 68 00 00       	call   80e358 <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  807a5f:	83 ec 0c             	sub    $0xc,%esp
  807a62:	50                   	push   %eax
  807a63:	e8 1b d1 ff ff       	call   804b83 <pbuf_clen>
  807a68:	0f b6 c0             	movzbl %al,%eax
  807a6b:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807a6f:	83 c4 10             	add    $0x10,%esp
  807a72:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807a76:	74 19                	je     807a91 <tcp_enqueue+0x271>
        MEMCPY(seg->p->payload, ptr, seglen);
  807a78:	83 ec 04             	sub    $0x4,%esp
  807a7b:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807a7f:	50                   	push   %eax
  807a80:	ff 75 cc             	pushl  -0x34(%ebp)
  807a83:	8b 43 04             	mov    0x4(%ebx),%eax
  807a86:	ff 70 04             	pushl  0x4(%eax)
  807a89:	e8 22 71 00 00       	call   80ebb0 <memcpy>
  807a8e:	83 c4 10             	add    $0x10,%esp
      }
      seg->dataptr = seg->p->payload;
  807a91:	8b 43 04             	mov    0x4(%ebx),%eax
  807a94:	8b 40 04             	mov    0x4(%eax),%eax
  807a97:	89 43 08             	mov    %eax,0x8(%ebx)
  807a9a:	eb 7e                	jmp    807b1a <tcp_enqueue+0x2fa>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  807a9c:	83 ec 04             	sub    $0x4,%esp
  807a9f:	6a 01                	push   $0x1
  807aa1:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807aa5:	50                   	push   %eax
  807aa6:	6a 00                	push   $0x0
  807aa8:	e8 3d cd ff ff       	call   8047ea <pbuf_alloc>
  807aad:	89 c6                	mov    %eax,%esi
  807aaf:	83 c4 10             	add    $0x10,%esp
  807ab2:	85 c0                	test   %eax,%eax
  807ab4:	0f 84 57 03 00 00    	je     807e11 <tcp_enqueue+0x5f1>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
  807aba:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807abe:	83 c0 01             	add    $0x1,%eax
  807ac1:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  807ac5:	8b 45 cc             	mov    -0x34(%ebp),%eax
  807ac8:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  807acb:	89 43 08             	mov    %eax,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  807ace:	83 ec 04             	sub    $0x4,%esp
  807ad1:	6a 00                	push   $0x0
  807ad3:	6a 00                	push   $0x0
  807ad5:	6a 00                	push   $0x0
  807ad7:	e8 0e cd ff ff       	call   8047ea <pbuf_alloc>
  807adc:	89 43 04             	mov    %eax,0x4(%ebx)
  807adf:	83 c4 10             	add    $0x10,%esp
  807ae2:	85 c0                	test   %eax,%eax
  807ae4:	75 11                	jne    807af7 <tcp_enqueue+0x2d7>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  807ae6:	83 ec 0c             	sub    $0xc,%esp
  807ae9:	56                   	push   %esi
  807aea:	e8 35 cc ff ff       	call   804724 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  807aef:	83 c4 10             	add    $0x10,%esp
  807af2:	e9 1a 03 00 00       	jmp    807e11 <tcp_enqueue+0x5f1>
      }
      queuelen += pbuf_clen(seg->p);
  807af7:	83 ec 0c             	sub    $0xc,%esp
  807afa:	50                   	push   %eax
  807afb:	e8 83 d0 ff ff       	call   804b83 <pbuf_clen>
  807b00:	0f b6 c0             	movzbl %al,%eax
  807b03:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  807b07:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  807b0b:	83 c4 08             	add    $0x8,%esp
  807b0e:	56                   	push   %esi
  807b0f:	ff 73 04             	pushl  0x4(%ebx)
  807b12:	e8 95 d0 ff ff       	call   804bac <pbuf_cat>
  807b17:	83 c4 10             	add    $0x10,%esp
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807b1a:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807b1f:	0f 87 ec 02 00 00    	ja     807e11 <tcp_enqueue+0x5f1>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  807b25:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807b29:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807b2d:	83 ec 08             	sub    $0x8,%esp
  807b30:	6a 14                	push   $0x14
  807b32:	ff 73 04             	pushl  0x4(%ebx)
  807b35:	e8 18 cb ff ff       	call   804652 <pbuf_header>
  807b3a:	83 c4 10             	add    $0x10,%esp
  807b3d:	84 c0                	test   %al,%al
  807b3f:	0f 85 cc 02 00 00    	jne    807e11 <tcp_enqueue+0x5f1>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  807b45:	8b 43 04             	mov    0x4(%ebx),%eax
  807b48:	8b 70 04             	mov    0x4(%eax),%esi
  807b4b:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807b4e:	83 ec 0c             	sub    $0xc,%esp
  807b51:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807b55:	50                   	push   %eax
  807b56:	e8 7a fa ff ff       	call   8075d5 <htons>
  807b5b:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807b5e:	8b 73 10             	mov    0x10(%ebx),%esi
  807b61:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807b65:	89 04 24             	mov    %eax,(%esp)
  807b68:	e8 68 fa ff ff       	call   8075d5 <htons>
  807b6d:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807b71:	8b 73 10             	mov    0x10(%ebx),%esi
  807b74:	83 c4 04             	add    $0x4,%esp
  807b77:	ff 75 d8             	pushl  -0x28(%ebp)
  807b7a:	e8 70 fa ff ff       	call   8075ef <htonl>
  807b7f:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807b82:	8b 43 10             	mov    0x10(%ebx),%eax
  807b85:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807b8b:	8b 73 10             	mov    0x10(%ebx),%esi
  807b8e:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807b92:	89 04 24             	mov    %eax,(%esp)
  807b95:	e8 48 fa ff ff       	call   8075e2 <ntohs>
  807b9a:	83 e0 c0             	and    $0xffffffc0,%eax
  807b9d:	0f b6 55 dd          	movzbl -0x23(%ebp),%edx
  807ba1:	09 d0                	or     %edx,%eax
  807ba3:	0f b7 c0             	movzwl %ax,%eax
  807ba6:	89 04 24             	mov    %eax,(%esp)
  807ba9:	e8 27 fa ff ff       	call   8075d5 <htons>
  807bae:	66 89 46 0c          	mov    %ax,0xc(%esi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  807bb2:	83 c4 10             	add    $0x10,%esp
  807bb5:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807bb9:	75 27                	jne    807be2 <tcp_enqueue+0x3c2>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  807bbb:	8b 73 10             	mov    0x10(%ebx),%esi
  807bbe:	83 ec 0c             	sub    $0xc,%esp
  807bc1:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807bc5:	50                   	push   %eax
  807bc6:	e8 17 fa ff ff       	call   8075e2 <ntohs>
  807bcb:	83 e0 3f             	and    $0x3f,%eax
  807bce:	80 cc 50             	or     $0x50,%ah
  807bd1:	89 04 24             	mov    %eax,(%esp)
  807bd4:	e8 fc f9 ff ff       	call   8075d5 <htons>
  807bd9:	66 89 46 0c          	mov    %ax,0xc(%esi)
  807bdd:	83 c4 10             	add    $0x10,%esp
  807be0:	eb 3a                	jmp    807c1c <tcp_enqueue+0x3fc>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807be2:	8b 73 10             	mov    0x10(%ebx),%esi
  807be5:	83 ec 0c             	sub    $0xc,%esp
  807be8:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807bec:	50                   	push   %eax
  807bed:	e8 f0 f9 ff ff       	call   8075e2 <ntohs>
  807bf2:	83 e0 3f             	and    $0x3f,%eax
  807bf5:	66 0b 45 ca          	or     -0x36(%ebp),%ax
  807bf9:	0f b7 c0             	movzwl %ax,%eax
  807bfc:	89 04 24             	mov    %eax,(%esp)
  807bff:	e8 d1 f9 ff ff       	call   8075d5 <htons>
  807c04:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807c08:	83 c4 0c             	add    $0xc,%esp
  807c0b:	ff 75 d4             	pushl  -0x2c(%ebp)
  807c0e:	ff 75 1c             	pushl  0x1c(%ebp)
  807c11:	ff 73 08             	pushl  0x8(%ebx)
  807c14:	e8 97 6f 00 00       	call   80ebb0 <memcpy>
  807c19:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807c1c:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  807c20:	0f b7 c1             	movzwl %cx,%eax
  807c23:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807c26:	01 45 cc             	add    %eax,-0x34(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  807c29:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  807c2d:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807c31:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  807c35:	89 de                	mov    %ebx,%esi

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  807c37:	66 29 4d de          	sub    %cx,-0x22(%ebp)
  807c3b:	0f 85 17 fd ff ff    	jne    807958 <tcp_enqueue+0x138>
  807c41:	84 c0                	test   %al,%al
  807c43:	0f 85 0f fd ff ff    	jne    807958 <tcp_enqueue+0x138>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807c49:	8b 77 74             	mov    0x74(%edi),%esi
  807c4c:	85 f6                	test   %esi,%esi
  807c4e:	75 07                	jne    807c57 <tcp_enqueue+0x437>
  807c50:	e9 ff 00 00 00       	jmp    807d54 <tcp_enqueue+0x534>
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807c55:	89 c6                	mov    %eax,%esi
  807c57:	8b 06                	mov    (%esi),%eax
  807c59:	85 c0                	test   %eax,%eax
  807c5b:	75 f8                	jne    807c55 <tcp_enqueue+0x435>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  807c5d:	85 f6                	test   %esi,%esi
  807c5f:	0f 84 ef 00 00 00    	je     807d54 <tcp_enqueue+0x534>
    TCP_TCPLEN(useg) != 0 &&
  807c65:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  807c69:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807c6c:	83 ec 0c             	sub    $0xc,%esp
  807c6f:	8b 46 10             	mov    0x10(%esi),%eax
  807c72:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807c76:	50                   	push   %eax
  807c77:	e8 66 f9 ff ff       	call   8075e2 <ntohs>
  807c7c:	83 c4 10             	add    $0x10,%esp
  807c7f:	ba 01 00 00 00       	mov    $0x1,%edx
  807c84:	a8 01                	test   $0x1,%al
  807c86:	75 1b                	jne    807ca3 <tcp_enqueue+0x483>
  807c88:	83 ec 0c             	sub    $0xc,%esp
  807c8b:	8b 46 10             	mov    0x10(%esi),%eax
  807c8e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807c92:	50                   	push   %eax
  807c93:	e8 4a f9 ff ff       	call   8075e2 <ntohs>
  807c98:	66 d1 e8             	shr    %ax
  807c9b:	89 c2                	mov    %eax,%edx
  807c9d:	83 e2 01             	and    $0x1,%edx
  807ca0:	83 c4 10             	add    $0x10,%esp
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  807ca3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807ca6:	01 d0                	add    %edx,%eax
  807ca8:	0f 84 c7 01 00 00    	je     807e75 <tcp_enqueue+0x655>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807cae:	83 ec 0c             	sub    $0xc,%esp
  807cb1:	8b 46 10             	mov    0x10(%esi),%eax
  807cb4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807cb8:	50                   	push   %eax
  807cb9:	e8 24 f9 ff ff       	call   8075e2 <ntohs>
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  807cbe:	83 c4 10             	add    $0x10,%esp
  807cc1:	a8 03                	test   $0x3,%al
  807cc3:	0f 85 ac 01 00 00    	jne    807e75 <tcp_enqueue+0x655>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807cc9:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807ccd:	0f 85 a2 01 00 00    	jne    807e75 <tcp_enqueue+0x655>
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807cd3:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  807cd7:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807cda:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807cde:	01 d0                	add    %edx,%eax
  807ce0:	0f b7 57 34          	movzwl 0x34(%edi),%edx
  807ce4:	39 d0                	cmp    %edx,%eax
  807ce6:	0f 8f 89 01 00 00    	jg     807e75 <tcp_enqueue+0x655>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807cec:	83 ec 08             	sub    $0x8,%esp
  807cef:	6a ec                	push   $0xffffffec
  807cf1:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807cf4:	ff 70 04             	pushl  0x4(%eax)
  807cf7:	e8 56 c9 ff ff       	call   804652 <pbuf_header>
  807cfc:	83 c4 10             	add    $0x10,%esp
  807cff:	84 c0                	test   %al,%al
  807d01:	74 17                	je     807d1a <tcp_enqueue+0x4fa>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  807d03:	83 ec 04             	sub    $0x4,%esp
  807d06:	68 67 1f 81 00       	push   $0x811f67
  807d0b:	68 52 01 00 00       	push   $0x152
  807d10:	68 42 1f 81 00       	push   $0x811f42
  807d15:	e8 3e 66 00 00       	call   80e358 <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  807d1a:	83 ec 08             	sub    $0x8,%esp
  807d1d:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807d20:	ff 70 04             	pushl  0x4(%eax)
  807d23:	ff 76 04             	pushl  0x4(%esi)
  807d26:	e8 81 ce ff ff       	call   804bac <pbuf_cat>
    useg->len += queue->len;
  807d2b:	8b 55 d0             	mov    -0x30(%ebp),%edx
  807d2e:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807d32:	66 01 46 0c          	add    %ax,0xc(%esi)
    useg->next = queue->next;
  807d36:	8b 02                	mov    (%edx),%eax
  807d38:	89 06                	mov    %eax,(%esi)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  807d3a:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  807d3d:	39 da                	cmp    %ebx,%edx
  807d3f:	b8 00 00 00 00       	mov    $0x0,%eax
  807d44:	0f 44 d8             	cmove  %eax,%ebx
    }
    memp_free(MEMP_TCP_SEG, queue);
  807d47:	52                   	push   %edx
  807d48:	6a 04                	push   $0x4
  807d4a:	e8 62 c6 ff ff       	call   8043b1 <memp_free>
  807d4f:	83 c4 10             	add    $0x10,%esp
  807d52:	eb 1f                	jmp    807d73 <tcp_enqueue+0x553>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  807d54:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807d57:	89 47 74             	mov    %eax,0x74(%edi)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  807d5a:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  807d5e:	83 e2 03             	and    $0x3,%edx
    ++len;
  807d61:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807d65:	83 c0 01             	add    $0x1,%eax
  807d68:	84 d2                	test   %dl,%dl
  807d6a:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  807d6f:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  }
  if (flags & TCP_FIN) {
  807d73:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  807d77:	74 04                	je     807d7d <tcp_enqueue+0x55d>
    pcb->flags |= TF_FIN;
  807d79:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  807d7d:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  807d81:	0f b7 c2             	movzwl %dx,%eax
  807d84:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  807d87:	66 29 57 6e          	sub    %dx,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  807d8b:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807d8f:	66 89 47 70          	mov    %ax,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  807d93:	66 85 c0             	test   %ax,%ax
  807d96:	74 23                	je     807dbb <tcp_enqueue+0x59b>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807d98:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807d9c:	75 1d                	jne    807dbb <tcp_enqueue+0x59b>
  807d9e:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807da2:	75 17                	jne    807dbb <tcp_enqueue+0x59b>
  807da4:	83 ec 04             	sub    $0x4,%esp
  807da7:	68 f4 1e 81 00       	push   $0x811ef4
  807dac:	68 7a 01 00 00       	push   $0x17a
  807db1:	68 42 1f 81 00       	push   $0x811f42
  807db6:	e8 9d 65 00 00       	call   80e358 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807dbb:	85 db                	test   %ebx,%ebx
  807dbd:	0f 84 8f 00 00 00    	je     807e52 <tcp_enqueue+0x632>
  807dc3:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  807dc8:	0f 84 84 00 00 00    	je     807e52 <tcp_enqueue+0x632>
  807dce:	8b 5b 10             	mov    0x10(%ebx),%ebx
  807dd1:	85 db                	test   %ebx,%ebx
  807dd3:	0f 84 80 00 00 00    	je     807e59 <tcp_enqueue+0x639>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  807dd9:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807dde:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  807de2:	0f 85 97 00 00 00    	jne    807e7f <tcp_enqueue+0x65f>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  807de8:	83 ec 0c             	sub    $0xc,%esp
  807deb:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  807def:	50                   	push   %eax
  807df0:	e8 ed f7 ff ff       	call   8075e2 <ntohs>
  807df5:	83 c8 08             	or     $0x8,%eax
  807df8:	0f b7 c0             	movzwl %ax,%eax
  807dfb:	89 04 24             	mov    %eax,(%esp)
  807dfe:	e8 d2 f7 ff ff       	call   8075d5 <htons>
  807e03:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  807e07:	83 c4 10             	add    $0x10,%esp
  }

  return ERR_OK;
  807e0a:	b8 00 00 00 00       	mov    $0x0,%eax
  807e0f:	eb 6e                	jmp    807e7f <tcp_enqueue+0x65f>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  807e11:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  807e15:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807e18:	85 c0                	test   %eax,%eax
  807e1a:	74 0c                	je     807e28 <tcp_enqueue+0x608>
    tcp_segs_free(queue);
  807e1c:	83 ec 0c             	sub    $0xc,%esp
  807e1f:	50                   	push   %eax
  807e20:	e8 89 d8 ff ff       	call   8056ae <tcp_segs_free>
  807e25:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  807e28:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  807e2d:	74 31                	je     807e60 <tcp_enqueue+0x640>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807e2f:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807e33:	75 32                	jne    807e67 <tcp_enqueue+0x647>
  807e35:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807e39:	75 33                	jne    807e6e <tcp_enqueue+0x64e>
  807e3b:	83 ec 04             	sub    $0x4,%esp
  807e3e:	68 f4 1e 81 00       	push   $0x811ef4
  807e43:	68 8d 01 00 00       	push   $0x18d
  807e48:	68 42 1f 81 00       	push   $0x811f42
  807e4d:	e8 06 65 00 00       	call   80e358 <_panic>
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  807e52:	b8 00 00 00 00       	mov    $0x0,%eax
  807e57:	eb 26                	jmp    807e7f <tcp_enqueue+0x65f>
  807e59:	b8 00 00 00 00       	mov    $0x0,%eax
  807e5e:	eb 1f                	jmp    807e7f <tcp_enqueue+0x65f>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  807e60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807e65:	eb 18                	jmp    807e7f <tcp_enqueue+0x65f>
  807e67:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807e6c:	eb 11                	jmp    807e7f <tcp_enqueue+0x65f>
  807e6e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807e73:	eb 0a                	jmp    807e7f <tcp_enqueue+0x65f>
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  807e75:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807e78:	89 06                	mov    %eax,(%esi)
  807e7a:	e9 db fe ff ff       	jmp    807d5a <tcp_enqueue+0x53a>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  807e7f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807e82:	5b                   	pop    %ebx
  807e83:	5e                   	pop    %esi
  807e84:	5f                   	pop    %edi
  807e85:	5d                   	pop    %ebp
  807e86:	c3                   	ret    

00807e87 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  807e87:	55                   	push   %ebp
  807e88:	89 e5                	mov    %esp,%ebp
  807e8a:	83 ec 0c             	sub    $0xc,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  807e8d:	6a 00                	push   $0x0
  807e8f:	6a 00                	push   $0x0
  807e91:	6a 01                	push   $0x1
  807e93:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  807e97:	50                   	push   %eax
  807e98:	6a 00                	push   $0x0
  807e9a:	6a 00                	push   $0x0
  807e9c:	ff 75 08             	pushl  0x8(%ebp)
  807e9f:	e8 7c f9 ff ff       	call   807820 <tcp_enqueue>
}
  807ea4:	c9                   	leave  
  807ea5:	c3                   	ret    

00807ea6 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  807ea6:	55                   	push   %ebp
  807ea7:	89 e5                	mov    %esp,%ebp
  807ea9:	56                   	push   %esi
  807eaa:	53                   	push   %ebx
  807eab:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807eae:	8b 55 10             	mov    0x10(%ebp),%edx
  807eb1:	8b 5d 14             	mov    0x14(%ebp),%ebx
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  807eb4:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  807eb7:	8d 70 fe             	lea    -0x2(%eax),%esi
  807eba:	83 fe 02             	cmp    $0x2,%esi
  807ebd:	76 05                	jbe    807ec4 <tcp_write+0x1e>
  807ebf:	83 f8 07             	cmp    $0x7,%eax
  807ec2:	75 29                	jne    807eed <tcp_write+0x47>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  807ec4:	b8 00 00 00 00       	mov    $0x0,%eax
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  807ec9:	66 85 d2             	test   %dx,%dx
  807ecc:	74 24                	je     807ef2 <tcp_write+0x4c>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  807ece:	83 ec 04             	sub    $0x4,%esp
  807ed1:	6a 00                	push   $0x0
  807ed3:	6a 00                	push   $0x0
  807ed5:	0f b6 db             	movzbl %bl,%ebx
  807ed8:	53                   	push   %ebx
  807ed9:	6a 00                	push   $0x0
  807edb:	0f b7 d2             	movzwl %dx,%edx
  807ede:	52                   	push   %edx
  807edf:	ff 75 0c             	pushl  0xc(%ebp)
  807ee2:	51                   	push   %ecx
  807ee3:	e8 38 f9 ff ff       	call   807820 <tcp_enqueue>
  807ee8:	83 c4 20             	add    $0x20,%esp
  807eeb:	eb 05                	jmp    807ef2 <tcp_write+0x4c>
    }
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  807eed:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  807ef2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  807ef5:	5b                   	pop    %ebx
  807ef6:	5e                   	pop    %esi
  807ef7:	5d                   	pop    %ebp
  807ef8:	c3                   	ret    

00807ef9 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  807ef9:	55                   	push   %ebp
  807efa:	89 e5                	mov    %esp,%ebp
  807efc:	57                   	push   %edi
  807efd:	56                   	push   %esi
  807efe:	53                   	push   %ebx
  807eff:	83 ec 1c             	sub    $0x1c,%esp
  807f02:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  807f05:	39 3d 58 b2 b3 00    	cmp    %edi,0xb3b258
  807f0b:	0f 84 36 04 00 00    	je     808347 <tcp_output+0x44e>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  807f11:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  807f15:	66 39 47 4e          	cmp    %ax,0x4e(%edi)
  807f19:	66 0f 46 47 4e       	cmovbe 0x4e(%edi),%ax
  807f1e:	0f b7 c0             	movzwl %ax,%eax
  807f21:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  807f24:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  807f27:	8b 47 78             	mov    0x78(%edi),%eax
  807f2a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807f2d:	8b 55 dc             	mov    -0x24(%ebp),%edx
  if (useg != NULL) {
  807f30:	85 c0                	test   %eax,%eax
  807f32:	75 06                	jne    807f3a <tcp_output+0x41>
  807f34:	eb 0d                	jmp    807f43 <tcp_output+0x4a>
    for (; useg->next != NULL; useg = useg->next);
  807f36:	89 c2                	mov    %eax,%edx
  807f38:	eb 00                	jmp    807f3a <tcp_output+0x41>
  807f3a:	8b 02                	mov    (%edx),%eax
  807f3c:	85 c0                	test   %eax,%eax
  807f3e:	75 f6                	jne    807f36 <tcp_output+0x3d>
  807f40:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  807f43:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  807f47:	75 0b                	jne    807f54 <tcp_output+0x5b>

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  807f49:	8d 47 04             	lea    0x4(%edi),%eax
  807f4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807f4f:	e9 8c 03 00 00       	jmp    8082e0 <tcp_output+0x3e7>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  807f54:	85 db                	test   %ebx,%ebx
  807f56:	74 1f                	je     807f77 <tcp_output+0x7e>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  807f58:	83 ec 0c             	sub    $0xc,%esp
  807f5b:	8b 43 10             	mov    0x10(%ebx),%eax
  807f5e:	ff 70 04             	pushl  0x4(%eax)
  807f61:	e8 aa f8 ff ff       	call   807810 <ntohl>
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  807f66:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  807f6a:	2b 57 48             	sub    0x48(%edi),%edx
  807f6d:	01 d0                	add    %edx,%eax
  807f6f:	83 c4 10             	add    $0x10,%esp
  807f72:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  807f75:	73 d2                	jae    807f49 <tcp_output+0x50>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  807f77:	83 ec 04             	sub    $0x4,%esp
  807f7a:	6a 00                	push   $0x0
  807f7c:	6a 14                	push   $0x14
  807f7e:	6a 01                	push   $0x1
  807f80:	e8 65 c8 ff ff       	call   8047ea <pbuf_alloc>
  807f85:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  807f87:	83 c4 10             	add    $0x10,%esp
  807f8a:	85 c0                	test   %eax,%eax
  807f8c:	0f 84 bc 03 00 00    	je     80834e <tcp_output+0x455>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  807f92:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  807f96:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  807f99:	83 ec 0c             	sub    $0xc,%esp
  807f9c:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807fa0:	50                   	push   %eax
  807fa1:	e8 2f f6 ff ff       	call   8075d5 <htons>
  807fa6:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  807fa9:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807fad:	89 04 24             	mov    %eax,(%esp)
  807fb0:	e8 20 f6 ff ff       	call   8075d5 <htons>
  807fb5:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  807fb9:	83 c4 04             	add    $0x4,%esp
  807fbc:	ff 77 54             	pushl  0x54(%edi)
  807fbf:	e8 2b f6 ff ff       	call   8075ef <htonl>
  807fc4:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  807fc7:	83 c4 04             	add    $0x4,%esp
  807fca:	ff 77 24             	pushl  0x24(%edi)
  807fcd:	e8 1d f6 ff ff       	call   8075ef <htonl>
  807fd2:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  807fd5:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  807fd9:	89 04 24             	mov    %eax,(%esp)
  807fdc:	e8 01 f6 ff ff       	call   8075e2 <ntohs>
  807fe1:	25 c0 ff 00 00       	and    $0xffc0,%eax
  807fe6:	83 c8 10             	or     $0x10,%eax
  807fe9:	89 04 24             	mov    %eax,(%esp)
  807fec:	e8 e4 f5 ff ff       	call   8075d5 <htons>
  807ff1:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  807ff5:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  807ff9:	89 04 24             	mov    %eax,(%esp)
  807ffc:	e8 d4 f5 ff ff       	call   8075d5 <htons>
  808001:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  808005:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80800b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80800f:	89 04 24             	mov    %eax,(%esp)
  808012:	e8 cb f5 ff ff       	call   8075e2 <ntohs>
  808017:	83 e0 3f             	and    $0x3f,%eax
  80801a:	80 cc 50             	or     $0x50,%ah
  80801d:	89 04 24             	mov    %eax,(%esp)
  808020:	e8 b0 f5 ff ff       	call   8075d5 <htons>
  808025:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  808029:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80802f:	8d 47 04             	lea    0x4(%edi),%eax
  808032:	89 c1                	mov    %eax,%ecx
  808034:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808038:	89 04 24             	mov    %eax,(%esp)
  80803b:	6a 06                	push   $0x6
  80803d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808040:	51                   	push   %ecx
  808041:	57                   	push   %edi
  808042:	56                   	push   %esi
  808043:	e8 74 f2 ff ff       	call   8072bc <inet_chksum_pseudo>
  808048:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80804c:	83 c4 18             	add    $0x18,%esp
  80804f:	6a 06                	push   $0x6
  808051:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808055:	50                   	push   %eax
  808056:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80805a:	50                   	push   %eax
  80805b:	ff 75 e4             	pushl  -0x1c(%ebp)
  80805e:	57                   	push   %edi
  80805f:	56                   	push   %esi
  808060:	e8 9e e8 ff ff       	call   806903 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  808065:	83 c4 14             	add    $0x14,%esp
  808068:	56                   	push   %esi
  808069:	e8 b6 c6 ff ff       	call   804724 <pbuf_free>

    return ERR_OK;
  80806e:	83 c4 10             	add    $0x10,%esp
  808071:	b8 00 00 00 00       	mov    $0x0,%eax
  808076:	e9 ed 02 00 00       	jmp    808368 <tcp_output+0x46f>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80807b:	83 ec 0c             	sub    $0xc,%esp
  80807e:	8b 43 10             	mov    0x10(%ebx),%eax
  808081:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808085:	50                   	push   %eax
  808086:	e8 57 f5 ff ff       	call   8075e2 <ntohs>
  80808b:	83 c4 10             	add    $0x10,%esp
  80808e:	a8 04                	test   $0x4,%al
  808090:	74 17                	je     8080a9 <tcp_output+0x1b0>
  808092:	83 ec 04             	sub    $0x4,%esp
  808095:	68 7b 1f 81 00       	push   $0x811f7b
  80809a:	68 05 02 00 00       	push   $0x205
  80809f:	68 42 1f 81 00       	push   $0x811f42
  8080a4:	e8 af 62 00 00       	call   80e358 <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  8080a9:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8080ad:	74 1c                	je     8080cb <tcp_output+0x1d2>
  8080af:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  8080b3:	a8 40                	test   $0x40,%al
  8080b5:	75 14                	jne    8080cb <tcp_output+0x1d2>
  8080b7:	8b 57 74             	mov    0x74(%edi),%edx
  8080ba:	85 d2                	test   %edx,%edx
  8080bc:	0f 84 93 02 00 00    	je     808355 <tcp_output+0x45c>
  8080c2:	83 3a 00             	cmpl   $0x0,(%edx)
  8080c5:	0f 84 8a 02 00 00    	je     808355 <tcp_output+0x45c>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  8080cb:	8b 03                	mov    (%ebx),%eax
  8080cd:	89 47 74             	mov    %eax,0x74(%edi)

    if (pcb->state != SYN_SENT) {
  8080d0:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  8080d4:	74 29                	je     8080ff <tcp_output+0x206>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  8080d6:	8b 73 10             	mov    0x10(%ebx),%esi
  8080d9:	83 ec 0c             	sub    $0xc,%esp
  8080dc:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8080e0:	50                   	push   %eax
  8080e1:	e8 fc f4 ff ff       	call   8075e2 <ntohs>
  8080e6:	83 c8 10             	or     $0x10,%eax
  8080e9:	0f b7 c0             	movzwl %ax,%eax
  8080ec:	89 04 24             	mov    %eax,(%esp)
  8080ef:	e8 e1 f4 ff ff       	call   8075d5 <htons>
  8080f4:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8080f8:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  8080fc:	83 c4 10             	add    $0x10,%esp
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  8080ff:	8b 73 10             	mov    0x10(%ebx),%esi
  808102:	83 ec 0c             	sub    $0xc,%esp
  808105:	ff 77 24             	pushl  0x24(%edi)
  808108:	e8 e2 f4 ff ff       	call   8075ef <htonl>
  80810d:	89 46 08             	mov    %eax,0x8(%esi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808110:	8b 73 10             	mov    0x10(%ebx),%esi
  808113:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  808117:	89 04 24             	mov    %eax,(%esp)
  80811a:	e8 b6 f4 ff ff       	call   8075d5 <htons>
  80811f:	66 89 46 0e          	mov    %ax,0xe(%esi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  808123:	83 c4 10             	add    $0x10,%esp
  808126:	85 ff                	test   %edi,%edi
  808128:	74 05                	je     80812f <tcp_output+0x236>
  80812a:	83 3f 00             	cmpl   $0x0,(%edi)
  80812d:	75 27                	jne    808156 <tcp_output+0x25d>
    netif = ip_route(&(pcb->remote_ip));
  80812f:	83 ec 0c             	sub    $0xc,%esp
  808132:	ff 75 e4             	pushl  -0x1c(%ebp)
  808135:	e8 df e2 ff ff       	call   806419 <ip_route>
    if (netif == NULL) {
  80813a:	83 c4 10             	add    $0x10,%esp
  80813d:	85 c0                	test   %eax,%eax
  80813f:	0f 84 a2 00 00 00    	je     8081e7 <tcp_output+0x2ee>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  808145:	83 f8 fc             	cmp    $0xfffffffc,%eax
  808148:	74 05                	je     80814f <tcp_output+0x256>
  80814a:	8b 40 04             	mov    0x4(%eax),%eax
  80814d:	eb 05                	jmp    808154 <tcp_output+0x25b>
  80814f:	b8 00 00 00 00       	mov    $0x0,%eax
  808154:	89 07                	mov    %eax,(%edi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  808156:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  80815b:	75 06                	jne    808163 <tcp_output+0x26a>
    pcb->rtime = 0;
  80815d:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

  if (pcb->rttest == 0) {
  808163:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  808167:	75 1c                	jne    808185 <tcp_output+0x28c>
    pcb->rttest = tcp_ticks;
  808169:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80816e:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  808171:	83 ec 0c             	sub    $0xc,%esp
  808174:	8b 43 10             	mov    0x10(%ebx),%eax
  808177:	ff 70 04             	pushl  0x4(%eax)
  80817a:	e8 91 f6 ff ff       	call   807810 <ntohl>
  80817f:	89 47 3c             	mov    %eax,0x3c(%edi)
  808182:	83 c4 10             	add    $0x10,%esp
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  808185:	8b 53 04             	mov    0x4(%ebx),%edx
  808188:	8b 43 10             	mov    0x10(%ebx),%eax
  80818b:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  80818e:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  808192:	8b 53 04             	mov    0x4(%ebx),%edx
  808195:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  808199:	8b 43 04             	mov    0x4(%ebx),%eax
  80819c:	8b 53 10             	mov    0x10(%ebx),%edx
  80819f:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  8081a2:	8b 43 10             	mov    0x10(%ebx),%eax
  8081a5:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8081ab:	8b 73 10             	mov    0x10(%ebx),%esi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  8081ae:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8081b1:	83 ec 0c             	sub    $0xc,%esp
  8081b4:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  8081b8:	52                   	push   %edx
  8081b9:	6a 06                	push   $0x6
  8081bb:	ff 75 e4             	pushl  -0x1c(%ebp)
  8081be:	57                   	push   %edi
  8081bf:	50                   	push   %eax
  8081c0:	e8 f7 f0 ff ff       	call   8072bc <inet_chksum_pseudo>
  8081c5:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  8081c9:	83 c4 18             	add    $0x18,%esp
  8081cc:	6a 06                	push   $0x6
  8081ce:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  8081d2:	50                   	push   %eax
  8081d3:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  8081d7:	50                   	push   %eax
  8081d8:	ff 75 e4             	pushl  -0x1c(%ebp)
  8081db:	57                   	push   %edi
  8081dc:	ff 73 04             	pushl  0x4(%ebx)
  8081df:	e8 1f e7 ff ff       	call   806903 <ip_output>
  8081e4:	83 c4 20             	add    $0x20,%esp
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8081e7:	83 ec 0c             	sub    $0xc,%esp
  8081ea:	8b 43 10             	mov    0x10(%ebx),%eax
  8081ed:	ff 70 04             	pushl  0x4(%eax)
  8081f0:	e8 1b f6 ff ff       	call   807810 <ntohl>
  8081f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8081f8:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8081fc:	8b 43 10             	mov    0x10(%ebx),%eax
  8081ff:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808203:	89 04 24             	mov    %eax,(%esp)
  808206:	e8 d7 f3 ff ff       	call   8075e2 <ntohs>
  80820b:	83 c4 10             	add    $0x10,%esp
  80820e:	ba 01 00 00 00       	mov    $0x1,%edx
  808213:	a8 01                	test   $0x1,%al
  808215:	75 1b                	jne    808232 <tcp_output+0x339>
  808217:	83 ec 0c             	sub    $0xc,%esp
  80821a:	8b 43 10             	mov    0x10(%ebx),%eax
  80821d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808221:	50                   	push   %eax
  808222:	e8 bb f3 ff ff       	call   8075e2 <ntohs>
  808227:	66 d1 e8             	shr    %ax
  80822a:	89 c2                	mov    %eax,%edx
  80822c:	83 e2 01             	and    $0x1,%edx
  80822f:	83 c4 10             	add    $0x10,%esp
  808232:	01 d6                	add    %edx,%esi
  808234:	03 75 e0             	add    -0x20(%ebp),%esi
  808237:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  80823a:	39 77 58             	cmp    %esi,0x58(%edi)
  80823d:	79 03                	jns    808242 <tcp_output+0x349>
      pcb->snd_max = pcb->snd_nxt;
  80823f:	89 77 58             	mov    %esi,0x58(%edi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  808242:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808246:	83 ec 0c             	sub    $0xc,%esp
  808249:	8b 43 10             	mov    0x10(%ebx),%eax
  80824c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808250:	50                   	push   %eax
  808251:	e8 8c f3 ff ff       	call   8075e2 <ntohs>
  808256:	83 c4 10             	add    $0x10,%esp
  808259:	ba 01 00 00 00       	mov    $0x1,%edx
  80825e:	a8 01                	test   $0x1,%al
  808260:	75 1b                	jne    80827d <tcp_output+0x384>
  808262:	83 ec 0c             	sub    $0xc,%esp
  808265:	8b 43 10             	mov    0x10(%ebx),%eax
  808268:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80826c:	50                   	push   %eax
  80826d:	e8 70 f3 ff ff       	call   8075e2 <ntohs>
  808272:	66 d1 e8             	shr    %ax
  808275:	89 c2                	mov    %eax,%edx
  808277:	83 e2 01             	and    $0x1,%edx
  80827a:	83 c4 10             	add    $0x10,%esp
  80827d:	01 f2                	add    %esi,%edx
  80827f:	74 50                	je     8082d1 <tcp_output+0x3d8>
      seg->next = NULL;
  808281:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  808287:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80828b:	75 08                	jne    808295 <tcp_output+0x39c>
        pcb->unacked = seg;
  80828d:	89 5f 78             	mov    %ebx,0x78(%edi)
  808290:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808293:	eb 48                	jmp    8082dd <tcp_output+0x3e4>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  808295:	83 ec 0c             	sub    $0xc,%esp
  808298:	8b 43 10             	mov    0x10(%ebx),%eax
  80829b:	ff 70 04             	pushl  0x4(%eax)
  80829e:	e8 6d f5 ff ff       	call   807810 <ntohl>
  8082a3:	89 c6                	mov    %eax,%esi
  8082a5:	83 c4 04             	add    $0x4,%esp
  8082a8:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8082ab:	8b 40 10             	mov    0x10(%eax),%eax
  8082ae:	ff 70 04             	pushl  0x4(%eax)
  8082b1:	e8 5a f5 ff ff       	call   807810 <ntohl>
  8082b6:	83 c4 10             	add    $0x10,%esp
  8082b9:	39 c6                	cmp    %eax,%esi
  8082bb:	79 0a                	jns    8082c7 <tcp_output+0x3ce>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  8082bd:	8b 47 78             	mov    0x78(%edi),%eax
  8082c0:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  8082c2:	89 5f 78             	mov    %ebx,0x78(%edi)
  8082c5:	eb 16                	jmp    8082dd <tcp_output+0x3e4>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  8082c7:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8082ca:	89 18                	mov    %ebx,(%eax)
  8082cc:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  8082cf:	eb 0c                	jmp    8082dd <tcp_output+0x3e4>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  8082d1:	83 ec 0c             	sub    $0xc,%esp
  8082d4:	53                   	push   %ebx
  8082d5:	e8 90 d3 ff ff       	call   80566a <tcp_seg_free>
  8082da:	83 c4 10             	add    $0x10,%esp
    }
    seg = pcb->unsent;
  8082dd:	8b 5f 74             	mov    0x74(%edi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  8082e0:	85 db                	test   %ebx,%ebx
  8082e2:	74 58                	je     80833c <tcp_output+0x443>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  8082e4:	83 ec 0c             	sub    $0xc,%esp
  8082e7:	8b 43 10             	mov    0x10(%ebx),%eax
  8082ea:	ff 70 04             	pushl  0x4(%eax)
  8082ed:	e8 1e f5 ff ff       	call   807810 <ntohl>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  8082f2:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  8082f6:	2b 57 48             	sub    0x48(%edi),%edx
  8082f9:	01 d0                	add    %edx,%eax
  8082fb:	83 c4 10             	add    $0x10,%esp
  8082fe:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  808301:	0f 83 74 fd ff ff    	jae    80807b <tcp_output+0x182>
  808307:	eb 54                	jmp    80835d <tcp_output+0x464>
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808309:	83 ec 0c             	sub    $0xc,%esp
  80830c:	8b 43 10             	mov    0x10(%ebx),%eax
  80830f:	ff 70 04             	pushl  0x4(%eax)
  808312:	e8 f9 f4 ff ff       	call   807810 <ntohl>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808317:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80831b:	2b 57 48             	sub    0x48(%edi),%edx
  80831e:	01 d0                	add    %edx,%eax
  808320:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  808324:	83 c4 10             	add    $0x10,%esp
  808327:	39 d0                	cmp    %edx,%eax
  808329:	76 11                	jbe    80833c <tcp_output+0x443>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  80832b:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  808332:	00 00 00 
    pcb->persist_backoff = 1;
  808335:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  80833c:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  808340:	b8 00 00 00 00       	mov    $0x0,%eax
  808345:	eb 21                	jmp    808368 <tcp_output+0x46f>
  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  808347:	b8 00 00 00 00       	mov    $0x0,%eax
  80834c:	eb 1a                	jmp    808368 <tcp_output+0x46f>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    if (p == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  80834e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808353:	eb 13                	jmp    808368 <tcp_output+0x46f>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808355:	a8 a0                	test   $0xa0,%al
  808357:	0f 85 6e fd ff ff    	jne    8080cb <tcp_output+0x1d2>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80835d:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  808364:	75 d6                	jne    80833c <tcp_output+0x443>
  808366:	eb a1                	jmp    808309 <tcp_output+0x410>
    pcb->persist_backoff = 1;
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
  808368:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80836b:	5b                   	pop    %ebx
  80836c:	5e                   	pop    %esi
  80836d:	5f                   	pop    %edi
  80836e:	5d                   	pop    %ebp
  80836f:	c3                   	ret    

00808370 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  808370:	55                   	push   %ebp
  808371:	89 e5                	mov    %esp,%ebp
  808373:	57                   	push   %edi
  808374:	56                   	push   %esi
  808375:	53                   	push   %ebx
  808376:	83 ec 20             	sub    $0x20,%esp
  808379:	8b 7d 18             	mov    0x18(%ebp),%edi
  80837c:	8b 45 1c             	mov    0x1c(%ebp),%eax
  80837f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808382:	6a 00                	push   $0x0
  808384:	6a 14                	push   $0x14
  808386:	6a 01                	push   $0x1
  808388:	e8 5d c4 ff ff       	call   8047ea <pbuf_alloc>
  if (p == NULL) {
  80838d:	83 c4 10             	add    $0x10,%esp
  808390:	85 c0                	test   %eax,%eax
  808392:	0f 84 f5 00 00 00    	je     80848d <tcp_rst+0x11d>
  808398:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80839a:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80839f:	77 17                	ja     8083b8 <tcp_rst+0x48>
  8083a1:	83 ec 04             	sub    $0x4,%esp
  8083a4:	68 14 1f 81 00       	push   $0x811f14
  8083a9:	68 be 02 00 00       	push   $0x2be
  8083ae:	68 42 1f 81 00       	push   $0x811f42
  8083b3:	e8 a0 5f 00 00       	call   80e358 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8083b8:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  8083bb:	83 ec 0c             	sub    $0xc,%esp
  8083be:	0f b7 ff             	movzwl %di,%edi
  8083c1:	57                   	push   %edi
  8083c2:	e8 0e f2 ff ff       	call   8075d5 <htons>
  8083c7:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  8083ca:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8083ce:	89 04 24             	mov    %eax,(%esp)
  8083d1:	e8 ff f1 ff ff       	call   8075d5 <htons>
  8083d6:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  8083da:	83 c4 04             	add    $0x4,%esp
  8083dd:	ff 75 08             	pushl  0x8(%ebp)
  8083e0:	e8 0a f2 ff ff       	call   8075ef <htonl>
  8083e5:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  8083e8:	83 c4 04             	add    $0x4,%esp
  8083eb:	ff 75 0c             	pushl  0xc(%ebp)
  8083ee:	e8 fc f1 ff ff       	call   8075ef <htonl>
  8083f3:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  8083f6:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8083fa:	89 04 24             	mov    %eax,(%esp)
  8083fd:	e8 e0 f1 ff ff       	call   8075e2 <ntohs>
  808402:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808407:	83 c8 14             	or     $0x14,%eax
  80840a:	89 04 24             	mov    %eax,(%esp)
  80840d:	e8 c3 f1 ff ff       	call   8075d5 <htons>
  808412:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808416:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80841d:	e8 b3 f1 ff ff       	call   8075d5 <htons>
  808422:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808426:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80842c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808430:	89 04 24             	mov    %eax,(%esp)
  808433:	e8 aa f1 ff ff       	call   8075e2 <ntohs>
  808438:	83 e0 3f             	and    $0x3f,%eax
  80843b:	80 cc 50             	or     $0x50,%ah
  80843e:	89 04 24             	mov    %eax,(%esp)
  808441:	e8 8f f1 ff ff       	call   8075d5 <htons>
  808446:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80844a:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808450:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808454:	89 04 24             	mov    %eax,(%esp)
  808457:	6a 06                	push   $0x6
  808459:	ff 75 14             	pushl  0x14(%ebp)
  80845c:	ff 75 10             	pushl  0x10(%ebp)
  80845f:	56                   	push   %esi
  808460:	e8 57 ee ff ff       	call   8072bc <inet_chksum_pseudo>
  808465:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  808469:	83 c4 18             	add    $0x18,%esp
  80846c:	6a 06                	push   $0x6
  80846e:	6a 00                	push   $0x0
  808470:	68 ff 00 00 00       	push   $0xff
  808475:	ff 75 14             	pushl  0x14(%ebp)
  808478:	ff 75 10             	pushl  0x10(%ebp)
  80847b:	56                   	push   %esi
  80847c:	e8 82 e4 ff ff       	call   806903 <ip_output>
  pbuf_free(p);
  808481:	83 c4 14             	add    $0x14,%esp
  808484:	56                   	push   %esi
  808485:	e8 9a c2 ff ff       	call   804724 <pbuf_free>
  80848a:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  80848d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808490:	5b                   	pop    %ebx
  808491:	5e                   	pop    %esi
  808492:	5f                   	pop    %edi
  808493:	5d                   	pop    %ebp
  808494:	c3                   	ret    

00808495 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  808495:	55                   	push   %ebp
  808496:	89 e5                	mov    %esp,%ebp
  808498:	53                   	push   %ebx
  808499:	83 ec 04             	sub    $0x4,%esp
  80849c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80849f:	8b 53 78             	mov    0x78(%ebx),%edx
  8084a2:	85 d2                	test   %edx,%edx
  8084a4:	75 04                	jne    8084aa <tcp_rexmit_rto+0x15>
  8084a6:	eb 41                	jmp    8084e9 <tcp_rexmit_rto+0x54>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  8084a8:	89 c2                	mov    %eax,%edx
  8084aa:	8b 02                	mov    (%edx),%eax
  8084ac:	85 c0                	test   %eax,%eax
  8084ae:	75 f8                	jne    8084a8 <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  8084b0:	8b 43 74             	mov    0x74(%ebx),%eax
  8084b3:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  8084b5:	8b 43 78             	mov    0x78(%ebx),%eax
  8084b8:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  8084bb:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8084c2:	83 ec 0c             	sub    $0xc,%esp
  8084c5:	8b 40 10             	mov    0x10(%eax),%eax
  8084c8:	ff 70 04             	pushl  0x4(%eax)
  8084cb:	e8 40 f3 ff ff       	call   807810 <ntohl>
  8084d0:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8084d3:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  8084d7:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  8084de:	89 1c 24             	mov    %ebx,(%esp)
  8084e1:	e8 13 fa ff ff       	call   807ef9 <tcp_output>
  8084e6:	83 c4 10             	add    $0x10,%esp
}
  8084e9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8084ec:	c9                   	leave  
  8084ed:	c3                   	ret    

008084ee <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  8084ee:	55                   	push   %ebp
  8084ef:	89 e5                	mov    %esp,%ebp
  8084f1:	53                   	push   %ebx
  8084f2:	83 ec 04             	sub    $0x4,%esp
  8084f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8084f8:	8b 43 78             	mov    0x78(%ebx),%eax
  8084fb:	85 c0                	test   %eax,%eax
  8084fd:	74 37                	je     808536 <tcp_rexmit+0x48>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  8084ff:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808501:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808504:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808506:	8b 43 78             	mov    0x78(%ebx),%eax
  808509:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80850c:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80850f:	83 ec 0c             	sub    $0xc,%esp
  808512:	8b 40 10             	mov    0x10(%eax),%eax
  808515:	ff 70 04             	pushl  0x4(%eax)
  808518:	e8 f3 f2 ff ff       	call   807810 <ntohl>
  80851d:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808520:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808524:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80852b:	89 1c 24             	mov    %ebx,(%esp)
  80852e:	e8 c6 f9 ff ff       	call   807ef9 <tcp_output>
  808533:	83 c4 10             	add    $0x10,%esp
}
  808536:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808539:	c9                   	leave  
  80853a:	c3                   	ret    

0080853b <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80853b:	55                   	push   %ebp
  80853c:	89 e5                	mov    %esp,%ebp
  80853e:	57                   	push   %edi
  80853f:	56                   	push   %esi
  808540:	53                   	push   %ebx
  808541:	83 ec 20             	sub    $0x20,%esp
  808544:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808547:	6a 00                	push   $0x0
  808549:	6a 14                	push   $0x14
  80854b:	6a 01                	push   $0x1
  80854d:	e8 98 c2 ff ff       	call   8047ea <pbuf_alloc>
   
  if(p == NULL) {
  808552:	83 c4 10             	add    $0x10,%esp
  808555:	85 c0                	test   %eax,%eax
  808557:	0f 84 f8 00 00 00    	je     808655 <tcp_keepalive+0x11a>
  80855d:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80855f:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808564:	77 17                	ja     80857d <tcp_keepalive+0x42>
  808566:	83 ec 04             	sub    $0x4,%esp
  808569:	68 14 1f 81 00       	push   $0x811f14
  80856e:	68 3a 03 00 00       	push   $0x33a
  808573:	68 42 1f 81 00       	push   $0x811f42
  808578:	e8 db 5d 00 00       	call   80e358 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80857d:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808580:	83 ec 0c             	sub    $0xc,%esp
  808583:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808587:	50                   	push   %eax
  808588:	e8 48 f0 ff ff       	call   8075d5 <htons>
  80858d:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808590:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808594:	89 04 24             	mov    %eax,(%esp)
  808597:	e8 39 f0 ff ff       	call   8075d5 <htons>
  80859c:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  8085a0:	8b 46 54             	mov    0x54(%esi),%eax
  8085a3:	83 e8 01             	sub    $0x1,%eax
  8085a6:	89 04 24             	mov    %eax,(%esp)
  8085a9:	e8 41 f0 ff ff       	call   8075ef <htonl>
  8085ae:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8085b1:	83 c4 04             	add    $0x4,%esp
  8085b4:	ff 76 24             	pushl  0x24(%esi)
  8085b7:	e8 33 f0 ff ff       	call   8075ef <htonl>
  8085bc:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8085bf:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8085c3:	89 04 24             	mov    %eax,(%esp)
  8085c6:	e8 17 f0 ff ff       	call   8075e2 <ntohs>
  8085cb:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8085d0:	89 04 24             	mov    %eax,(%esp)
  8085d3:	e8 fd ef ff ff       	call   8075d5 <htons>
  8085d8:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8085dc:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  8085e0:	89 04 24             	mov    %eax,(%esp)
  8085e3:	e8 ed ef ff ff       	call   8075d5 <htons>
  8085e8:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  8085ec:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  8085f2:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8085f6:	89 04 24             	mov    %eax,(%esp)
  8085f9:	e8 e4 ef ff ff       	call   8075e2 <ntohs>
  8085fe:	83 e0 3f             	and    $0x3f,%eax
  808601:	80 cc 50             	or     $0x50,%ah
  808604:	89 04 24             	mov    %eax,(%esp)
  808607:	e8 c9 ef ff ff       	call   8075d5 <htons>
  80860c:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808610:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808616:	8d 46 04             	lea    0x4(%esi),%eax
  808619:	89 c2                	mov    %eax,%edx
  80861b:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80861f:	89 04 24             	mov    %eax,(%esp)
  808622:	6a 06                	push   $0x6
  808624:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808627:	52                   	push   %edx
  808628:	56                   	push   %esi
  808629:	57                   	push   %edi
  80862a:	e8 8d ec ff ff       	call   8072bc <inet_chksum_pseudo>
  80862f:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808633:	83 c4 18             	add    $0x18,%esp
  808636:	6a 06                	push   $0x6
  808638:	6a 00                	push   $0x0
  80863a:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80863e:	50                   	push   %eax
  80863f:	ff 75 e4             	pushl  -0x1c(%ebp)
  808642:	56                   	push   %esi
  808643:	57                   	push   %edi
  808644:	e8 ba e2 ff ff       	call   806903 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808649:	83 c4 14             	add    $0x14,%esp
  80864c:	57                   	push   %edi
  80864d:	e8 d2 c0 ff ff       	call   804724 <pbuf_free>
  808652:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808655:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808658:	5b                   	pop    %ebx
  808659:	5e                   	pop    %esi
  80865a:	5f                   	pop    %edi
  80865b:	5d                   	pop    %ebp
  80865c:	c3                   	ret    

0080865d <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  80865d:	55                   	push   %ebp
  80865e:	89 e5                	mov    %esp,%ebp
  808660:	57                   	push   %edi
  808661:	56                   	push   %esi
  808662:	53                   	push   %ebx
  808663:	83 ec 1c             	sub    $0x1c,%esp
  808666:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  808669:	8b 46 78             	mov    0x78(%esi),%eax
  80866c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  80866f:	85 c0                	test   %eax,%eax
  808671:	75 0e                	jne    808681 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  808673:	8b 46 74             	mov    0x74(%esi),%eax
  808676:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808679:	85 c0                	test   %eax,%eax
  80867b:	0f 84 1b 01 00 00    	je     80879c <tcp_zero_window_probe+0x13f>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  808681:	83 ec 04             	sub    $0x4,%esp
  808684:	6a 00                	push   $0x0
  808686:	6a 15                	push   $0x15
  808688:	6a 01                	push   $0x1
  80868a:	e8 5b c1 ff ff       	call   8047ea <pbuf_alloc>
  80868f:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808691:	83 c4 10             	add    $0x10,%esp
  808694:	85 c0                	test   %eax,%eax
  808696:	0f 84 00 01 00 00    	je     80879c <tcp_zero_window_probe+0x13f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80869c:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8086a1:	77 17                	ja     8086ba <tcp_zero_window_probe+0x5d>
  8086a3:	83 ec 04             	sub    $0x4,%esp
  8086a6:	68 14 1f 81 00       	push   $0x811f14
  8086ab:	68 8d 03 00 00       	push   $0x38d
  8086b0:	68 42 1f 81 00       	push   $0x811f42
  8086b5:	e8 9e 5c 00 00       	call   80e358 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8086ba:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8086bd:	83 ec 0c             	sub    $0xc,%esp
  8086c0:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8086c4:	50                   	push   %eax
  8086c5:	e8 0b ef ff ff       	call   8075d5 <htons>
  8086ca:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8086cd:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  8086d1:	89 04 24             	mov    %eax,(%esp)
  8086d4:	e8 fc ee ff ff       	call   8075d5 <htons>
  8086d9:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  8086dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8086e0:	8b 40 10             	mov    0x10(%eax),%eax
  8086e3:	8b 40 04             	mov    0x4(%eax),%eax
  8086e6:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8086e9:	83 c4 04             	add    $0x4,%esp
  8086ec:	ff 76 24             	pushl  0x24(%esi)
  8086ef:	e8 fb ee ff ff       	call   8075ef <htonl>
  8086f4:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8086f7:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8086fb:	89 04 24             	mov    %eax,(%esp)
  8086fe:	e8 df ee ff ff       	call   8075e2 <ntohs>
  808703:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808708:	89 04 24             	mov    %eax,(%esp)
  80870b:	e8 c5 ee ff ff       	call   8075d5 <htons>
  808710:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808714:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808718:	89 04 24             	mov    %eax,(%esp)
  80871b:	e8 b5 ee ff ff       	call   8075d5 <htons>
  808720:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808724:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80872a:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80872e:	89 04 24             	mov    %eax,(%esp)
  808731:	e8 ac ee ff ff       	call   8075e2 <ntohs>
  808736:	83 e0 3f             	and    $0x3f,%eax
  808739:	80 cc 50             	or     $0x50,%ah
  80873c:	89 04 24             	mov    %eax,(%esp)
  80873f:	e8 91 ee ff ff       	call   8075d5 <htons>
  808744:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  808748:	8b 47 04             	mov    0x4(%edi),%eax
  80874b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80874e:	8b 51 08             	mov    0x8(%ecx),%edx
  808751:	0f b6 12             	movzbl (%edx),%edx
  808754:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808757:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80875d:	8d 46 04             	lea    0x4(%esi),%eax
  808760:	89 c1                	mov    %eax,%ecx
  808762:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808766:	89 04 24             	mov    %eax,(%esp)
  808769:	6a 06                	push   $0x6
  80876b:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80876e:	51                   	push   %ecx
  80876f:	56                   	push   %esi
  808770:	57                   	push   %edi
  808771:	e8 46 eb ff ff       	call   8072bc <inet_chksum_pseudo>
  808776:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80877a:	83 c4 18             	add    $0x18,%esp
  80877d:	6a 06                	push   $0x6
  80877f:	6a 00                	push   $0x0
  808781:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808785:	50                   	push   %eax
  808786:	ff 75 e4             	pushl  -0x1c(%ebp)
  808789:	56                   	push   %esi
  80878a:	57                   	push   %edi
  80878b:	e8 73 e1 ff ff       	call   806903 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808790:	83 c4 14             	add    $0x14,%esp
  808793:	57                   	push   %edi
  808794:	e8 8b bf ff ff       	call   804724 <pbuf_free>
  808799:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80879c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80879f:	5b                   	pop    %ebx
  8087a0:	5e                   	pop    %esi
  8087a1:	5f                   	pop    %edi
  8087a2:	5d                   	pop    %ebp
  8087a3:	c3                   	ret    

008087a4 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  8087a4:	55                   	push   %ebp
  8087a5:	89 e5                	mov    %esp,%ebp
  8087a7:	57                   	push   %edi
  8087a8:	56                   	push   %esi
  8087a9:	53                   	push   %ebx
  8087aa:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  8087ad:	8b 45 08             	mov    0x8(%ebp),%eax
  8087b0:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  8087b3:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  8087b7:	0f b7 07             	movzwl (%edi),%eax
  8087ba:	50                   	push   %eax
  8087bb:	e8 22 ee ff ff       	call   8075e2 <ntohs>
  8087c0:	66 c1 e8 08          	shr    $0x8,%ax
  8087c4:	83 e0 0f             	and    $0xf,%eax
  8087c7:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  8087ce:	83 c4 10             	add    $0x10,%esp
  8087d1:	39 c3                	cmp    %eax,%ebx
  8087d3:	7c 29                	jl     8087fe <udp_input+0x5a>
  8087d5:	83 ec 0c             	sub    $0xc,%esp
  8087d8:	0f b7 07             	movzwl (%edi),%eax
  8087db:	50                   	push   %eax
  8087dc:	e8 01 ee ff ff       	call   8075e2 <ntohs>
  8087e1:	83 c4 08             	add    $0x8,%esp
  8087e4:	66 c1 e8 06          	shr    $0x6,%ax
  8087e8:	83 e0 3c             	and    $0x3c,%eax
  8087eb:	f7 d8                	neg    %eax
  8087ed:	98                   	cwtl   
  8087ee:	50                   	push   %eax
  8087ef:	ff 75 08             	pushl  0x8(%ebp)
  8087f2:	e8 5b be ff ff       	call   804652 <pbuf_header>
  8087f7:	83 c4 10             	add    $0x10,%esp
  8087fa:	84 c0                	test   %al,%al
  8087fc:	74 13                	je     808811 <udp_input+0x6d>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  8087fe:	83 ec 0c             	sub    $0xc,%esp
  808801:	ff 75 08             	pushl  0x8(%ebp)
  808804:	e8 1b bf ff ff       	call   804724 <pbuf_free>
    goto end;
  808809:	83 c4 10             	add    $0x10,%esp
  80880c:	e9 ce 02 00 00       	jmp    808adf <udp_input+0x33b>
  }

  udphdr = (struct udp_hdr *)p->payload;
  808811:	8b 45 08             	mov    0x8(%ebp),%eax
  808814:	8b 40 04             	mov    0x4(%eax),%eax
  808817:	89 c6                	mov    %eax,%esi
  808819:	89 45 d0             	mov    %eax,-0x30(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80881c:	83 ec 0c             	sub    $0xc,%esp
  80881f:	0f b7 00             	movzwl (%eax),%eax
  808822:	50                   	push   %eax
  808823:	e8 ba ed ff ff       	call   8075e2 <ntohs>
  808828:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  dest = ntohs(udphdr->dest);
  80882c:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  808830:	89 04 24             	mov    %eax,(%esp)
  808833:	e8 aa ed ff ff       	call   8075e2 <ntohs>
  808838:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  80883a:	83 c4 10             	add    $0x10,%esp
  80883d:	66 83 f8 44          	cmp    $0x44,%ax
  808841:	75 49                	jne    80888c <udp_input+0xe8>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  808843:	66 83 7d da 43       	cmpw   $0x43,-0x26(%ebp)
  808848:	0f 85 06 01 00 00    	jne    808954 <udp_input+0x1b0>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  80884e:	8b 45 0c             	mov    0xc(%ebp),%eax
  808851:	8b 40 20             	mov    0x20(%eax),%eax
  808854:	85 c0                	test   %eax,%eax
  808856:	0f 84 f8 00 00 00    	je     808954 <udp_input+0x1b0>
  80885c:	8b 40 08             	mov    0x8(%eax),%eax
  80885f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808862:	85 c0                	test   %eax,%eax
  808864:	0f 84 ea 00 00 00    	je     808954 <udp_input+0x1b0>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  80886a:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80886d:	0f 84 f7 00 00 00    	je     80896a <udp_input+0x1c6>
  808873:	8b 40 04             	mov    0x4(%eax),%eax
  808876:	85 c0                	test   %eax,%eax
  808878:	0f 84 ec 00 00 00    	je     80896a <udp_input+0x1c6>
  80887e:	3b 47 0c             	cmp    0xc(%edi),%eax
  808881:	0f 85 cd 00 00 00    	jne    808954 <udp_input+0x1b0>
  808887:	e9 de 00 00 00       	jmp    80896a <udp_input+0x1c6>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80888c:	8b 1d 54 b2 b3 00    	mov    0xb3b254,%ebx
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    local_match = 0;
    uncon_pcb = NULL;
  808892:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  808899:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8088a0:	8d 47 10             	lea    0x10(%edi),%eax
  8088a3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8088a6:	89 7d dc             	mov    %edi,-0x24(%ebp)
  8088a9:	0f b7 7d da          	movzwl -0x26(%ebp),%edi
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8088ad:	e9 91 00 00 00       	jmp    808943 <udp_input+0x19f>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8088b2:	66 3b 73 12          	cmp    0x12(%ebx),%si
  8088b6:	0f 85 81 00 00 00    	jne    80893d <udp_input+0x199>
  8088bc:	85 db                	test   %ebx,%ebx
  8088be:	74 23                	je     8088e3 <udp_input+0x13f>
          (ip_addr_isany(&pcb->local_ip) ||
  8088c0:	8b 03                	mov    (%ebx),%eax
  8088c2:	85 c0                	test   %eax,%eax
  8088c4:	74 1d                	je     8088e3 <udp_input+0x13f>
  8088c6:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8088c9:	3b 42 10             	cmp    0x10(%edx),%eax
  8088cc:	74 15                	je     8088e3 <udp_input+0x13f>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8088ce:	83 ec 08             	sub    $0x8,%esp
  8088d1:	ff 75 0c             	pushl  0xc(%ebp)
  8088d4:	ff 75 d4             	pushl  -0x2c(%ebp)
  8088d7:	e8 f1 da ff ff       	call   8063cd <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  8088dc:	83 c4 10             	add    $0x10,%esp
  8088df:	84 c0                	test   %al,%al
  8088e1:	74 5a                	je     80893d <udp_input+0x199>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  8088e3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  8088e7:	0f 85 db 01 00 00    	jne    808ac8 <udp_input+0x324>
  8088ed:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  8088f1:	83 e0 04             	and    $0x4,%eax
  8088f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8088f7:	0f 44 c3             	cmove  %ebx,%eax
  8088fa:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8088fd:	e9 c6 01 00 00       	jmp    808ac8 <udp_input+0x324>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  808902:	83 fb fc             	cmp    $0xfffffffc,%ebx
  808905:	74 0f                	je     808916 <udp_input+0x172>
          (ip_addr_isany(&pcb->remote_ip) ||
  808907:	8b 43 04             	mov    0x4(%ebx),%eax
  80890a:	85 c0                	test   %eax,%eax
  80890c:	74 08                	je     808916 <udp_input+0x172>
  80890e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808911:	3b 41 0c             	cmp    0xc(%ecx),%eax
  808914:	75 27                	jne    80893d <udp_input+0x199>
  808916:	8b 7d dc             	mov    -0x24(%ebp),%edi
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  808919:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80891c:	85 d2                	test   %edx,%edx
  80891e:	0f 84 b3 01 00 00    	je     808ad7 <udp_input+0x333>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  808924:	8b 43 0c             	mov    0xc(%ebx),%eax
  808927:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  80892a:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  80892f:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808932:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  808938:	e9 9a 01 00 00       	jmp    808ad7 <udp_input+0x333>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80893d:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808940:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808943:	85 db                	test   %ebx,%ebx
  808945:	0f 85 67 ff ff ff    	jne    8088b2 <udp_input+0x10e>
  80894b:	8b 7d dc             	mov    -0x24(%ebp),%edi
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  80894e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  808952:	75 16                	jne    80896a <udp_input+0x1c6>
  808954:	8b 45 0c             	mov    0xc(%ebp),%eax
  808957:	8b 57 10             	mov    0x10(%edi),%edx
  80895a:	39 50 04             	cmp    %edx,0x4(%eax)
  80895d:	0f 85 55 01 00 00    	jne    808ab8 <udp_input+0x314>
  808963:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  80896a:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80896d:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  808972:	74 38                	je     8089ac <udp_input+0x208>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  808974:	83 ec 0c             	sub    $0xc,%esp
  808977:	8b 45 08             	mov    0x8(%ebp),%eax
  80897a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80897e:	50                   	push   %eax
  80897f:	6a 11                	push   $0x11
  808981:	8d 47 10             	lea    0x10(%edi),%eax
  808984:	50                   	push   %eax
  808985:	8d 47 0c             	lea    0xc(%edi),%eax
  808988:	50                   	push   %eax
  808989:	ff 75 08             	pushl  0x8(%ebp)
  80898c:	e8 2b e9 ff ff       	call   8072bc <inet_chksum_pseudo>
  808991:	83 c4 20             	add    $0x20,%esp
  808994:	66 85 c0             	test   %ax,%ax
  808997:	74 13                	je     8089ac <udp_input+0x208>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  808999:	83 ec 0c             	sub    $0xc,%esp
  80899c:	ff 75 08             	pushl  0x8(%ebp)
  80899f:	e8 80 bd ff ff       	call   804724 <pbuf_free>
          goto end;
  8089a4:	83 c4 10             	add    $0x10,%esp
  8089a7:	e9 33 01 00 00       	jmp    808adf <udp_input+0x33b>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  8089ac:	83 ec 08             	sub    $0x8,%esp
  8089af:	6a f8                	push   $0xfffffff8
  8089b1:	ff 75 08             	pushl  0x8(%ebp)
  8089b4:	e8 99 bc ff ff       	call   804652 <pbuf_header>
  8089b9:	83 c4 10             	add    $0x10,%esp
  8089bc:	84 c0                	test   %al,%al
  8089be:	74 17                	je     8089d7 <udp_input+0x233>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8089c0:	83 ec 04             	sub    $0x4,%esp
  8089c3:	68 67 1f 81 00       	push   $0x811f67
  8089c8:	68 0a 01 00 00       	push   $0x10a
  8089cd:	68 92 1f 81 00       	push   $0x811f92
  8089d2:	e8 81 59 00 00       	call   80e358 <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  8089d7:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8089da:	85 c9                	test   %ecx,%ecx
  8089dc:	74 37                	je     808a15 <udp_input+0x271>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  8089de:	8b 41 18             	mov    0x18(%ecx),%eax
  8089e1:	85 c0                	test   %eax,%eax
  8089e3:	74 1d                	je     808a02 <udp_input+0x25e>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  8089e5:	83 ec 0c             	sub    $0xc,%esp
  8089e8:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
  8089ec:	52                   	push   %edx
  8089ed:	83 c7 0c             	add    $0xc,%edi
  8089f0:	57                   	push   %edi
  8089f1:	ff 75 08             	pushl  0x8(%ebp)
  8089f4:	51                   	push   %ecx
  8089f5:	ff 71 1c             	pushl  0x1c(%ecx)
  8089f8:	ff d0                	call   *%eax
  8089fa:	83 c4 20             	add    $0x20,%esp
  8089fd:	e9 dd 00 00 00       	jmp    808adf <udp_input+0x33b>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  808a02:	83 ec 0c             	sub    $0xc,%esp
  808a05:	ff 75 08             	pushl  0x8(%ebp)
  808a08:	e8 17 bd ff ff       	call   804724 <pbuf_free>
        goto end;
  808a0d:	83 c4 10             	add    $0x10,%esp
  808a10:	e9 ca 00 00 00       	jmp    808adf <udp_input+0x33b>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808a15:	83 ec 08             	sub    $0x8,%esp
  808a18:	ff 75 0c             	pushl  0xc(%ebp)
  808a1b:	8d 47 10             	lea    0x10(%edi),%eax
  808a1e:	50                   	push   %eax
  808a1f:	e8 a9 d9 ff ff       	call   8063cd <ip_addr_isbroadcast>
  808a24:	83 c4 10             	add    $0x10,%esp
  808a27:	84 c0                	test   %al,%al
  808a29:	75 7d                	jne    808aa8 <udp_input+0x304>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808a2b:	8b 5f 10             	mov    0x10(%edi),%ebx
  808a2e:	83 ec 0c             	sub    $0xc,%esp
  808a31:	68 00 00 00 f0       	push   $0xf0000000
  808a36:	e8 d5 ed ff ff       	call   807810 <ntohl>
  808a3b:	21 c3                	and    %eax,%ebx
  808a3d:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808a44:	e8 c7 ed ff ff       	call   807810 <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808a49:	83 c4 10             	add    $0x10,%esp
  808a4c:	39 c3                	cmp    %eax,%ebx
  808a4e:	74 58                	je     808aa8 <udp_input+0x304>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808a50:	83 ec 0c             	sub    $0xc,%esp
  808a53:	0f b7 07             	movzwl (%edi),%eax
  808a56:	50                   	push   %eax
  808a57:	e8 86 eb ff ff       	call   8075e2 <ntohs>
  808a5c:	83 c4 08             	add    $0x8,%esp
  808a5f:	66 c1 e8 08          	shr    $0x8,%ax
  808a63:	83 e0 0f             	and    $0xf,%eax
  808a66:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808a6d:	50                   	push   %eax
  808a6e:	ff 75 08             	pushl  0x8(%ebp)
  808a71:	e8 dc bb ff ff       	call   804652 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808a76:	83 c4 10             	add    $0x10,%esp
  808a79:	8b 45 08             	mov    0x8(%ebp),%eax
  808a7c:	3b 78 04             	cmp    0x4(%eax),%edi
  808a7f:	74 17                	je     808a98 <udp_input+0x2f4>
  808a81:	83 ec 04             	sub    $0x4,%esp
  808a84:	68 a6 1f 81 00       	push   $0x811fa6
  808a89:	68 25 01 00 00       	push   $0x125
  808a8e:	68 92 1f 81 00       	push   $0x811f92
  808a93:	e8 c0 58 00 00       	call   80e358 <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808a98:	83 ec 08             	sub    $0x8,%esp
  808a9b:	6a 03                	push   $0x3
  808a9d:	ff 75 08             	pushl  0x8(%ebp)
  808aa0:	e8 8b 56 00 00       	call   80e130 <icmp_dest_unreach>
  808aa5:	83 c4 10             	add    $0x10,%esp
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  808aa8:	83 ec 0c             	sub    $0xc,%esp
  808aab:	ff 75 08             	pushl  0x8(%ebp)
  808aae:	e8 71 bc ff ff       	call   804724 <pbuf_free>
  808ab3:	83 c4 10             	add    $0x10,%esp
  808ab6:	eb 27                	jmp    808adf <udp_input+0x33b>
    }
  } else {
    pbuf_free(p);
  808ab8:	83 ec 0c             	sub    $0xc,%esp
  808abb:	ff 75 08             	pushl  0x8(%ebp)
  808abe:	e8 61 bc ff ff       	call   804724 <pbuf_free>
  808ac3:	83 c4 10             	add    $0x10,%esp
  }
end:
  PERF_STOP("udp_input");
}
  808ac6:	eb 17                	jmp    808adf <udp_input+0x33b>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  808ac8:	66 3b 7b 14          	cmp    0x14(%ebx),%di
  808acc:	0f 85 6b fe ff ff    	jne    80893d <udp_input+0x199>
  808ad2:	e9 2b fe ff ff       	jmp    808902 <udp_input+0x15e>
  808ad7:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  808ada:	e9 8b fe ff ff       	jmp    80896a <udp_input+0x1c6>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  808adf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808ae2:	5b                   	pop    %ebx
  808ae3:	5e                   	pop    %esi
  808ae4:	5f                   	pop    %edi
  808ae5:	5d                   	pop    %ebp
  808ae6:	c3                   	ret    

00808ae7 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808ae7:	55                   	push   %ebp
  808ae8:	89 e5                	mov    %esp,%ebp
  808aea:	57                   	push   %edi
  808aeb:	56                   	push   %esi
  808aec:	53                   	push   %ebx
  808aed:	83 ec 0c             	sub    $0xc,%esp
  808af0:	8b 55 08             	mov    0x8(%ebp),%edx
  808af3:	8b 7d 0c             	mov    0xc(%ebp),%edi
  808af6:	8b 75 10             	mov    0x10(%ebp),%esi
  808af9:	89 f1                	mov    %esi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808afb:	a1 54 b2 b3 00       	mov    0xb3b254,%eax

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  808b00:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808b05:	eb 27                	jmp    808b2e <udp_bind+0x47>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  808b07:	39 d0                	cmp    %edx,%eax
  808b09:	75 20                	jne    808b2b <udp_bind+0x44>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808b0b:	84 db                	test   %bl,%bl
  808b0d:	74 17                	je     808b26 <udp_bind+0x3f>
  808b0f:	83 ec 04             	sub    $0x4,%esp
  808b12:	68 ba 1f 81 00       	push   $0x811fba
  808b17:	68 41 02 00 00       	push   $0x241
  808b1c:	68 92 1f 81 00       	push   $0x811f92
  808b21:	e8 32 58 00 00       	call   80e358 <_panic>
      /* pcb already in list, just rebind */
      rebind = 1;
  808b26:	bb 01 00 00 00       	mov    $0x1,%ebx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808b2b:	8b 40 0c             	mov    0xc(%eax),%eax
  808b2e:	85 c0                	test   %eax,%eax
  808b30:	75 d5                	jne    808b07 <udp_bind+0x20>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808b32:	85 ff                	test   %edi,%edi
  808b34:	74 04                	je     808b3a <udp_bind+0x53>
  808b36:	8b 07                	mov    (%edi),%eax
  808b38:	eb 05                	jmp    808b3f <udp_bind+0x58>
  808b3a:	b8 00 00 00 00       	mov    $0x0,%eax
  808b3f:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808b41:	66 85 f6             	test   %si,%si
  808b44:	75 2e                	jne    808b74 <udp_bind+0x8d>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808b46:	8b 35 54 b2 b3 00    	mov    0xb3b254,%esi
  808b4c:	89 f0                	mov    %esi,%eax
  if (port == 0) {
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  808b4e:	b9 00 10 00 00       	mov    $0x1000,%ecx
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808b53:	eb 10                	jmp    808b65 <udp_bind+0x7e>
      if (ipcb->local_port == port) {
  808b55:	66 3b 48 12          	cmp    0x12(%eax),%cx
  808b59:	75 07                	jne    808b62 <udp_bind+0x7b>
        /* port is already used by another udp_pcb */
        port++;
  808b5b:	83 c1 01             	add    $0x1,%ecx
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  808b5e:	89 f0                	mov    %esi,%eax
  808b60:	eb 03                	jmp    808b65 <udp_bind+0x7e>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808b62:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808b65:	85 c0                	test   %eax,%eax
  808b67:	74 07                	je     808b70 <udp_bind+0x89>
  808b69:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808b6e:	75 e5                	jne    808b55 <udp_bind+0x6e>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  808b70:	85 c0                	test   %eax,%eax
  808b72:	75 22                	jne    808b96 <udp_bind+0xaf>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808b74:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808b78:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  pcb->local_port = port;
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  808b7d:	84 db                	test   %bl,%bl
  808b7f:	75 1a                	jne    808b9b <udp_bind+0xb4>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  808b81:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808b86:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808b89:	89 15 54 b2 b3 00    	mov    %edx,0xb3b254
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808b8f:	b8 00 00 00 00       	mov    $0x0,%eax
  808b94:	eb 05                	jmp    808b9b <udp_bind+0xb4>
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  808b96:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  808b9b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808b9e:	5b                   	pop    %ebx
  808b9f:	5e                   	pop    %esi
  808ba0:	5f                   	pop    %edi
  808ba1:	5d                   	pop    %ebp
  808ba2:	c3                   	ret    

00808ba3 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  808ba3:	55                   	push   %ebp
  808ba4:	89 e5                	mov    %esp,%ebp
  808ba6:	57                   	push   %edi
  808ba7:	56                   	push   %esi
  808ba8:	53                   	push   %ebx
  808ba9:	83 ec 1c             	sub    $0x1c,%esp
  808bac:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808baf:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  808bb2:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808bb7:	75 17                	jne    808bd0 <udp_sendto_if+0x2d>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808bb9:	83 ec 04             	sub    $0x4,%esp
  808bbc:	6a 00                	push   $0x0
  808bbe:	53                   	push   %ebx
  808bbf:	53                   	push   %ebx
  808bc0:	e8 22 ff ff ff       	call   808ae7 <udp_bind>
    if (err != ERR_OK) {
  808bc5:	83 c4 10             	add    $0x10,%esp
  808bc8:	84 c0                	test   %al,%al
  808bca:	0f 85 54 01 00 00    	jne    808d24 <udp_sendto_if+0x181>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  808bd0:	83 ec 08             	sub    $0x8,%esp
  808bd3:	6a 08                	push   $0x8
  808bd5:	ff 75 0c             	pushl  0xc(%ebp)
  808bd8:	e8 75 ba ff ff       	call   804652 <pbuf_header>
  808bdd:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  808be0:	8b 75 0c             	mov    0xc(%ebp),%esi
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  808be3:	84 c0                	test   %al,%al
  808be5:	74 2a                	je     808c11 <udp_sendto_if+0x6e>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  808be7:	83 ec 04             	sub    $0x4,%esp
  808bea:	6a 00                	push   $0x0
  808bec:	6a 08                	push   $0x8
  808bee:	6a 01                	push   $0x1
  808bf0:	e8 f5 bb ff ff       	call   8047ea <pbuf_alloc>
  808bf5:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  808bf7:	83 c4 10             	add    $0x10,%esp
  808bfa:	85 c0                	test   %eax,%eax
  808bfc:	0f 84 1d 01 00 00    	je     808d1f <udp_sendto_if+0x17c>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  808c02:	83 ec 08             	sub    $0x8,%esp
  808c05:	ff 75 0c             	pushl  0xc(%ebp)
  808c08:	50                   	push   %eax
  808c09:	e8 0a c0 ff ff       	call   804c18 <pbuf_chain>
  808c0e:	83 c4 10             	add    $0x10,%esp
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808c11:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  808c16:	77 17                	ja     808c2f <udp_sendto_if+0x8c>
  808c18:	83 ec 04             	sub    $0x4,%esp
  808c1b:	68 c8 1f 81 00       	push   $0x811fc8
  808c20:	68 b2 01 00 00       	push   $0x1b2
  808c25:	68 92 1f 81 00       	push   $0x811f92
  808c2a:	e8 29 57 00 00       	call   80e358 <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  808c2f:	8b 46 04             	mov    0x4(%esi),%eax
  808c32:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  udphdr->src = htons(pcb->local_port);
  808c35:	83 ec 0c             	sub    $0xc,%esp
  808c38:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  808c3c:	50                   	push   %eax
  808c3d:	e8 93 e9 ff ff       	call   8075d5 <htons>
  808c42:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808c45:	66 89 01             	mov    %ax,(%ecx)
  udphdr->dest = htons(dst_port);
  808c48:	0f b7 ff             	movzwl %di,%edi
  808c4b:	89 3c 24             	mov    %edi,(%esp)
  808c4e:	e8 82 e9 ff ff       	call   8075d5 <htons>
  808c53:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808c56:	66 89 41 02          	mov    %ax,0x2(%ecx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  808c5a:	66 c7 41 06 00 00    	movw   $0x0,0x6(%ecx)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  808c60:	89 df                	mov    %ebx,%edi
  808c62:	83 c4 10             	add    $0x10,%esp
  808c65:	85 db                	test   %ebx,%ebx
  808c67:	74 06                	je     808c6f <udp_sendto_if+0xcc>
  808c69:	8b 03                	mov    (%ebx),%eax
  808c6b:	85 c0                	test   %eax,%eax
  808c6d:	75 08                	jne    808c77 <udp_sendto_if+0xd4>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  808c6f:	8b 45 18             	mov    0x18(%ebp),%eax
  808c72:	8d 78 04             	lea    0x4(%eax),%edi
  808c75:	eb 2c                	jmp    808ca3 <udp_sendto_if+0x100>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  808c77:	8b 55 18             	mov    0x18(%ebp),%edx
  808c7a:	3b 42 04             	cmp    0x4(%edx),%eax
  808c7d:	74 24                	je     808ca3 <udp_sendto_if+0x100>
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  808c7f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  808c84:	3b 75 0c             	cmp    0xc(%ebp),%esi
  808c87:	0f 84 97 00 00 00    	je     808d24 <udp_sendto_if+0x181>
        /* free the header pbuf */
        pbuf_free(q);
  808c8d:	83 ec 0c             	sub    $0xc,%esp
  808c90:	56                   	push   %esi
  808c91:	e8 8e ba ff ff       	call   804724 <pbuf_free>
  808c96:	83 c4 10             	add    $0x10,%esp
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  808c99:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  808c9e:	e9 81 00 00 00       	jmp    808d24 <udp_sendto_if+0x181>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  808ca3:	83 ec 0c             	sub    $0xc,%esp
  808ca6:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808caa:	50                   	push   %eax
  808cab:	e8 25 e9 ff ff       	call   8075d5 <htons>
  808cb0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808cb3:	66 89 42 04          	mov    %ax,0x4(%edx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  808cb7:	83 c4 10             	add    $0x10,%esp
  808cba:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  808cbe:	75 29                	jne    808ce9 <udp_sendto_if+0x146>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808cc0:	83 ec 0c             	sub    $0xc,%esp
  808cc3:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808cc7:	50                   	push   %eax
  808cc8:	6a 11                	push   $0x11
  808cca:	ff 75 10             	pushl  0x10(%ebp)
  808ccd:	57                   	push   %edi
  808cce:	56                   	push   %esi
  808ccf:	e8 e8 e5 ff ff       	call   8072bc <inet_chksum_pseudo>
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  808cd4:	83 c4 20             	add    $0x20,%esp
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808cd7:	66 85 c0             	test   %ax,%ax
  808cda:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  808cdf:	0f 44 c2             	cmove  %edx,%eax
  808ce2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808ce5:	66 89 42 06          	mov    %ax,0x6(%edx)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  808ce9:	83 ec 04             	sub    $0x4,%esp
  808cec:	ff 75 18             	pushl  0x18(%ebp)
  808cef:	6a 11                	push   $0x11
  808cf1:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  808cf5:	50                   	push   %eax
  808cf6:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  808cfa:	50                   	push   %eax
  808cfb:	ff 75 10             	pushl  0x10(%ebp)
  808cfe:	57                   	push   %edi
  808cff:	56                   	push   %esi
  808d00:	e8 76 da ff ff       	call   80677b <ip_output_if>
  808d05:	89 c3                	mov    %eax,%ebx
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  808d07:	83 c4 20             	add    $0x20,%esp
  808d0a:	3b 75 0c             	cmp    0xc(%ebp),%esi
  808d0d:	74 15                	je     808d24 <udp_sendto_if+0x181>
    /* free the header pbuf */
    pbuf_free(q);
  808d0f:	83 ec 0c             	sub    $0xc,%esp
  808d12:	56                   	push   %esi
  808d13:	e8 0c ba ff ff       	call   804724 <pbuf_free>
  808d18:	83 c4 10             	add    $0x10,%esp
    q = NULL;
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  808d1b:	89 d8                	mov    %ebx,%eax
  808d1d:	eb 05                	jmp    808d24 <udp_sendto_if+0x181>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  808d1f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  808d24:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808d27:	5b                   	pop    %ebx
  808d28:	5e                   	pop    %esi
  808d29:	5f                   	pop    %edi
  808d2a:	5d                   	pop    %ebp
  808d2b:	c3                   	ret    

00808d2c <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  808d2c:	55                   	push   %ebp
  808d2d:	89 e5                	mov    %esp,%ebp
  808d2f:	56                   	push   %esi
  808d30:	53                   	push   %ebx
  808d31:	8b 75 10             	mov    0x10(%ebp),%esi
  808d34:	8b 5d 14             	mov    0x14(%ebp),%ebx

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  808d37:	83 ec 0c             	sub    $0xc,%esp
  808d3a:	56                   	push   %esi
  808d3b:	e8 d9 d6 ff ff       	call   806419 <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  808d40:	83 c4 10             	add    $0x10,%esp
  808d43:	85 c0                	test   %eax,%eax
  808d45:	74 19                	je     808d60 <udp_sendto+0x34>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  808d47:	83 ec 0c             	sub    $0xc,%esp
  808d4a:	50                   	push   %eax
  808d4b:	0f b7 db             	movzwl %bx,%ebx
  808d4e:	53                   	push   %ebx
  808d4f:	56                   	push   %esi
  808d50:	ff 75 0c             	pushl  0xc(%ebp)
  808d53:	ff 75 08             	pushl  0x8(%ebp)
  808d56:	e8 48 fe ff ff       	call   808ba3 <udp_sendto_if>
  808d5b:	83 c4 20             	add    $0x20,%esp
  808d5e:	eb 05                	jmp    808d65 <udp_sendto+0x39>

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  808d60:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
}
  808d65:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808d68:	5b                   	pop    %ebx
  808d69:	5e                   	pop    %esi
  808d6a:	5d                   	pop    %ebp
  808d6b:	c3                   	ret    

00808d6c <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  808d6c:	55                   	push   %ebp
  808d6d:	89 e5                	mov    %esp,%ebp
  808d6f:	83 ec 08             	sub    $0x8,%esp
  808d72:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  808d75:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  808d79:	52                   	push   %edx
  808d7a:	8d 50 04             	lea    0x4(%eax),%edx
  808d7d:	52                   	push   %edx
  808d7e:	ff 75 0c             	pushl  0xc(%ebp)
  808d81:	50                   	push   %eax
  808d82:	e8 a5 ff ff ff       	call   808d2c <udp_sendto>
}
  808d87:	c9                   	leave  
  808d88:	c3                   	ret    

00808d89 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808d89:	55                   	push   %ebp
  808d8a:	89 e5                	mov    %esp,%ebp
  808d8c:	57                   	push   %edi
  808d8d:	56                   	push   %esi
  808d8e:	53                   	push   %ebx
  808d8f:	83 ec 0c             	sub    $0xc,%esp
  808d92:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808d95:	8b 75 0c             	mov    0xc(%ebp),%esi
  808d98:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  808d9b:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808da0:	75 13                	jne    808db5 <udp_connect+0x2c>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808da2:	83 ec 04             	sub    $0x4,%esp
  808da5:	6a 00                	push   $0x0
  808da7:	53                   	push   %ebx
  808da8:	53                   	push   %ebx
  808da9:	e8 39 fd ff ff       	call   808ae7 <udp_bind>
    if (err != ERR_OK)
  808dae:	83 c4 10             	add    $0x10,%esp
  808db1:	84 c0                	test   %al,%al
  808db3:	75 3d                	jne    808df2 <udp_connect+0x69>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  808db5:	85 f6                	test   %esi,%esi
  808db7:	74 04                	je     808dbd <udp_connect+0x34>
  808db9:	8b 06                	mov    (%esi),%eax
  808dbb:	eb 05                	jmp    808dc2 <udp_connect+0x39>
  808dbd:	b8 00 00 00 00       	mov    $0x0,%eax
  808dc2:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  808dc5:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  808dc9:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808dcd:	8b 15 54 b2 b3 00    	mov    0xb3b254,%edx
  808dd3:	89 d0                	mov    %edx,%eax
  808dd5:	eb 07                	jmp    808dde <udp_connect+0x55>
    if (pcb == ipcb) {
  808dd7:	39 d8                	cmp    %ebx,%eax
  808dd9:	74 12                	je     808ded <udp_connect+0x64>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808ddb:	8b 40 0c             	mov    0xc(%eax),%eax
  808dde:	85 c0                	test   %eax,%eax
  808de0:	75 f5                	jne    808dd7 <udp_connect+0x4e>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  808de2:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  808de5:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  return ERR_OK;
  808deb:	eb 05                	jmp    808df2 <udp_connect+0x69>

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
  808ded:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
  808df2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808df5:	5b                   	pop    %ebx
  808df6:	5e                   	pop    %esi
  808df7:	5f                   	pop    %edi
  808df8:	5d                   	pop    %ebp
  808df9:	c3                   	ret    

00808dfa <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  808dfa:	55                   	push   %ebp
  808dfb:	89 e5                	mov    %esp,%ebp
  808dfd:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  808e00:	8b 15 04 1c 81 00    	mov    0x811c04,%edx
  808e06:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  808e09:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  808e0f:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  808e13:	5d                   	pop    %ebp
  808e14:	c3                   	ret    

00808e15 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  808e15:	55                   	push   %ebp
  808e16:	89 e5                	mov    %esp,%ebp
  808e18:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  808e1b:	8b 55 0c             	mov    0xc(%ebp),%edx
  808e1e:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  808e21:	8b 55 10             	mov    0x10(%ebp),%edx
  808e24:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  808e27:	5d                   	pop    %ebp
  808e28:	c3                   	ret    

00808e29 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  808e29:	55                   	push   %ebp
  808e2a:	89 e5                	mov    %esp,%ebp
  808e2c:	83 ec 08             	sub    $0x8,%esp
  808e2f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  808e32:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808e37:	39 c8                	cmp    %ecx,%eax
  808e39:	75 1e                	jne    808e59 <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  808e3b:	8b 40 0c             	mov    0xc(%eax),%eax
  808e3e:	a3 54 b2 b3 00       	mov    %eax,0xb3b254
  808e43:	eb 18                	jmp    808e5d <udp_remove+0x34>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  808e45:	8b 50 0c             	mov    0xc(%eax),%edx
  808e48:	39 d1                	cmp    %edx,%ecx
  808e4a:	75 0a                	jne    808e56 <udp_remove+0x2d>
  808e4c:	85 d2                	test   %edx,%edx
  808e4e:	74 06                	je     808e56 <udp_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  808e50:	8b 51 0c             	mov    0xc(%ecx),%edx
  808e53:	89 50 0c             	mov    %edx,0xc(%eax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  808e56:	8b 40 0c             	mov    0xc(%eax),%eax
  808e59:	85 c0                	test   %eax,%eax
  808e5b:	75 e8                	jne    808e45 <udp_remove+0x1c>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  808e5d:	83 ec 08             	sub    $0x8,%esp
  808e60:	51                   	push   %ecx
  808e61:	6a 01                	push   $0x1
  808e63:	e8 49 b5 ff ff       	call   8043b1 <memp_free>
}
  808e68:	83 c4 10             	add    $0x10,%esp
  808e6b:	c9                   	leave  
  808e6c:	c3                   	ret    

00808e6d <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  808e6d:	55                   	push   %ebp
  808e6e:	89 e5                	mov    %esp,%ebp
  808e70:	53                   	push   %ebx
  808e71:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  808e74:	6a 01                	push   $0x1
  808e76:	e8 e0 b4 ff ff       	call   80435b <memp_malloc>
  808e7b:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  808e7d:	83 c4 10             	add    $0x10,%esp
  808e80:	85 c0                	test   %eax,%eax
  808e82:	74 14                	je     808e98 <udp_new+0x2b>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  808e84:	83 ec 04             	sub    $0x4,%esp
  808e87:	6a 20                	push   $0x20
  808e89:	6a 00                	push   $0x0
  808e8b:	50                   	push   %eax
  808e8c:	e8 6a 5c 00 00       	call   80eafb <memset>
    pcb->ttl = UDP_TTL;
  808e91:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  808e95:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  808e98:	89 d8                	mov    %ebx,%eax
  808e9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808e9d:	c9                   	leave  
  808e9e:	c3                   	ret    

00808e9f <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  808e9f:	55                   	push   %ebp
  808ea0:	89 e5                	mov    %esp,%ebp
  808ea2:	56                   	push   %esi
  808ea3:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  808ea4:	85 c0                	test   %eax,%eax
  808ea6:	75 17                	jne    808ebf <free_etharp_q+0x20>
  808ea8:	83 ec 04             	sub    $0x4,%esp
  808eab:	68 08 17 81 00       	push   $0x811708
  808eb0:	68 93 00 00 00       	push   $0x93
  808eb5:	68 f6 1f 81 00       	push   $0x811ff6
  808eba:	e8 99 54 00 00       	call   80e358 <_panic>
  808ebf:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  808ec1:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  808ec5:	75 17                	jne    808ede <free_etharp_q+0x3f>
  808ec7:	83 ec 04             	sub    $0x4,%esp
  808eca:	68 0e 20 81 00       	push   $0x81200e
  808ecf:	68 94 00 00 00       	push   $0x94
  808ed4:	68 f6 1f 81 00       	push   $0x811ff6
  808ed9:	e8 7a 54 00 00       	call   80e358 <_panic>
  while (q) {
    r = q;
    q = q->next;
  808ede:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  808ee0:	8b 43 04             	mov    0x4(%ebx),%eax
  808ee3:	85 c0                	test   %eax,%eax
  808ee5:	75 17                	jne    808efe <free_etharp_q+0x5f>
  808ee7:	83 ec 04             	sub    $0x4,%esp
  808eea:	68 1b 20 81 00       	push   $0x81201b
  808eef:	68 98 00 00 00       	push   $0x98
  808ef4:	68 f6 1f 81 00       	push   $0x811ff6
  808ef9:	e8 5a 54 00 00       	call   80e358 <_panic>
    pbuf_free(r->p);
  808efe:	83 ec 0c             	sub    $0xc,%esp
  808f01:	50                   	push   %eax
  808f02:	e8 1d b8 ff ff       	call   804724 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  808f07:	83 c4 08             	add    $0x8,%esp
  808f0a:	53                   	push   %ebx
  808f0b:	6a 0a                	push   $0xa
  808f0d:	e8 9f b4 ff ff       	call   8043b1 <memp_free>
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
    r = q;
    q = q->next;
  808f12:	89 f3                	mov    %esi,%ebx
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  808f14:	83 c4 10             	add    $0x10,%esp
  808f17:	85 f6                	test   %esi,%esi
  808f19:	75 c3                	jne    808ede <free_etharp_q+0x3f>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  808f1b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808f1e:	5b                   	pop    %ebx
  808f1f:	5e                   	pop    %esi
  808f20:	5d                   	pop    %ebp
  808f21:	c3                   	ret    

00808f22 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  808f22:	55                   	push   %ebp
  808f23:	89 e5                	mov    %esp,%ebp
  808f25:	57                   	push   %edi
  808f26:	56                   	push   %esi
  808f27:	53                   	push   %ebx
  808f28:	83 ec 1c             	sub    $0x1c,%esp
  808f2b:	89 d7                	mov    %edx,%edi
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  808f2d:	85 c0                	test   %eax,%eax
  808f2f:	74 2e                	je     808f5f <find_entry+0x3d>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  808f31:	0f b6 15 00 4a b3 00 	movzbl 0xb34a00,%edx
  808f38:	0f b6 ca             	movzbl %dl,%ecx
  808f3b:	6b d9 1c             	imul   $0x1c,%ecx,%ebx
  808f3e:	83 bb 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ebx)
  808f45:	75 37                	jne    808f7e <find_entry+0x5c>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  808f47:	8b 8b 24 4a b3 00    	mov    0xb34a24(%ebx),%ecx
  808f4d:	39 08                	cmp    %ecx,(%eax)
  808f4f:	75 4c                	jne    808f9d <find_entry+0x7b>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  808f51:	89 d0                	mov    %edx,%eax
  808f53:	e9 22 02 00 00       	jmp    80917a <find_entry+0x258>
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  808f58:	80 f9 0a             	cmp    $0xa,%cl
  808f5b:	75 78                	jne    808fd5 <find_entry+0xb3>
  808f5d:	eb 5b                	jmp    808fba <find_entry+0x98>
  808f5f:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  808f63:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  808f67:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  808f6b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  808f6f:	ba 00 00 00 00       	mov    $0x0,%edx
  808f74:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  808f78:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  808f7c:	eb 3c                	jmp    808fba <find_entry+0x98>
  808f7e:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  808f82:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  808f86:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  808f8a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  808f8e:	ba 00 00 00 00       	mov    $0x0,%edx
  808f93:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  808f97:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  808f9b:	eb 1d                	jmp    808fba <find_entry+0x98>
  808f9d:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  808fa1:	c6 45 e4 0a          	movb   $0xa,-0x1c(%ebp)
  808fa5:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  808fa9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  808fad:	ba 00 00 00 00       	mov    $0x0,%edx
  808fb2:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  808fb6:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  808fba:	0f b6 ca             	movzbl %dl,%ecx
  808fbd:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  808fc0:	83 b9 30 4a b3 00 00 	cmpl   $0x0,0xb34a30(%ecx)
  808fc7:	75 07                	jne    808fd0 <find_entry+0xae>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  808fc9:	89 d1                	mov    %edx,%ecx
  808fcb:	e9 a3 00 00 00       	jmp    809073 <find_entry+0x151>
  808fd0:	b9 0a 00 00 00       	mov    $0xa,%ecx
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  808fd5:	0f b6 da             	movzbl %dl,%ebx
  808fd8:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  808fdb:	8b b6 30 4a b3 00    	mov    0xb34a30(%esi),%esi
  808fe1:	83 fe 01             	cmp    $0x1,%esi
  808fe4:	75 55                	jne    80903b <find_entry+0x119>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  808fe6:	85 c0                	test   %eax,%eax
  808fe8:	74 1a                	je     809004 <find_entry+0xe2>
  808fea:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  808fed:	8b b6 24 4a b3 00    	mov    0xb34a24(%esi),%esi
  808ff3:	39 30                	cmp    %esi,(%eax)
  808ff5:	75 0d                	jne    809004 <find_entry+0xe2>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  808ff7:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  808ffd:	89 d0                	mov    %edx,%eax
  808fff:	e9 76 01 00 00       	jmp    80917a <find_entry+0x258>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  809004:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  809007:	83 be 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%esi)
  80900e:	74 14                	je     809024 <find_entry+0x102>
        if (arp_table[i].ctime >= age_queue) {
  809010:	0f b6 9e 34 4a b3 00 	movzbl 0xb34a34(%esi),%ebx
  809017:	3a 5d e7             	cmp    -0x19(%ebp),%bl
  80901a:	72 57                	jb     809073 <find_entry+0x151>
          old_queue = i;
  80901c:	88 55 e4             	mov    %dl,-0x1c(%ebp)
          age_queue = arp_table[i].ctime;
  80901f:	88 5d e7             	mov    %bl,-0x19(%ebp)
  809022:	eb 4f                	jmp    809073 <find_entry+0x151>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  809024:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  809027:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  80902e:	3a 5d e3             	cmp    -0x1d(%ebp),%bl
  809031:	72 40                	jb     809073 <find_entry+0x151>
          old_pending = i;
  809033:	88 55 e2             	mov    %dl,-0x1e(%ebp)
          age_pending = arp_table[i].ctime;
  809036:	88 5d e3             	mov    %bl,-0x1d(%ebp)
  809039:	eb 38                	jmp    809073 <find_entry+0x151>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80903b:	83 fe 02             	cmp    $0x2,%esi
  80903e:	75 33                	jne    809073 <find_entry+0x151>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809040:	85 c0                	test   %eax,%eax
  809042:	74 1a                	je     80905e <find_entry+0x13c>
  809044:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  809047:	8b b6 24 4a b3 00    	mov    0xb34a24(%esi),%esi
  80904d:	39 30                	cmp    %esi,(%eax)
  80904f:	75 0d                	jne    80905e <find_entry+0x13c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  809051:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  809057:	89 d0                	mov    %edx,%eax
  809059:	e9 1c 01 00 00       	jmp    80917a <find_entry+0x258>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  80905e:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  809061:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  809068:	3a 5d e6             	cmp    -0x1a(%ebp),%bl
  80906b:	72 06                	jb     809073 <find_entry+0x151>
        old_stable = i;
  80906d:	88 55 e5             	mov    %dl,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  809070:	88 5d e6             	mov    %bl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809073:	83 c2 01             	add    $0x1,%edx
  809076:	80 fa 09             	cmp    $0x9,%dl
  809079:	0f 86 d9 fe ff ff    	jbe    808f58 <find_entry+0x36>
  80907f:	89 fa                	mov    %edi,%edx
  809081:	89 c3                	mov    %eax,%ebx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  809083:	80 f9 0a             	cmp    $0xa,%cl
  809086:	75 0e                	jne    809096 <find_entry+0x174>
  809088:	f6 c2 01             	test   $0x1,%dl
  80908b:	0f 85 de 00 00 00    	jne    80916f <find_entry+0x24d>
  809091:	e9 bd 00 00 00       	jmp    809153 <find_entry+0x231>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809096:	f6 c2 02             	test   $0x2,%dl
  809099:	0f 85 bb 00 00 00    	jne    80915a <find_entry+0x238>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  80909f:	89 ce                	mov    %ecx,%esi
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  8090a1:	80 f9 09             	cmp    $0x9,%cl
  8090a4:	7e 5f                	jle    809105 <find_entry+0x1e3>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  8090a6:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  8090aa:	3c 09                	cmp    $0x9,%al
  8090ac:	7f 28                	jg     8090d6 <find_entry+0x1b4>
    /* recycle oldest stable*/
    i = old_stable;
  8090ae:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  8090b0:	0f b6 c0             	movzbl %al,%eax
  8090b3:	6b c0 1c             	imul   $0x1c,%eax,%eax
  8090b6:	83 b8 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%eax)
  8090bd:	74 46                	je     809105 <find_entry+0x1e3>
  8090bf:	83 ec 04             	sub    $0x4,%esp
  8090c2:	68 28 20 81 00       	push   $0x812028
  8090c7:	68 75 01 00 00       	push   $0x175
  8090cc:	68 f6 1f 81 00       	push   $0x811ff6
  8090d1:	e8 82 52 00 00       	call   80e358 <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  8090d6:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
    /* recycle oldest pending */
    i = old_pending;
  8090da:	89 c6                	mov    %eax,%esi
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  8090dc:	3c 09                	cmp    $0x9,%al
  8090de:	7e 25                	jle    809105 <find_entry+0x1e3>
    /* recycle oldest pending */
    i = old_pending;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  8090e0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8090e4:	3c 09                	cmp    $0x9,%al
  8090e6:	7f 79                	jg     809161 <find_entry+0x23f>
    /* recycle oldest pending */
    i = old_queue;
  8090e8:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  8090ea:	0f b6 f8             	movzbl %al,%edi
  8090ed:	6b ff 1c             	imul   $0x1c,%edi,%edi
  8090f0:	8b 87 20 4a b3 00    	mov    0xb34a20(%edi),%eax
  8090f6:	e8 a4 fd ff ff       	call   808e9f <free_etharp_q>
    arp_table[i].q = NULL;
  8090fb:	c7 87 20 4a b3 00 00 	movl   $0x0,0xb34a20(%edi)
  809102:	00 00 00 
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  809105:	89 f0                	mov    %esi,%eax
  809107:	3c 09                	cmp    $0x9,%al
  809109:	76 17                	jbe    809122 <find_entry+0x200>
  80910b:	83 ec 04             	sub    $0x4,%esp
  80910e:	68 3f 20 81 00       	push   $0x81203f
  809113:	68 8b 01 00 00       	push   $0x18b
  809118:	68 f6 1f 81 00       	push   $0x811ff6
  80911d:	e8 36 52 00 00       	call   80e358 <_panic>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  809122:	89 f0                	mov    %esi,%eax
  809124:	0f b6 c0             	movzbl %al,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  809127:	6b d0 1c             	imul   $0x1c,%eax,%edx
  80912a:	c7 82 30 4a b3 00 00 	movl   $0x0,0xb34a30(%edx)
  809131:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  809134:	85 db                	test   %ebx,%ebx
  809136:	74 08                	je     809140 <find_entry+0x21e>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809138:	8b 0b                	mov    (%ebx),%ecx
  80913a:	89 8a 24 4a b3 00    	mov    %ecx,0xb34a24(%edx)
  }
  arp_table[i].ctime = 0;
  809140:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809143:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  80914a:	89 f0                	mov    %esi,%eax
  80914c:	a2 00 4a b3 00       	mov    %al,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  809151:	eb 27                	jmp    80917a <find_entry+0x258>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809153:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809158:	eb 20                	jmp    80917a <find_entry+0x258>
  80915a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80915f:	eb 19                	jmp    80917a <find_entry+0x258>
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  809161:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809166:	eb 12                	jmp    80917a <find_entry+0x258>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809168:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80916d:	eb 0b                	jmp    80917a <find_entry+0x258>
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  80916f:	f6 c2 02             	test   $0x2,%dl
  809172:	0f 84 2e ff ff ff    	je     8090a6 <find_entry+0x184>
  809178:	eb ee                	jmp    809168 <find_entry+0x246>
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  80917a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80917d:	5b                   	pop    %ebx
  80917e:	5e                   	pop    %esi
  80917f:	5f                   	pop    %edi
  809180:	5d                   	pop    %ebp
  809181:	c3                   	ret    

00809182 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  809182:	55                   	push   %ebp
  809183:	89 e5                	mov    %esp,%ebp
  809185:	57                   	push   %edi
  809186:	56                   	push   %esi
  809187:	53                   	push   %ebx
  809188:	83 ec 1c             	sub    $0x1c,%esp
  80918b:	89 c6                	mov    %eax,%esi
  80918d:	89 55 e0             	mov    %edx,-0x20(%ebp)
  809190:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  809193:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809196:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80919a:	74 17                	je     8091b3 <etharp_send_ip+0x31>
  80919c:	83 ec 04             	sub    $0x4,%esp
  80919f:	68 6c 20 81 00       	push   $0x81206c
  8091a4:	68 b3 01 00 00       	push   $0x1b3
  8091a9:	68 f6 1f 81 00       	push   $0x811ff6
  8091ae:	e8 a5 51 00 00       	call   80e358 <_panic>
  8091b3:	ba 06 00 00 00       	mov    $0x6,%edx
  8091b8:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  8091bb:	83 ea 01             	sub    $0x1,%edx
    ethhdr->dest.addr[k] = dst->addr[k];
  8091be:	0f b6 c2             	movzbl %dl,%eax
  8091c1:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  8091c5:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  8091c8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8091cb:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  8091cf:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  8091d3:	84 d2                	test   %dl,%dl
  8091d5:	75 e4                	jne    8091bb <etharp_send_ip+0x39>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  8091d7:	83 ec 0c             	sub    $0xc,%esp
  8091da:	68 00 08 00 00       	push   $0x800
  8091df:	e8 f1 e3 ff ff       	call   8075d5 <htons>
  8091e4:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  8091e8:	83 c4 08             	add    $0x8,%esp
  8091eb:	ff 75 e0             	pushl  -0x20(%ebp)
  8091ee:	56                   	push   %esi
  8091ef:	ff 56 18             	call   *0x18(%esi)
}
  8091f2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8091f5:	5b                   	pop    %ebx
  8091f6:	5e                   	pop    %esi
  8091f7:	5f                   	pop    %edi
  8091f8:	5d                   	pop    %ebp
  8091f9:	c3                   	ret    

008091fa <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  8091fa:	55                   	push   %ebp
  8091fb:	89 e5                	mov    %esp,%ebp
  8091fd:	57                   	push   %edi
  8091fe:	56                   	push   %esi
  8091ff:	53                   	push   %ebx
  809200:	83 ec 1c             	sub    $0x1c,%esp
  809203:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809206:	89 cb                	mov    %ecx,%ebx
  809208:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80920b:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80920e:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809212:	74 17                	je     80922b <update_arp_entry+0x31>
  809214:	83 ec 04             	sub    $0x4,%esp
  809217:	68 b0 20 81 00       	push   $0x8120b0
  80921c:	68 d9 01 00 00       	push   $0x1d9
  809221:	68 f6 1f 81 00       	push   $0x811ff6
  809226:	e8 2d 51 00 00       	call   80e358 <_panic>
  80922b:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80922d:	85 d2                	test   %edx,%edx
  80922f:	0f 84 ed 00 00 00    	je     809322 <update_arp_entry+0x128>
  809235:	83 3a 00             	cmpl   $0x0,(%edx)
  809238:	0f 84 eb 00 00 00    	je     809329 <update_arp_entry+0x12f>
      ip_addr_isbroadcast(ipaddr, netif) ||
  80923e:	83 ec 08             	sub    $0x8,%esp
  809241:	ff 75 e4             	pushl  -0x1c(%ebp)
  809244:	52                   	push   %edx
  809245:	e8 83 d1 ff ff       	call   8063cd <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80924a:	83 c4 10             	add    $0x10,%esp
  80924d:	84 c0                	test   %al,%al
  80924f:	0f 85 db 00 00 00    	jne    809330 <update_arp_entry+0x136>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  809255:	8b 3e                	mov    (%esi),%edi
  809257:	83 ec 0c             	sub    $0xc,%esp
  80925a:	68 00 00 00 f0       	push   $0xf0000000
  80925f:	e8 ac e5 ff ff       	call   807810 <ntohl>
  809264:	21 c7                	and    %eax,%edi
  809266:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80926d:	e8 9e e5 ff ff       	call   807810 <ntohl>
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  809272:	83 c4 10             	add    $0x10,%esp
  809275:	39 c7                	cmp    %eax,%edi
  809277:	0f 84 ba 00 00 00    	je     809337 <update_arp_entry+0x13d>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  80927d:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  809281:	89 f0                	mov    %esi,%eax
  809283:	e8 9a fc ff ff       	call   808f22 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  809288:	84 c0                	test   %al,%al
  80928a:	0f 88 ac 00 00 00    	js     80933c <update_arp_entry+0x142>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  809290:	0f be f0             	movsbl %al,%esi
  809293:	6b c6 1c             	imul   $0x1c,%esi,%eax
  809296:	c7 80 30 4a b3 00 02 	movl   $0x2,0xb34a30(%eax)
  80929d:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  8092a0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8092a3:	89 88 38 4a b3 00    	mov    %ecx,0xb34a38(%eax)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  8092a9:	ba 06 00 00 00       	mov    $0x6,%edx
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8092ae:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8092b1:	05 20 4a b3 00       	add    $0xb34a20,%eax
  8092b6:	89 d7                	mov    %edx,%edi

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
  8092b8:	83 ef 01             	sub    $0x1,%edi
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8092bb:	89 f9                	mov    %edi,%ecx
  8092bd:	0f b6 c9             	movzbl %cl,%ecx
  8092c0:	0f b6 14 0b          	movzbl (%ebx,%ecx,1),%edx
  8092c4:	88 54 01 08          	mov    %dl,0x8(%ecx,%eax,1)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  8092c8:	89 f9                	mov    %edi,%ecx
  8092ca:	84 c9                	test   %cl,%cl
  8092cc:	75 ea                	jne    8092b8 <update_arp_entry+0xbe>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  8092ce:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8092d1:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  8092d8:	89 c6                	mov    %eax,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  8092da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8092dd:	83 c0 25             	add    $0x25,%eax
  8092e0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  8092e3:	eb 31                	jmp    809316 <update_arp_entry+0x11c>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  8092e5:	8b 10                	mov    (%eax),%edx
  8092e7:	89 96 20 4a b3 00    	mov    %edx,0xb34a20(%esi)
    /* get the packet pointer */
    p = q->p;
  8092ed:	8b 78 04             	mov    0x4(%eax),%edi
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  8092f0:	83 ec 08             	sub    $0x8,%esp
  8092f3:	50                   	push   %eax
  8092f4:	6a 0a                	push   $0xa
  8092f6:	e8 b6 b0 ff ff       	call   8043b1 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  8092fb:	89 1c 24             	mov    %ebx,(%esp)
  8092fe:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809301:	89 fa                	mov    %edi,%edx
  809303:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809306:	e8 77 fe ff ff       	call   809182 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  80930b:	89 3c 24             	mov    %edi,(%esp)
  80930e:	e8 11 b4 ff ff       	call   804724 <pbuf_free>
  809313:	83 c4 10             	add    $0x10,%esp
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809316:	8b 86 20 4a b3 00    	mov    0xb34a20(%esi),%eax
  80931c:	85 c0                	test   %eax,%eax
  80931e:	75 c5                	jne    8092e5 <update_arp_entry+0xeb>
  809320:	eb 1a                	jmp    80933c <update_arp_entry+0x142>
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  809322:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809327:	eb 13                	jmp    80933c <update_arp_entry+0x142>
  809329:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80932e:	eb 0c                	jmp    80933c <update_arp_entry+0x142>
  809330:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809335:	eb 05                	jmp    80933c <update_arp_entry+0x142>
  809337:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  80933c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80933f:	5b                   	pop    %ebx
  809340:	5e                   	pop    %esi
  809341:	5f                   	pop    %edi
  809342:	5d                   	pop    %ebp
  809343:	c3                   	ret    

00809344 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  809344:	55                   	push   %ebp
  809345:	89 e5                	mov    %esp,%ebp
  809347:	57                   	push   %edi
  809348:	56                   	push   %esi
  809349:	53                   	push   %ebx
  80934a:	83 ec 0c             	sub    $0xc,%esp
  80934d:	bb 34 4a b3 00       	mov    $0xb34a34,%ebx
  809352:	bf 4c 4b b3 00       	mov    $0xb34b4c,%edi
  809357:	89 de                	mov    %ebx,%esi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  809359:	0f b6 03             	movzbl (%ebx),%eax
  80935c:	83 c0 01             	add    $0x1,%eax
  80935f:	88 03                	mov    %al,(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  809361:	8b 53 fc             	mov    -0x4(%ebx),%edx
  809364:	3c ef                	cmp    $0xef,%al
  809366:	76 05                	jbe    80936d <etharp_tmr+0x29>
  809368:	83 fa 02             	cmp    $0x2,%edx
  80936b:	74 09                	je     809376 <etharp_tmr+0x32>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  80936d:	3c 01                	cmp    $0x1,%al
  80936f:	76 1f                	jbe    809390 <etharp_tmr+0x4c>
  809371:	83 fa 01             	cmp    $0x1,%edx
  809374:	75 1a                	jne    809390 <etharp_tmr+0x4c>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  809376:	8b 46 ec             	mov    -0x14(%esi),%eax
  809379:	85 c0                	test   %eax,%eax
  80937b:	74 0c                	je     809389 <etharp_tmr+0x45>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  80937d:	e8 1d fb ff ff       	call   808e9f <free_etharp_q>
        arp_table[i].q = NULL;
  809382:	c7 46 ec 00 00 00 00 	movl   $0x0,-0x14(%esi)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  809389:	c7 46 fc 00 00 00 00 	movl   $0x0,-0x4(%esi)
  809390:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809393:	39 fb                	cmp    %edi,%ebx
  809395:	75 c0                	jne    809357 <etharp_tmr+0x13>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  809397:	83 c4 0c             	add    $0xc,%esp
  80939a:	5b                   	pop    %ebx
  80939b:	5e                   	pop    %esi
  80939c:	5f                   	pop    %edi
  80939d:	5d                   	pop    %ebp
  80939e:	c3                   	ret    

0080939f <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  80939f:	55                   	push   %ebp
  8093a0:	89 e5                	mov    %esp,%ebp
  8093a2:	53                   	push   %ebx
  8093a3:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  8093a6:	ba 02 00 00 00       	mov    $0x2,%edx
  8093ab:	8b 45 0c             	mov    0xc(%ebp),%eax
  8093ae:	e8 6f fb ff ff       	call   808f22 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  8093b3:	84 c0                	test   %al,%al
  8093b5:	78 29                	js     8093e0 <etharp_find_addr+0x41>
  8093b7:	0f be d0             	movsbl %al,%edx
  8093ba:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  8093bd:	83 b9 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ecx)
  8093c4:	75 21                	jne    8093e7 <etharp_find_addr+0x48>
      *eth_ret = &arp_table[i].ethaddr;
  8093c6:	89 ca                	mov    %ecx,%edx
  8093c8:	8d 99 28 4a b3 00    	lea    0xb34a28(%ecx),%ebx
  8093ce:	8b 4d 10             	mov    0x10(%ebp),%ecx
  8093d1:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  8093d3:	81 c2 24 4a b3 00    	add    $0xb34a24,%edx
  8093d9:	8b 4d 14             	mov    0x14(%ebp),%ecx
  8093dc:	89 11                	mov    %edx,(%ecx)
      return i;
  8093de:	eb 0c                	jmp    8093ec <etharp_find_addr+0x4d>
  }
  return -1;
  8093e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8093e5:	eb 05                	jmp    8093ec <etharp_find_addr+0x4d>
  8093e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8093ec:	83 c4 04             	add    $0x4,%esp
  8093ef:	5b                   	pop    %ebx
  8093f0:	5d                   	pop    %ebp
  8093f1:	c3                   	ret    

008093f2 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  8093f2:	55                   	push   %ebp
  8093f3:	89 e5                	mov    %esp,%ebp
  8093f5:	83 ec 08             	sub    $0x8,%esp
  8093f8:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8093fb:	85 c0                	test   %eax,%eax
  8093fd:	75 17                	jne    809416 <etharp_ip_input+0x24>
  8093ff:	83 ec 04             	sub    $0x4,%esp
  809402:	68 62 13 81 00       	push   $0x811362
  809407:	68 48 02 00 00       	push   $0x248
  80940c:	68 f6 1f 81 00       	push   $0x811ff6
  809411:	e8 42 4f 00 00       	call   80e358 <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809416:	8b 55 0c             	mov    0xc(%ebp),%edx
  809419:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80941c:	8b 4a 1c             	mov    0x1c(%edx),%ecx
  80941f:	33 48 04             	xor    0x4(%eax),%ecx
  809422:	85 48 08             	test   %ecx,0x8(%eax)
  809425:	75 13                	jne    80943a <etharp_ip_input+0x48>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  809427:	8d 4a 06             	lea    0x6(%edx),%ecx
  80942a:	83 c2 1c             	add    $0x1c,%edx
  80942d:	83 ec 0c             	sub    $0xc,%esp
  809430:	6a 00                	push   $0x0
  809432:	e8 c3 fd ff ff       	call   8091fa <update_arp_entry>
  809437:	83 c4 10             	add    $0x10,%esp
}
  80943a:	c9                   	leave  
  80943b:	c3                   	ret    

0080943c <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  80943c:	55                   	push   %ebp
  80943d:	89 e5                	mov    %esp,%ebp
  80943f:	57                   	push   %edi
  809440:	56                   	push   %esi
  809441:	53                   	push   %ebx
  809442:	83 ec 1c             	sub    $0x1c,%esp
  809445:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809448:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80944c:	75 17                	jne    809465 <etharp_arp_input+0x29>
  80944e:	83 ec 04             	sub    $0x4,%esp
  809451:	68 62 13 81 00       	push   $0x811362
  809456:	68 75 02 00 00       	push   $0x275
  80945b:	68 f6 1f 81 00       	push   $0x811ff6
  809460:	e8 f3 4e 00 00       	call   80e358 <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  809465:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  80946a:	77 11                	ja     80947d <etharp_arp_input+0x41>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80946c:	83 ec 0c             	sub    $0xc,%esp
  80946f:	53                   	push   %ebx
  809470:	e8 af b2 ff ff       	call   804724 <pbuf_free>
    return;
  809475:	83 c4 10             	add    $0x10,%esp
  809478:	e9 b4 01 00 00       	jmp    809631 <etharp_arp_input+0x1f5>
  }

  hdr = p->payload;
  80947d:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809480:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  809484:	83 ec 0c             	sub    $0xc,%esp
  809487:	6a 01                	push   $0x1
  809489:	e8 47 e1 ff ff       	call   8075d5 <htons>
  80948e:	83 c4 10             	add    $0x10,%esp
  809491:	66 39 c7             	cmp    %ax,%di
  809494:	75 4b                	jne    8094e1 <etharp_arp_input+0xa5>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809496:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  80949a:	83 ec 0c             	sub    $0xc,%esp
  80949d:	68 04 06 00 00       	push   $0x604
  8094a2:	e8 2e e1 ff ff       	call   8075d5 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8094a7:	83 c4 10             	add    $0x10,%esp
  8094aa:	66 39 c7             	cmp    %ax,%di
  8094ad:	75 32                	jne    8094e1 <etharp_arp_input+0xa5>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8094af:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  8094b3:	83 ec 0c             	sub    $0xc,%esp
  8094b6:	68 00 08 00 00       	push   $0x800
  8094bb:	e8 15 e1 ff ff       	call   8075d5 <htons>

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8094c0:	83 c4 10             	add    $0x10,%esp
  8094c3:	66 39 c7             	cmp    %ax,%di
  8094c6:	75 19                	jne    8094e1 <etharp_arp_input+0xa5>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  8094c8:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  8094cc:	83 ec 0c             	sub    $0xc,%esp
  8094cf:	68 06 08 00 00       	push   $0x806
  8094d4:	e8 fc e0 ff ff       	call   8075d5 <htons>
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8094d9:	83 c4 10             	add    $0x10,%esp
  8094dc:	66 39 c7             	cmp    %ax,%di
  8094df:	74 11                	je     8094f2 <etharp_arp_input+0xb6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8094e1:	83 ec 0c             	sub    $0xc,%esp
  8094e4:	53                   	push   %ebx
  8094e5:	e8 3a b2 ff ff       	call   804724 <pbuf_free>
    return;
  8094ea:	83 c4 10             	add    $0x10,%esp
  8094ed:	e9 3f 01 00 00       	jmp    809631 <etharp_arp_input+0x1f5>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  8094f2:	83 ec 04             	sub    $0x4,%esp
  8094f5:	6a 04                	push   $0x4
  8094f7:	8d 46 1c             	lea    0x1c(%esi),%eax
  8094fa:	50                   	push   %eax
  8094fb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8094fe:	50                   	push   %eax
  8094ff:	e8 ac 56 00 00       	call   80ebb0 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  809504:	83 c4 0c             	add    $0xc,%esp
  809507:	6a 04                	push   $0x4
  809509:	8d 46 26             	lea    0x26(%esi),%eax
  80950c:	50                   	push   %eax
  80950d:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809510:	50                   	push   %eax
  809511:	e8 9a 56 00 00       	call   80ebb0 <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  809516:	8b 45 08             	mov    0x8(%ebp),%eax
  809519:	8b 40 04             	mov    0x4(%eax),%eax
  80951c:	83 c4 10             	add    $0x10,%esp
  80951f:	85 c0                	test   %eax,%eax
  809521:	74 3c                	je     80955f <etharp_arp_input+0x123>
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  }

  /* ARP message directed to us? */
  if (for_us) {
  809523:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  809526:	75 37                	jne    80955f <etharp_arp_input+0x123>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  809528:	8d 4e 16             	lea    0x16(%esi),%ecx
  80952b:	83 ec 0c             	sub    $0xc,%esp
  80952e:	6a 01                	push   $0x1
  809530:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809533:	8b 45 08             	mov    0x8(%ebp),%eax
  809536:	e8 bf fc ff ff       	call   8091fa <update_arp_entry>
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  80953b:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  80953f:	89 04 24             	mov    %eax,(%esp)
  809542:	e8 8e e0 ff ff       	call   8075d5 <htons>
  809547:	83 c4 10             	add    $0x10,%esp
  80954a:	66 83 f8 01          	cmp    $0x1,%ax
  80954e:	74 40                	je     809590 <etharp_arp_input+0x154>
  809550:	66 83 f8 02          	cmp    $0x2,%ax
  809554:	0f 84 b9 00 00 00    	je     809613 <etharp_arp_input+0x1d7>
  80955a:	e9 c6 00 00 00       	jmp    809625 <etharp_arp_input+0x1e9>
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  80955f:	8d 4e 16             	lea    0x16(%esi),%ecx
  809562:	83 ec 0c             	sub    $0xc,%esp
  809565:	6a 00                	push   $0x0
  809567:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80956a:	8b 45 08             	mov    0x8(%ebp),%eax
  80956d:	e8 88 fc ff ff       	call   8091fa <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  809572:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  809576:	89 04 24             	mov    %eax,(%esp)
  809579:	e8 57 e0 ff ff       	call   8075d5 <htons>
  80957e:	83 c4 10             	add    $0x10,%esp
  809581:	66 83 f8 02          	cmp    $0x2,%ax
  809585:	0f 85 9a 00 00 00    	jne    809625 <etharp_arp_input+0x1e9>
  80958b:	e9 83 00 00 00       	jmp    809613 <etharp_arp_input+0x1d7>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  809590:	83 ec 0c             	sub    $0xc,%esp
  809593:	6a 02                	push   $0x2
  809595:	e8 3b e0 ff ff       	call   8075d5 <htons>
  80959a:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  80959e:	8b 46 1c             	mov    0x1c(%esi),%eax
  8095a1:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  8095a4:	8b 45 08             	mov    0x8(%ebp),%eax
  8095a7:	8b 40 04             	mov    0x4(%eax),%eax
  8095aa:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8095ad:	83 c4 10             	add    $0x10,%esp
  8095b0:	ba 06 00 00 00       	mov    $0x6,%edx
  8095b5:	8b 45 08             	mov    0x8(%ebp),%eax
  8095b8:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  8095bc:	74 17                	je     8095d5 <etharp_arp_input+0x199>
  8095be:	83 ec 04             	sub    $0x4,%esp
  8095c1:	68 6c 20 81 00       	push   $0x81206c
  8095c6:	68 c7 02 00 00       	push   $0x2c7
  8095cb:	68 f6 1f 81 00       	push   $0x811ff6
  8095d0:	e8 83 4d 00 00       	call   80e358 <_panic>
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  8095d5:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  8095d8:	0f b6 c2             	movzbl %dl,%eax
  8095db:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  8095e0:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  8095e4:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  8095e7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8095ea:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  8095ee:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  8095f2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8095f5:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  8095f9:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  8095fd:	84 d2                	test   %dl,%dl
  8095ff:	75 d4                	jne    8095d5 <etharp_arp_input+0x199>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  809601:	83 ec 08             	sub    $0x8,%esp
  809604:	53                   	push   %ebx
  809605:	ff 75 08             	pushl  0x8(%ebp)
  809608:	8b 45 08             	mov    0x8(%ebp),%eax
  80960b:	ff 50 18             	call   *0x18(%eax)
  80960e:	83 c4 10             	add    $0x10,%esp
  809611:	eb 12                	jmp    809625 <etharp_arp_input+0x1e9>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  809613:	83 ec 08             	sub    $0x8,%esp
  809616:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809619:	50                   	push   %eax
  80961a:	ff 75 08             	pushl  0x8(%ebp)
  80961d:	e8 d6 a1 ff ff       	call   8037f8 <dhcp_arp_reply>
#endif
    break;
  809622:	83 c4 10             	add    $0x10,%esp
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  809625:	83 ec 0c             	sub    $0xc,%esp
  809628:	53                   	push   %ebx
  809629:	e8 f6 b0 ff ff       	call   804724 <pbuf_free>
  80962e:	83 c4 10             	add    $0x10,%esp
}
  809631:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809634:	5b                   	pop    %ebx
  809635:	5e                   	pop    %esi
  809636:	5f                   	pop    %edi
  809637:	5d                   	pop    %ebp
  809638:	c3                   	ret    

00809639 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  809639:	55                   	push   %ebp
  80963a:	89 e5                	mov    %esp,%ebp
  80963c:	57                   	push   %edi
  80963d:	56                   	push   %esi
  80963e:	53                   	push   %ebx
  80963f:	83 ec 10             	sub    $0x10,%esp
  809642:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  809645:	6a 00                	push   $0x0
  809647:	6a 2a                	push   $0x2a
  809649:	6a 02                	push   $0x2
  80964b:	e8 9a b1 ff ff       	call   8047ea <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  809650:	83 c4 10             	add    $0x10,%esp
  809653:	85 c0                	test   %eax,%eax
  809655:	0f 84 ec 00 00 00    	je     809747 <etharp_request+0x10e>
  80965b:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80965d:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  809662:	77 17                	ja     80967b <etharp_request+0x42>
  809664:	83 ec 04             	sub    $0x4,%esp
  809667:	68 d8 20 81 00       	push   $0x8120d8
  80966c:	68 1c 04 00 00       	push   $0x41c
  809671:	68 f6 1f 81 00       	push   $0x811ff6
  809676:	e8 dd 4c 00 00       	call   80e358 <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  80967b:	8b 58 04             	mov    0x4(%eax),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  80967e:	83 ec 0c             	sub    $0xc,%esp
  809681:	6a 01                	push   $0x1
  809683:	e8 4d df ff ff       	call   8075d5 <htons>
  809688:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80968c:	83 c4 10             	add    $0x10,%esp
  80968f:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  809693:	74 17                	je     8096ac <etharp_request+0x73>
  809695:	83 ec 04             	sub    $0x4,%esp
  809698:	68 6c 20 81 00       	push   $0x81206c
  80969d:	68 23 04 00 00       	push   $0x423
  8096a2:	68 f6 1f 81 00       	push   $0x811ff6
  8096a7:	e8 ac 4c 00 00       	call   80e358 <_panic>
  8096ac:	ba 06 00 00 00       	mov    $0x6,%edx
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  8096b1:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  8096b4:	0f b6 c2             	movzbl %dl,%eax
  8096b7:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  8096bc:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  8096c0:	0f b6 88 58 21 81 00 	movzbl 0x812158(%eax),%ecx
  8096c7:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  8096cb:	0f b6 88 60 21 81 00 	movzbl 0x812160(%eax),%ecx
  8096d2:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  8096d5:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  8096da:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  8096de:	84 d2                	test   %dl,%dl
  8096e0:	75 cf                	jne    8096b1 <etharp_request+0x78>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  8096e2:	8b 46 04             	mov    0x4(%esi),%eax
  8096e5:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  8096e8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8096eb:	8b 00                	mov    (%eax),%eax
  8096ed:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  8096f0:	83 ec 0c             	sub    $0xc,%esp
  8096f3:	6a 01                	push   $0x1
  8096f5:	e8 db de ff ff       	call   8075d5 <htons>
  8096fa:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  8096fe:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809705:	e8 cb de ff ff       	call   8075d5 <htons>
  80970a:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80970e:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809715:	e8 bb de ff ff       	call   8075d5 <htons>
  80971a:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80971e:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809725:	e8 ab de ff ff       	call   8075d5 <htons>
  80972a:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  80972e:	83 c4 08             	add    $0x8,%esp
  809731:	57                   	push   %edi
  809732:	56                   	push   %esi
  809733:	ff 56 18             	call   *0x18(%esi)
  809736:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  809738:	89 3c 24             	mov    %edi,(%esp)
  80973b:	e8 e4 af ff ff       	call   804724 <pbuf_free>
  809740:	83 c4 10             	add    $0x10,%esp
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
  809743:	89 d8                	mov    %ebx,%eax
  809745:	eb 05                	jmp    80974c <etharp_request+0x113>
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  809747:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80974c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80974f:	5b                   	pop    %ebx
  809750:	5e                   	pop    %esi
  809751:	5f                   	pop    %edi
  809752:	5d                   	pop    %ebp
  809753:	c3                   	ret    

00809754 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  809754:	55                   	push   %ebp
  809755:	89 e5                	mov    %esp,%ebp
  809757:	57                   	push   %edi
  809758:	56                   	push   %esi
  809759:	53                   	push   %ebx
  80975a:	83 ec 24             	sub    $0x24,%esp
  80975d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  809760:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  809763:	ff 75 08             	pushl  0x8(%ebp)
  809766:	53                   	push   %ebx
  809767:	e8 61 cc ff ff       	call   8063cd <ip_addr_isbroadcast>
  80976c:	83 c4 10             	add    $0x10,%esp
  80976f:	84 c0                	test   %al,%al
  809771:	0f 85 a9 01 00 00    	jne    809920 <etharp_query+0x1cc>
      ip_addr_ismulticast(ipaddr) ||
  809777:	8b 33                	mov    (%ebx),%esi
  809779:	83 ec 0c             	sub    $0xc,%esp
  80977c:	68 00 00 00 f0       	push   $0xf0000000
  809781:	e8 8a e0 ff ff       	call   807810 <ntohl>
  809786:	21 c6                	and    %eax,%esi
  809788:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80978f:	e8 7c e0 ff ff       	call   807810 <ntohl>
  809794:	83 c4 10             	add    $0x10,%esp
  809797:	85 db                	test   %ebx,%ebx
  809799:	0f 84 88 01 00 00    	je     809927 <etharp_query+0x1d3>
  80979f:	39 c6                	cmp    %eax,%esi
  8097a1:	0f 84 80 01 00 00    	je     809927 <etharp_query+0x1d3>
      ip_addr_isany(ipaddr)) {
  8097a7:	83 3b 00             	cmpl   $0x0,(%ebx)
  8097aa:	0f 84 7e 01 00 00    	je     80992e <etharp_query+0x1da>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  8097b0:	ba 01 00 00 00       	mov    $0x1,%edx
  8097b5:	89 d8                	mov    %ebx,%eax
  8097b7:	e8 66 f7 ff ff       	call   808f22 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  8097bc:	84 c0                	test   %al,%al
  8097be:	0f 88 c4 01 00 00    	js     809988 <etharp_query+0x234>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  8097c4:	0f be f0             	movsbl %al,%esi
  8097c7:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8097ca:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  8097d0:	85 c0                	test   %eax,%eax
  8097d2:	75 0f                	jne    8097e3 <etharp_query+0x8f>
    arp_table[i].state = ETHARP_STATE_PENDING;
  8097d4:	6b c6 1c             	imul   $0x1c,%esi,%eax
  8097d7:	c7 80 30 4a b3 00 01 	movl   $0x1,0xb34a30(%eax)
  8097de:	00 00 00 
  8097e1:	eb 28                	jmp    80980b <etharp_query+0xb7>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  8097e3:	8d 50 ff             	lea    -0x1(%eax),%edx
  8097e6:	83 fa 01             	cmp    $0x1,%edx
  8097e9:	76 17                	jbe    809802 <etharp_query+0xae>
  8097eb:	83 ec 04             	sub    $0x4,%esp
  8097ee:	68 0c 21 81 00       	push   $0x81210c
  8097f3:	68 92 03 00 00       	push   $0x392
  8097f8:	68 f6 1f 81 00       	push   $0x811ff6
  8097fd:	e8 56 4b 00 00       	call   80e358 <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809802:	85 ff                	test   %edi,%edi
  809804:	74 05                	je     80980b <etharp_query+0xb7>
  809806:	83 f8 01             	cmp    $0x1,%eax
  809809:	75 13                	jne    80981e <etharp_query+0xca>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80980b:	83 ec 08             	sub    $0x8,%esp
  80980e:	53                   	push   %ebx
  80980f:	ff 75 08             	pushl  0x8(%ebp)
  809812:	e8 22 fe ff ff       	call   809639 <etharp_request>
  809817:	89 c3                	mov    %eax,%ebx
  809819:	83 c4 10             	add    $0x10,%esp
  80981c:	eb 05                	jmp    809823 <etharp_query+0xcf>
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  80981e:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  809823:	85 ff                	test   %edi,%edi
  809825:	0f 84 0a 01 00 00    	je     809935 <etharp_query+0x1e1>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80982b:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80982e:	8b 90 30 4a b3 00    	mov    0xb34a30(%eax),%edx
  809834:	83 fa 02             	cmp    $0x2,%edx
  809837:	75 24                	jne    80985d <etharp_query+0x109>
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  809839:	8b 45 08             	mov    0x8(%ebp),%eax
  80983c:	8d 48 25             	lea    0x25(%eax),%ecx
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80983f:	83 ec 0c             	sub    $0xc,%esp
  809842:	6b c6 1c             	imul   $0x1c,%esi,%eax
  809845:	05 28 4a b3 00       	add    $0xb34a28,%eax
  80984a:	50                   	push   %eax
  80984b:	89 fa                	mov    %edi,%edx
  80984d:	8b 45 08             	mov    0x8(%ebp),%eax
  809850:	e8 2d f9 ff ff       	call   809182 <etharp_send_ip>
  809855:	83 c4 10             	add    $0x10,%esp
  809858:	e9 2b 01 00 00       	jmp    809988 <etharp_query+0x234>
  80985d:	89 d8                	mov    %ebx,%eax
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80985f:	83 fa 01             	cmp    $0x1,%edx
  809862:	0f 85 20 01 00 00    	jne    809988 <etharp_query+0x234>
  809868:	89 f8                	mov    %edi,%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80986a:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80986e:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  809872:	75 20                	jne    809894 <etharp_query+0x140>
  809874:	83 38 00             	cmpl   $0x0,(%eax)
  809877:	0f 84 03 01 00 00    	je     809980 <etharp_query+0x22c>
  80987d:	83 ec 04             	sub    $0x4,%esp
  809880:	68 52 20 81 00       	push   $0x812052
  809885:	68 b1 03 00 00       	push   $0x3b1
  80988a:	68 f6 1f 81 00       	push   $0x811ff6
  80988f:	e8 c4 4a 00 00       	call   80e358 <_panic>
        if(p->type != PBUF_ROM) {
  809894:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809898:	0f 85 9b 00 00 00    	jne    809939 <etharp_query+0x1e5>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80989e:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  8098a0:	85 c0                	test   %eax,%eax
  8098a2:	75 c6                	jne    80986a <etharp_query+0x116>
  8098a4:	e9 b0 00 00 00       	jmp    809959 <etharp_query+0x205>
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
  8098a9:	83 ec 08             	sub    $0x8,%esp
  8098ac:	57                   	push   %edi
  8098ad:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8098b0:	57                   	push   %edi
  8098b1:	e8 32 b4 ff ff       	call   804ce8 <pbuf_copy>
  8098b6:	83 c4 10             	add    $0x10,%esp
  8098b9:	84 c0                	test   %al,%al
  8098bb:	0f 84 a4 00 00 00    	je     809965 <etharp_query+0x211>
            pbuf_free(p);
  8098c1:	83 ec 0c             	sub    $0xc,%esp
  8098c4:	ff 75 e4             	pushl  -0x1c(%ebp)
  8098c7:	e8 58 ae ff ff       	call   804724 <pbuf_free>
  8098cc:	83 c4 10             	add    $0x10,%esp
  8098cf:	e9 a8 00 00 00       	jmp    80997c <etharp_query+0x228>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
        if (new_entry != NULL) {
          new_entry->next = 0;
  8098d4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  8098da:	89 78 04             	mov    %edi,0x4(%eax)
          if(arp_table[i].q != NULL) {
  8098dd:	6b d6 1c             	imul   $0x1c,%esi,%edx
  8098e0:	8b 8a 20 4a b3 00    	mov    0xb34a20(%edx),%ecx
  8098e6:	85 c9                	test   %ecx,%ecx
  8098e8:	75 04                	jne    8098ee <etharp_query+0x19a>
  8098ea:	eb 14                	jmp    809900 <etharp_query+0x1ac>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
              r = r->next;
  8098ec:	89 d1                	mov    %edx,%ecx
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  8098ee:	8b 11                	mov    (%ecx),%edx
  8098f0:	85 d2                	test   %edx,%edx
  8098f2:	75 f8                	jne    8098ec <etharp_query+0x198>
              r = r->next;
            }
            r->next = new_entry;
  8098f4:	89 01                	mov    %eax,(%ecx)
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  8098f6:	b8 00 00 00 00       	mov    $0x0,%eax
  8098fb:	e9 88 00 00 00       	jmp    809988 <etharp_query+0x234>
              r = r->next;
            }
            r->next = new_entry;
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  809900:	6b f6 1c             	imul   $0x1c,%esi,%esi
  809903:	89 86 20 4a b3 00    	mov    %eax,0xb34a20(%esi)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  809909:	b8 00 00 00 00       	mov    $0x0,%eax
  80990e:	eb 78                	jmp    809988 <etharp_query+0x234>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  809910:	83 ec 0c             	sub    $0xc,%esp
  809913:	57                   	push   %edi
  809914:	e8 0b ae ff ff       	call   804724 <pbuf_free>
  809919:	83 c4 10             	add    $0x10,%esp
  80991c:	89 d8                	mov    %ebx,%eax
  80991e:	eb 68                	jmp    809988 <etharp_query+0x234>
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  809920:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809925:	eb 61                	jmp    809988 <etharp_query+0x234>
  809927:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80992c:	eb 5a                	jmp    809988 <etharp_query+0x234>
  80992e:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809933:	eb 53                	jmp    809988 <etharp_query+0x234>
  809935:	89 d8                	mov    %ebx,%eax
  809937:	eb 4f                	jmp    809988 <etharp_query+0x234>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809939:	83 ec 04             	sub    $0x4,%esp
  80993c:	6a 00                	push   $0x0
  80993e:	0f b7 d2             	movzwl %dx,%edx
  809941:	52                   	push   %edx
  809942:	6a 03                	push   $0x3
  809944:	e8 a1 ae ff ff       	call   8047ea <pbuf_alloc>
  809949:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(p != NULL) {
  80994c:	83 c4 10             	add    $0x10,%esp
  80994f:	85 c0                	test   %eax,%eax
  809951:	0f 85 52 ff ff ff    	jne    8098a9 <etharp_query+0x155>
  809957:	eb 23                	jmp    80997c <etharp_query+0x228>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  809959:	83 ec 0c             	sub    $0xc,%esp
  80995c:	57                   	push   %edi
  80995d:	e8 39 b2 ff ff       	call   804b9b <pbuf_ref>
  809962:	83 c4 10             	add    $0x10,%esp
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809965:	83 ec 0c             	sub    $0xc,%esp
  809968:	6a 0a                	push   $0xa
  80996a:	e8 ec a9 ff ff       	call   80435b <memp_malloc>
        if (new_entry != NULL) {
  80996f:	83 c4 10             	add    $0x10,%esp
  809972:	85 c0                	test   %eax,%eax
  809974:	0f 85 5a ff ff ff    	jne    8098d4 <etharp_query+0x180>
  80997a:	eb 94                	jmp    809910 <etharp_query+0x1bc>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80997c:	89 d8                	mov    %ebx,%eax
  80997e:	eb 08                	jmp    809988 <etharp_query+0x234>
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
        if(p->type != PBUF_ROM) {
  809980:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809984:	75 b3                	jne    809939 <etharp_query+0x1e5>
  809986:	eb d1                	jmp    809959 <etharp_query+0x205>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  809988:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80998b:	5b                   	pop    %ebx
  80998c:	5e                   	pop    %esi
  80998d:	5f                   	pop    %edi
  80998e:	5d                   	pop    %ebp
  80998f:	c3                   	ret    

00809990 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  809990:	55                   	push   %ebp
  809991:	89 e5                	mov    %esp,%ebp
  809993:	57                   	push   %edi
  809994:	56                   	push   %esi
  809995:	53                   	push   %ebx
  809996:	83 ec 24             	sub    $0x24,%esp
  809999:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80999c:	8b 75 10             	mov    0x10(%ebp),%esi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80999f:	6a 0e                	push   $0xe
  8099a1:	ff 75 0c             	pushl  0xc(%ebp)
  8099a4:	e8 a9 ac ff ff       	call   804652 <pbuf_header>
  8099a9:	83 c4 10             	add    $0x10,%esp
  8099ac:	84 c0                	test   %al,%al
  8099ae:	0f 85 bd 00 00 00    	jne    809a71 <etharp_output+0xe1>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  8099b4:	83 ec 08             	sub    $0x8,%esp
  8099b7:	53                   	push   %ebx
  8099b8:	56                   	push   %esi
  8099b9:	e8 0f ca ff ff       	call   8063cd <ip_addr_isbroadcast>
  8099be:	83 c4 10             	add    $0x10,%esp
  8099c1:	84 c0                	test   %al,%al
  8099c3:	0f 85 8d 00 00 00    	jne    809a56 <etharp_output+0xc6>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  8099c9:	8b 3e                	mov    (%esi),%edi
  8099cb:	83 ec 0c             	sub    $0xc,%esp
  8099ce:	68 00 00 00 f0       	push   $0xf0000000
  8099d3:	e8 38 de ff ff       	call   807810 <ntohl>
  8099d8:	21 c7                	and    %eax,%edi
  8099da:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8099e1:	e8 2a de ff ff       	call   807810 <ntohl>
  8099e6:	83 c4 10             	add    $0x10,%esp
  8099e9:	39 c7                	cmp    %eax,%edi
  8099eb:	75 44                	jne    809a31 <etharp_output+0xa1>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  8099ed:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  8099f1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  8099f5:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  8099f9:	83 ec 0c             	sub    $0xc,%esp
  8099fc:	ff 36                	pushl  (%esi)
  8099fe:	e8 0d de ff ff       	call   807810 <ntohl>
  809a03:	c1 e8 10             	shr    $0x10,%eax
  809a06:	83 e0 7f             	and    $0x7f,%eax
  809a09:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809a0c:	83 c4 04             	add    $0x4,%esp
  809a0f:	ff 36                	pushl  (%esi)
  809a11:	e8 fa dd ff ff       	call   807810 <ntohl>
  809a16:	c1 e8 08             	shr    $0x8,%eax
  809a19:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809a1c:	83 c4 04             	add    $0x4,%esp
  809a1f:	ff 36                	pushl  (%esi)
  809a21:	e8 ea dd ff ff       	call   807810 <ntohl>
  809a26:	88 45 e7             	mov    %al,-0x19(%ebp)
  809a29:	83 c4 10             	add    $0x10,%esp
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  809a2c:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809a2f:	eb 2a                	jmp    809a5b <etharp_output+0xcb>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809a31:	8b 06                	mov    (%esi),%eax
  809a33:	33 43 04             	xor    0x4(%ebx),%eax
  809a36:	85 43 08             	test   %eax,0x8(%ebx)
  809a39:	74 09                	je     809a44 <etharp_output+0xb4>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  809a3b:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809a3f:	74 37                	je     809a78 <etharp_output+0xe8>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  809a41:	8d 73 0c             	lea    0xc(%ebx),%esi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  809a44:	83 ec 04             	sub    $0x4,%esp
  809a47:	ff 75 0c             	pushl  0xc(%ebp)
  809a4a:	56                   	push   %esi
  809a4b:	53                   	push   %ebx
  809a4c:	e8 03 fd ff ff       	call   809754 <etharp_query>
  809a51:	83 c4 10             	add    $0x10,%esp
  809a54:	eb 27                	jmp    809a7d <etharp_output+0xed>
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  809a56:	b8 60 21 81 00       	mov    $0x812160,%eax
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809a5b:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809a5e:	83 ec 0c             	sub    $0xc,%esp
  809a61:	50                   	push   %eax
  809a62:	8b 55 0c             	mov    0xc(%ebp),%edx
  809a65:	89 d8                	mov    %ebx,%eax
  809a67:	e8 16 f7 ff ff       	call   809182 <etharp_send_ip>
  809a6c:	83 c4 10             	add    $0x10,%esp
  809a6f:	eb 0c                	jmp    809a7d <etharp_output+0xed>
  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  809a71:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809a76:	eb 05                	jmp    809a7d <etharp_output+0xed>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  809a78:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
  809a7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809a80:	5b                   	pop    %ebx
  809a81:	5e                   	pop    %esi
  809a82:	5f                   	pop    %edi
  809a83:	5d                   	pop    %ebp
  809a84:	c3                   	ret    

00809a85 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809a85:	55                   	push   %ebp
  809a86:	89 e5                	mov    %esp,%ebp
  809a88:	56                   	push   %esi
  809a89:	53                   	push   %ebx
  809a8a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809a8d:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809a90:	83 ec 0c             	sub    $0xc,%esp
  809a93:	8b 43 04             	mov    0x4(%ebx),%eax
  809a96:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809a9a:	50                   	push   %eax
  809a9b:	e8 35 db ff ff       	call   8075d5 <htons>
  809aa0:	83 c4 10             	add    $0x10,%esp
  809aa3:	66 3d 00 08          	cmp    $0x800,%ax
  809aa7:	74 08                	je     809ab1 <ethernet_input+0x2c>
  809aa9:	66 3d 06 08          	cmp    $0x806,%ax
  809aad:	74 44                	je     809af3 <ethernet_input+0x6e>
  809aaf:	eb 55                	jmp    809b06 <ethernet_input+0x81>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  809ab1:	83 ec 08             	sub    $0x8,%esp
  809ab4:	53                   	push   %ebx
  809ab5:	56                   	push   %esi
  809ab6:	e8 37 f9 ff ff       	call   8093f2 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809abb:	83 c4 08             	add    $0x8,%esp
  809abe:	6a f2                	push   $0xfffffff2
  809ac0:	53                   	push   %ebx
  809ac1:	e8 8c ab ff ff       	call   804652 <pbuf_header>
  809ac6:	83 c4 10             	add    $0x10,%esp
  809ac9:	84 c0                	test   %al,%al
  809acb:	74 17                	je     809ae4 <ethernet_input+0x5f>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809acd:	83 ec 04             	sub    $0x4,%esp
  809ad0:	68 34 21 81 00       	push   $0x812134
  809ad5:	68 7e 04 00 00       	push   $0x47e
  809ada:	68 f6 1f 81 00       	push   $0x811ff6
  809adf:	e8 74 48 00 00       	call   80e358 <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  809ae4:	83 ec 08             	sub    $0x8,%esp
  809ae7:	56                   	push   %esi
  809ae8:	53                   	push   %ebx
  809ae9:	e8 89 c9 ff ff       	call   806477 <ip_input>
      }
      break;
  809aee:	83 c4 10             	add    $0x10,%esp
  809af1:	eb 1f                	jmp    809b12 <ethernet_input+0x8d>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809af3:	83 ec 04             	sub    $0x4,%esp
  809af6:	53                   	push   %ebx
  809af7:	8d 46 25             	lea    0x25(%esi),%eax
  809afa:	50                   	push   %eax
  809afb:	56                   	push   %esi
  809afc:	e8 3b f9 ff ff       	call   80943c <etharp_arp_input>
      break;
  809b01:	83 c4 10             	add    $0x10,%esp
  809b04:	eb 0c                	jmp    809b12 <ethernet_input+0x8d>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809b06:	83 ec 0c             	sub    $0xc,%esp
  809b09:	53                   	push   %ebx
  809b0a:	e8 15 ac ff ff       	call   804724 <pbuf_free>
      p = NULL;
      break;
  809b0f:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809b12:	b8 00 00 00 00       	mov    $0x0,%eax
  809b17:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809b1a:	5b                   	pop    %ebx
  809b1b:	5e                   	pop    %esi
  809b1c:	5d                   	pop    %ebp
  809b1d:	c3                   	ret    

00809b1e <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809b1e:	55                   	push   %ebp
  809b1f:	89 e5                	mov    %esp,%ebp
  809b21:	53                   	push   %ebx
  809b22:	83 ec 10             	sub    $0x10,%esp
  809b25:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809b28:	ff 73 04             	pushl  0x4(%ebx)
  809b2b:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809b2d:	89 1c 24             	mov    %ebx,(%esp)
  809b30:	e8 34 65 00 00       	call   810069 <free>
}
  809b35:	83 c4 10             	add    $0x10,%esp
  809b38:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809b3b:	c9                   	leave  
  809b3c:	c3                   	ret    

00809b3d <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809b3d:	55                   	push   %ebp
  809b3e:	89 e5                	mov    %esp,%ebp
  809b40:	83 ec 08             	sub    $0x8,%esp
  809b43:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809b46:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809b4b:	89 c8                	mov    %ecx,%eax
  809b4d:	f7 e2                	mul    %edx
  809b4f:	c1 ea 08             	shr    $0x8,%edx
  809b52:	89 d0                	mov    %edx,%eax
  809b54:	c1 e0 08             	shl    $0x8,%eax
  809b57:	01 c2                	add    %eax,%edx
  809b59:	89 c8                	mov    %ecx,%eax
  809b5b:	29 d0                	sub    %edx,%eax
  809b5d:	8b 04 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%eax
  809b64:	eb 2a                	jmp    809b90 <timeout_cleanup+0x53>
	if (t->tid == tid) {
  809b66:	3b 08                	cmp    (%eax),%ecx
  809b68:	75 23                	jne    809b8d <timeout_cleanup+0x50>
	    LIST_REMOVE(t, link);
  809b6a:	8b 50 08             	mov    0x8(%eax),%edx
  809b6d:	85 d2                	test   %edx,%edx
  809b6f:	74 06                	je     809b77 <timeout_cleanup+0x3a>
  809b71:	8b 48 0c             	mov    0xc(%eax),%ecx
  809b74:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809b77:	8b 50 0c             	mov    0xc(%eax),%edx
  809b7a:	8b 48 08             	mov    0x8(%eax),%ecx
  809b7d:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809b7f:	83 ec 0c             	sub    $0xc,%esp
  809b82:	50                   	push   %eax
  809b83:	e8 e1 64 00 00       	call   810069 <free>
	    goto done;
  809b88:	83 c4 10             	add    $0x10,%esp
  809b8b:	eb 07                	jmp    809b94 <timeout_cleanup+0x57>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809b8d:	8b 40 08             	mov    0x8(%eax),%eax
  809b90:	85 c0                	test   %eax,%eax
  809b92:	75 d2                	jne    809b66 <timeout_cleanup+0x29>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809b94:	c9                   	leave  
  809b95:	c3                   	ret    

00809b96 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  809b96:	55                   	push   %ebp
  809b97:	89 e5                	mov    %esp,%ebp
  809b99:	56                   	push   %esi
  809b9a:	53                   	push   %ebx
  809b9b:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809ba1:	b8 80 9d b3 00       	mov    $0xb39d80,%eax
  809ba6:	be 80 b1 b3 00       	mov    $0xb3b180,%esi
  809bab:	89 c1                	mov    %eax,%ecx
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  809bad:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809bb3:	89 50 0c             	mov    %edx,0xc(%eax)
  809bb6:	85 d2                	test   %edx,%edx
  809bb8:	74 06                	je     809bc0 <sys_init+0x2a>
  809bba:	8d 58 0c             	lea    0xc(%eax),%ebx
  809bbd:	89 5a 10             	mov    %ebx,0x10(%edx)
  809bc0:	c7 41 10 60 9d b3 00 	movl   $0xb39d60,0x10(%ecx)
  809bc7:	83 c0 14             	add    $0x14,%eax
  809bca:	89 ca                	mov    %ecx,%edx

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  809bcc:	39 f0                	cmp    %esi,%eax
  809bce:	75 db                	jne    809bab <sys_init+0x15>
  809bd0:	c7 05 60 9d b3 00 6c 	movl   $0xb3b16c,0xb39d60
  809bd7:	b1 b3 00 
  809bda:	8b 15 44 4f b3 00    	mov    0xb34f44,%edx
  809be0:	b8 60 4f b3 00       	mov    $0xb34f60,%eax
  809be5:	be 60 9d b3 00       	mov    $0xb39d60,%esi
  809bea:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  809bec:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809bf2:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  809bf8:	85 d2                	test   %edx,%edx
  809bfa:	74 0c                	je     809c08 <sys_init+0x72>
  809bfc:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  809c02:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  809c08:	c7 81 98 00 00 00 44 	movl   $0xb34f44,0x98(%ecx)
  809c0f:	4f b3 00 
  809c12:	05 9c 00 00 00       	add    $0x9c,%eax
  809c17:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  809c19:	39 f0                	cmp    %esi,%eax
  809c1b:	75 cd                	jne    809bea <sys_init+0x54>
  809c1d:	c7 05 44 4f b3 00 c4 	movl   $0xb39cc4,0xb34f44
  809c24:	9c b3 00 
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  809c27:	5b                   	pop    %ebx
  809c28:	5e                   	pop    %esi
  809c29:	5d                   	pop    %ebp
  809c2a:	c3                   	ret    

00809c2b <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  809c2b:	55                   	push   %ebp
  809c2c:	89 e5                	mov    %esp,%ebp
  809c2e:	53                   	push   %ebx
  809c2f:	83 ec 04             	sub    $0x4,%esp
  809c32:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  809c35:	a1 60 9d b3 00       	mov    0xb39d60,%eax
    if (!se) {
  809c3a:	85 c0                	test   %eax,%eax
  809c3c:	75 17                	jne    809c55 <sys_sem_new+0x2a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  809c3e:	83 ec 0c             	sub    $0xc,%esp
  809c41:	68 68 21 81 00       	push   $0x812168
  809c46:	e8 e6 47 00 00       	call   80e431 <cprintf>
	return SYS_SEM_NULL;
  809c4b:	83 c4 10             	add    $0x10,%esp
  809c4e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809c53:	eb 52                	jmp    809ca7 <sys_sem_new+0x7c>
    }
    LIST_REMOVE(se, link);
  809c55:	8b 48 0c             	mov    0xc(%eax),%ecx
  809c58:	85 c9                	test   %ecx,%ecx
  809c5a:	74 06                	je     809c62 <sys_sem_new+0x37>
  809c5c:	8b 58 10             	mov    0x10(%eax),%ebx
  809c5f:	89 59 10             	mov    %ebx,0x10(%ecx)
  809c62:	8b 48 10             	mov    0x10(%eax),%ecx
  809c65:	8b 58 0c             	mov    0xc(%eax),%ebx
  809c68:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  809c6a:	83 38 00             	cmpl   $0x0,(%eax)
  809c6d:	75 19                	jne    809c88 <sys_sem_new+0x5d>
  809c6f:	68 dd 22 81 00       	push   $0x8122dd
  809c74:	68 e7 22 81 00       	push   $0x8122e7
  809c79:	68 8d 00 00 00       	push   $0x8d
  809c7e:	68 fc 22 81 00       	push   $0x8122fc
  809c83:	e8 d0 46 00 00       	call   80e358 <_panic>
    se->freed = 0;
  809c88:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  809c8e:	0f b6 d2             	movzbl %dl,%edx
  809c91:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  809c95:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  809c99:	2d 80 9d b3 00       	sub    $0xb39d80,%eax
  809c9e:	c1 f8 02             	sar    $0x2,%eax
  809ca1:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  809ca7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809caa:	c9                   	leave  
  809cab:	c3                   	ret    

00809cac <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  809cac:	55                   	push   %ebp
  809cad:	89 e5                	mov    %esp,%ebp
  809caf:	83 ec 08             	sub    $0x8,%esp
  809cb2:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809cb5:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809cb8:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  809cbf:	00 
  809cc0:	74 19                	je     809cdb <sys_sem_free+0x2f>
  809cc2:	68 19 23 81 00       	push   $0x812319
  809cc7:	68 e7 22 81 00       	push   $0x8122e7
  809ccc:	68 98 00 00 00       	push   $0x98
  809cd1:	68 fc 22 81 00       	push   $0x8122fc
  809cd6:	e8 7d 46 00 00       	call   80e358 <_panic>
    sems[sem].freed = 1;
  809cdb:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809cde:	c1 e2 02             	shl    $0x2,%edx
  809ce1:	8d 8a 80 9d b3 00    	lea    0xb39d80(%edx),%ecx
  809ce7:	c7 82 80 9d b3 00 01 	movl   $0x1,0xb39d80(%edx)
  809cee:	00 00 00 
    sems[sem].gen++;
  809cf1:	83 41 04 01          	addl   $0x1,0x4(%ecx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  809cf5:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809cfb:	89 51 0c             	mov    %edx,0xc(%ecx)
  809cfe:	85 d2                	test   %edx,%edx
  809d00:	74 0d                	je     809d0f <sys_sem_free+0x63>
  809d02:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  809d05:	8d 0c 8d 8c 9d b3 00 	lea    0xb39d8c(,%ecx,4),%ecx
  809d0c:	89 4a 10             	mov    %ecx,0x10(%edx)
  809d0f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809d16:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809d19:	8d 0c 8d 80 9d b3 00 	lea    0xb39d80(,%ecx,4),%ecx
  809d20:	89 0d 60 9d b3 00    	mov    %ecx,0xb39d60
  809d26:	01 d0                	add    %edx,%eax
  809d28:	c7 04 85 90 9d b3 00 	movl   $0xb39d60,0xb39d90(,%eax,4)
  809d2f:	60 9d b3 00 
}
  809d33:	c9                   	leave  
  809d34:	c3                   	ret    

00809d35 <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  809d35:	55                   	push   %ebp
  809d36:	89 e5                	mov    %esp,%ebp
  809d38:	56                   	push   %esi
  809d39:	53                   	push   %ebx
  809d3a:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  809d3d:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  809d43:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  809d4a:	74 16                	je     809d62 <sys_mbox_free+0x2d>
  809d4c:	68 2a 23 81 00       	push   $0x81232a
  809d51:	68 e7 22 81 00       	push   $0x8122e7
  809d56:	6a 62                	push   $0x62
  809d58:	68 fc 22 81 00       	push   $0x8122fc
  809d5d:	e8 f6 45 00 00       	call   80e358 <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  809d62:	83 ec 0c             	sub    $0xc,%esp
  809d65:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  809d6b:	ff b6 ec 4f b3 00    	pushl  0xb34fec(%esi)
  809d71:	e8 36 ff ff ff       	call   809cac <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  809d76:	83 c4 04             	add    $0x4,%esp
  809d79:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  809d7f:	e8 28 ff ff ff       	call   809cac <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  809d84:	a1 44 4f b3 00       	mov    0xb34f44,%eax
  809d89:	89 86 f4 4f b3 00    	mov    %eax,0xb34ff4(%esi)
  809d8f:	83 c4 10             	add    $0x10,%esp
  809d92:	85 c0                	test   %eax,%eax
  809d94:	74 12                	je     809da8 <sys_mbox_free+0x73>
  809d96:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  809d9c:	81 c2 f4 4f b3 00    	add    $0xb34ff4,%edx
  809da2:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809da8:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  809dae:	8d 83 60 4f b3 00    	lea    0xb34f60(%ebx),%eax
  809db4:	a3 44 4f b3 00       	mov    %eax,0xb34f44
  809db9:	c7 83 f8 4f b3 00 44 	movl   $0xb34f44,0xb34ff8(%ebx)
  809dc0:	4f b3 00 
    mboxes[mbox].freed = 1;
  809dc3:	c7 83 60 4f b3 00 01 	movl   $0x1,0xb34f60(%ebx)
  809dca:	00 00 00 
}
  809dcd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809dd0:	5b                   	pop    %ebx
  809dd1:	5e                   	pop    %esi
  809dd2:	5d                   	pop    %ebp
  809dd3:	c3                   	ret    

00809dd4 <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  809dd4:	55                   	push   %ebp
  809dd5:	89 e5                	mov    %esp,%ebp
  809dd7:	56                   	push   %esi
  809dd8:	53                   	push   %ebx
    assert(size < MBOXSLOTS);
  809dd9:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  809ddd:	7e 16                	jle    809df5 <sys_mbox_new+0x21>
  809ddf:	68 3e 23 81 00       	push   $0x81233e
  809de4:	68 e7 22 81 00       	push   $0x8122e7
  809de9:	6a 45                	push   $0x45
  809deb:	68 fc 22 81 00       	push   $0x8122fc
  809df0:	e8 63 45 00 00       	call   80e358 <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  809df5:	8b 1d 44 4f b3 00    	mov    0xb34f44,%ebx
    if (!mbe) {
  809dfb:	85 db                	test   %ebx,%ebx
  809dfd:	75 1a                	jne    809e19 <sys_mbox_new+0x45>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  809dff:	83 ec 0c             	sub    $0xc,%esp
  809e02:	68 90 21 81 00       	push   $0x812190
  809e07:	e8 25 46 00 00       	call   80e431 <cprintf>
	return SYS_MBOX_NULL;
  809e0c:	83 c4 10             	add    $0x10,%esp
  809e0f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809e14:	e9 b7 00 00 00       	jmp    809ed0 <sys_mbox_new+0xfc>
    }
    LIST_REMOVE(mbe, link);
  809e19:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  809e1f:	85 c0                	test   %eax,%eax
  809e21:	74 0c                	je     809e2f <sys_mbox_new+0x5b>
  809e23:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  809e29:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809e2f:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  809e35:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  809e3b:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  809e3d:	83 3b 00             	cmpl   $0x0,(%ebx)
  809e40:	75 16                	jne    809e58 <sys_mbox_new+0x84>
  809e42:	68 4f 23 81 00       	push   $0x81234f
  809e47:	68 e7 22 81 00       	push   $0x8122e7
  809e4c:	6a 4c                	push   $0x4c
  809e4e:	68 fc 22 81 00       	push   $0x8122fc
  809e53:	e8 00 45 00 00       	call   80e358 <_panic>
    mbe->freed = 0;
  809e58:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  809e5e:	89 d8                	mov    %ebx,%eax
  809e60:	2d 60 4f b3 00       	sub    $0xb34f60,%eax
  809e65:	c1 f8 02             	sar    $0x2,%eax
  809e68:	69 f0 97 6f f9 96    	imul   $0x96f96f97,%eax,%esi
    mbe->head = -1;
  809e6e:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  809e75:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  809e7c:	83 ec 0c             	sub    $0xc,%esp
  809e7f:	6a 00                	push   $0x0
  809e81:	e8 a5 fd ff ff       	call   809c2b <sys_sem_new>
  809e86:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  809e8c:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  809e93:	e8 93 fd ff ff       	call   809c2b <sys_sem_new>
  809e98:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  809e9e:	83 c4 10             	add    $0x10,%esp
  809ea1:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  809ea8:	74 05                	je     809eaf <sys_mbox_new+0xdb>
  809eaa:	83 f8 ff             	cmp    $0xffffffff,%eax
  809ead:	75 1f                	jne    809ece <sys_mbox_new+0xfa>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  809eaf:	83 ec 0c             	sub    $0xc,%esp
  809eb2:	56                   	push   %esi
  809eb3:	e8 7d fe ff ff       	call   809d35 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  809eb8:	c7 04 24 b8 21 81 00 	movl   $0x8121b8,(%esp)
  809ebf:	e8 6d 45 00 00       	call   80e431 <cprintf>
	return SYS_MBOX_NULL;
  809ec4:	83 c4 10             	add    $0x10,%esp
  809ec7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809ecc:	eb 02                	jmp    809ed0 <sys_mbox_new+0xfc>
    }
    return i;
  809ece:	89 f0                	mov    %esi,%eax
}
  809ed0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809ed3:	5b                   	pop    %ebx
  809ed4:	5e                   	pop    %esi
  809ed5:	5d                   	pop    %ebp
  809ed6:	c3                   	ret    

00809ed7 <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  809ed7:	55                   	push   %ebp
  809ed8:	89 e5                	mov    %esp,%ebp
  809eda:	83 ec 08             	sub    $0x8,%esp
  809edd:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809ee0:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809ee3:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  809eea:	00 
  809eeb:	74 19                	je     809f06 <sys_sem_signal+0x2f>
  809eed:	68 19 23 81 00       	push   $0x812319
  809ef2:	68 e7 22 81 00       	push   $0x8122e7
  809ef7:	68 a1 00 00 00       	push   $0xa1
  809efc:	68 fc 22 81 00       	push   $0x8122fc
  809f01:	e8 52 44 00 00       	call   80e358 <_panic>
    sems[sem].counter++;
  809f06:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809f09:	8d 14 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edx
  809f10:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  809f15:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  809f1a:	74 27                	je     809f43 <sys_sem_signal+0x6c>
	sems[sem].waiters = 0;
  809f1c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809f23:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809f26:	66 c7 04 8d 8a 9d b3 	movw   $0x0,0xb39d8a(,%ecx,4)
  809f2d:	00 00 00 
	thread_wakeup(&sems[sem].v);
  809f30:	83 ec 0c             	sub    $0xc,%esp
  809f33:	8d 04 8d 88 9d b3 00 	lea    0xb39d88(,%ecx,4),%eax
  809f3a:	50                   	push   %eax
  809f3b:	e8 b9 04 00 00       	call   80a3f9 <thread_wakeup>
  809f40:	83 c4 10             	add    $0x10,%esp
    }
}
  809f43:	c9                   	leave  
  809f44:	c3                   	ret    

00809f45 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  809f45:	55                   	push   %ebp
  809f46:	89 e5                	mov    %esp,%ebp
  809f48:	57                   	push   %edi
  809f49:	56                   	push   %esi
  809f4a:	53                   	push   %ebx
  809f4b:	83 ec 1c             	sub    $0x1c,%esp
  809f4e:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!sems[sem].freed);
  809f51:	8b 45 08             	mov    0x8(%ebp),%eax
  809f54:	8d 04 80             	lea    (%eax,%eax,4),%eax
  809f57:	83 3c 85 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%eax,4)
  809f5e:	00 
  809f5f:	74 19                	je     809f7a <sys_arch_sem_wait+0x35>
  809f61:	68 19 23 81 00       	push   $0x812319
  809f66:	68 e7 22 81 00       	push   $0x8122e7
  809f6b:	68 ac 00 00 00       	push   $0xac
  809f70:	68 fc 22 81 00       	push   $0x8122fc
  809f75:	e8 de 43 00 00       	call   80e358 <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  809f7a:	8b 45 08             	mov    0x8(%ebp),%eax
  809f7d:	8d 04 80             	lea    (%eax,%eax,4),%eax
  809f80:	8b 04 85 84 9d b3 00 	mov    0xb39d84(,%eax,4),%eax
  809f87:	89 45 dc             	mov    %eax,-0x24(%ebp)

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
    assert(!sems[sem].freed);
    u32_t waited = 0;
  809f8a:	bf 00 00 00 00       	mov    $0x0,%edi

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  809f8f:	8b 45 08             	mov    0x8(%ebp),%eax
  809f92:	8d 04 80             	lea    (%eax,%eax,4),%eax
  809f95:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  809f98:	e9 92 00 00 00       	jmp    80a02f <sys_arch_sem_wait+0xea>
	if (sems[sem].counter > 0) {
  809f9d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809fa0:	0f b7 04 85 88 9d b3 	movzwl 0xb39d88(,%eax,4),%eax
  809fa7:	00 
  809fa8:	66 85 c0             	test   %ax,%ax
  809fab:	74 18                	je     809fc5 <sys_arch_sem_wait+0x80>
	    sems[sem].counter--;
  809fad:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809fb0:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  809fb3:	83 e8 01             	sub    $0x1,%eax
  809fb6:	66 89 04 95 88 9d b3 	mov    %ax,0xb39d88(,%edx,4)
  809fbd:	00 
	    return waited;
  809fbe:	89 f8                	mov    %edi,%eax
  809fc0:	e9 86 00 00 00       	jmp    80a04b <sys_arch_sem_wait+0x106>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  809fc5:	83 fe fe             	cmp    $0xfffffffe,%esi
  809fc8:	74 7c                	je     80a046 <sys_arch_sem_wait+0x101>
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  809fca:	e8 db 4f 00 00       	call   80efaa <sys_time_msec>
  809fcf:	89 c1                	mov    %eax,%ecx
  809fd1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  809fd4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809fd9:	85 f6                	test   %esi,%esi
  809fdb:	74 06                	je     809fe3 <sys_arch_sem_wait+0x9e>
  809fdd:	89 f0                	mov    %esi,%eax
  809fdf:	29 f8                	sub    %edi,%eax
  809fe1:	01 c8                	add    %ecx,%eax
	    sems[sem].waiters = 1;
  809fe3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809fe6:	8d 1c 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%ebx
  809fed:	66 c7 43 0a 01 00    	movw   $0x1,0xa(%ebx)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  809ff3:	83 ec 04             	sub    $0x4,%esp
  809ff6:	50                   	push   %eax
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
	    uint32_t cur_v = sems[sem].v;
  809ff7:	8d 43 08             	lea    0x8(%ebx),%eax
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  809ffa:	ff 73 08             	pushl  0x8(%ebx)
  809ffd:	50                   	push   %eax
  809ffe:	e8 0d 06 00 00       	call   80a610 <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80a003:	83 c4 10             	add    $0x10,%esp
  80a006:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80a009:	3b 43 04             	cmp    0x4(%ebx),%eax
  80a00c:	74 17                	je     80a025 <sys_arch_sem_wait+0xe0>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a00e:	83 ec 0c             	sub    $0xc,%esp
  80a011:	68 e4 21 81 00       	push   $0x8121e4
  80a016:	e8 16 44 00 00       	call   80e431 <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a01b:	83 c4 10             	add    $0x10,%esp
  80a01e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a023:	eb 26                	jmp    80a04b <sys_arch_sem_wait+0x106>
	    }
	    uint32_t b = sys_time_msec();
  80a025:	e8 80 4f 00 00       	call   80efaa <sys_time_msec>
	    waited += (b - a);
  80a02a:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a02d:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80a02f:	85 f6                	test   %esi,%esi
  80a031:	0f 84 66 ff ff ff    	je     809f9d <sys_arch_sem_wait+0x58>
  80a037:	39 f7                	cmp    %esi,%edi
  80a039:	0f 82 5e ff ff ff    	jb     809f9d <sys_arch_sem_wait+0x58>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  80a03f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a044:	eb 05                	jmp    80a04b <sys_arch_sem_wait+0x106>
    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
  80a046:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80a04b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a04e:	5b                   	pop    %ebx
  80a04f:	5e                   	pop    %esi
  80a050:	5f                   	pop    %edi
  80a051:	5d                   	pop    %ebp
  80a052:	c3                   	ret    

0080a053 <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80a053:	55                   	push   %ebp
  80a054:	89 e5                	mov    %esp,%ebp
  80a056:	57                   	push   %edi
  80a057:	56                   	push   %esi
  80a058:	53                   	push   %ebx
  80a059:	83 ec 0c             	sub    $0xc,%esp
  80a05c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a05f:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a065:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a06c:	74 16                	je     80a084 <sys_mbox_trypost+0x31>
  80a06e:	68 2a 23 81 00       	push   $0x81232a
  80a073:	68 e7 22 81 00       	push   $0x8122e7
  80a078:	6a 72                	push   $0x72
  80a07a:	68 fc 22 81 00       	push   $0x8122fc
  80a07f:	e8 d4 42 00 00       	call   80e358 <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a084:	83 ec 08             	sub    $0x8,%esp
  80a087:	6a 00                	push   $0x0
  80a089:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a08f:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a095:	e8 ab fe ff ff       	call   809f45 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a09a:	8b 96 68 4f b3 00    	mov    0xb34f68(%esi),%edx
  80a0a0:	8b 8e 64 4f b3 00    	mov    0xb34f64(%esi),%ecx
  80a0a6:	83 c4 10             	add    $0x10,%esp
  80a0a9:	39 ca                	cmp    %ecx,%edx
  80a0ab:	74 5c                	je     80a109 <sys_mbox_trypost+0xb6>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a0ad:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a0b3:	8d 42 01             	lea    0x1(%edx),%eax
  80a0b6:	89 c7                	mov    %eax,%edi
  80a0b8:	c1 ff 1f             	sar    $0x1f,%edi
  80a0bb:	c1 ef 1b             	shr    $0x1b,%edi
  80a0be:	01 f8                	add    %edi,%eax
  80a0c0:	83 e0 1f             	and    $0x1f,%eax
  80a0c3:	29 f8                	sub    %edi,%eax
  80a0c5:	89 86 68 4f b3 00    	mov    %eax,0xb34f68(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a0cb:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a0ce:	01 d0                	add    %edx,%eax
  80a0d0:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a0d3:	89 34 85 6c 4f b3 00 	mov    %esi,0xb34f6c(,%eax,4)

    if (mboxes[mbox].head == -1)
  80a0da:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a0dd:	75 0c                	jne    80a0eb <sys_mbox_trypost+0x98>
	mboxes[mbox].head = slot;
  80a0df:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a0e5:	89 90 64 4f b3 00    	mov    %edx,0xb34f64(%eax)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80a0eb:	83 ec 0c             	sub    $0xc,%esp
  80a0ee:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a0f4:	ff b3 ec 4f b3 00    	pushl  0xb34fec(%ebx)
  80a0fa:	e8 d8 fd ff ff       	call   809ed7 <sys_sem_signal>

    return ERR_OK;
  80a0ff:	83 c4 10             	add    $0x10,%esp
  80a102:	b8 00 00 00 00       	mov    $0x0,%eax
  80a107:	eb 05                	jmp    80a10e <sys_mbox_trypost+0xbb>
{
    assert(!mboxes[mbox].freed);

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
    if (mboxes[mbox].nextq == mboxes[mbox].head)
	return ERR_MEM;
  80a109:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	mboxes[mbox].head = slot;

    sys_sem_signal(mboxes[mbox].queued_msg);

    return ERR_OK;
}
  80a10e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a111:	5b                   	pop    %ebx
  80a112:	5e                   	pop    %esi
  80a113:	5f                   	pop    %edi
  80a114:	5d                   	pop    %ebp
  80a115:	c3                   	ret    

0080a116 <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80a116:	55                   	push   %ebp
  80a117:	89 e5                	mov    %esp,%ebp
  80a119:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a11c:	ff 75 0c             	pushl  0xc(%ebp)
  80a11f:	ff 75 08             	pushl  0x8(%ebp)
  80a122:	e8 2c ff ff ff       	call   80a053 <sys_mbox_trypost>
  80a127:	83 c4 10             	add    $0x10,%esp
  80a12a:	84 c0                	test   %al,%al
  80a12c:	74 16                	je     80a144 <sys_mbox_post+0x2e>
  80a12e:	68 10 22 81 00       	push   $0x812210
  80a133:	68 e7 22 81 00       	push   $0x8122e7
  80a138:	6a 6c                	push   $0x6c
  80a13a:	68 fc 22 81 00       	push   $0x8122fc
  80a13f:	e8 14 42 00 00       	call   80e358 <_panic>
}
  80a144:	c9                   	leave  
  80a145:	c3                   	ret    

0080a146 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80a146:	55                   	push   %ebp
  80a147:	89 e5                	mov    %esp,%ebp
  80a149:	57                   	push   %edi
  80a14a:	56                   	push   %esi
  80a14b:	53                   	push   %ebx
  80a14c:	83 ec 0c             	sub    $0xc,%esp
  80a14f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a152:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a155:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a15b:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a162:	74 19                	je     80a17d <sys_arch_mbox_fetch+0x37>
  80a164:	68 2a 23 81 00       	push   $0x81232a
  80a169:	68 e7 22 81 00       	push   $0x8122e7
  80a16e:	68 ce 00 00 00       	push   $0xce
  80a173:	68 fc 22 81 00       	push   $0x8122fc
  80a178:	e8 db 41 00 00       	call   80e358 <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a17d:	83 ec 08             	sub    $0x8,%esp
  80a180:	ff 75 10             	pushl  0x10(%ebp)
  80a183:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a189:	ff b0 ec 4f b3 00    	pushl  0xb34fec(%eax)
  80a18f:	e8 b1 fd ff ff       	call   809f45 <sys_arch_sem_wait>
  80a194:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a196:	83 c4 10             	add    $0x10,%esp
  80a199:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a19c:	0f 84 86 00 00 00    	je     80a228 <sys_arch_mbox_fetch+0xe2>
	return waited;

    int slot = mboxes[mbox].head;
  80a1a2:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a1a8:	8b 80 64 4f b3 00    	mov    0xb34f64(%eax),%eax
    if (slot == -1)
  80a1ae:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a1b1:	75 17                	jne    80a1ca <sys_arch_mbox_fetch+0x84>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a1b3:	83 ec 04             	sub    $0x4,%esp
  80a1b6:	68 38 22 81 00       	push   $0x812238
  80a1bb:	68 d6 00 00 00       	push   $0xd6
  80a1c0:	68 fc 22 81 00       	push   $0x8122fc
  80a1c5:	e8 8e 41 00 00       	call   80e358 <_panic>
    if (msg)
  80a1ca:	85 ff                	test   %edi,%edi
  80a1cc:	74 0e                	je     80a1dc <sys_arch_mbox_fetch+0x96>
	*msg = mboxes[mbox].msg[slot];
  80a1ce:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a1d1:	01 c2                	add    %eax,%edx
  80a1d3:	8b 14 95 6c 4f b3 00 	mov    0xb34f6c(,%edx,4),%edx
  80a1da:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a1dc:	83 c0 01             	add    $0x1,%eax
  80a1df:	99                   	cltd   
  80a1e0:	c1 ea 1b             	shr    $0x1b,%edx
  80a1e3:	01 d0                	add    %edx,%eax
  80a1e5:	83 e0 1f             	and    $0x1f,%eax
  80a1e8:	29 d0                	sub    %edx,%eax
  80a1ea:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a1f0:	89 82 64 4f b3 00    	mov    %eax,0xb34f64(%edx)
  80a1f6:	81 c2 60 4f b3 00    	add    $0xb34f60,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a1fc:	3b 42 08             	cmp    0x8(%edx),%eax
  80a1ff:	75 10                	jne    80a211 <sys_arch_mbox_fetch+0xcb>
	mboxes[mbox].head = -1;
  80a201:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a207:	c7 80 64 4f b3 00 ff 	movl   $0xffffffff,0xb34f64(%eax)
  80a20e:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80a211:	83 ec 0c             	sub    $0xc,%esp
  80a214:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a21a:	ff b3 f0 4f b3 00    	pushl  0xb34ff0(%ebx)
  80a220:	e8 b2 fc ff ff       	call   809ed7 <sys_sem_signal>
    return waited;
  80a225:	83 c4 10             	add    $0x10,%esp
}
  80a228:	89 f0                	mov    %esi,%eax
  80a22a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a22d:	5b                   	pop    %ebx
  80a22e:	5e                   	pop    %esi
  80a22f:	5f                   	pop    %edi
  80a230:	5d                   	pop    %ebp
  80a231:	c3                   	ret    

0080a232 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80a232:	55                   	push   %ebp
  80a233:	89 e5                	mov    %esp,%ebp
  80a235:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a238:	6a fe                	push   $0xfffffffe
  80a23a:	ff 75 0c             	pushl  0xc(%ebp)
  80a23d:	ff 75 08             	pushl  0x8(%ebp)
  80a240:	e8 01 ff ff ff       	call   80a146 <sys_arch_mbox_fetch>
}
  80a245:	c9                   	leave  
  80a246:	c3                   	ret    

0080a247 <sys_thread_new>:
}

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80a247:	55                   	push   %ebp
  80a248:	89 e5                	mov    %esp,%ebp
  80a24a:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a24d:	6a 08                	push   $0x8
  80a24f:	e8 c3 5e 00 00       	call   810117 <malloc>
    if (lt == 0)
  80a254:	83 c4 10             	add    $0x10,%esp
  80a257:	85 c0                	test   %eax,%eax
  80a259:	75 17                	jne    80a272 <sys_thread_new+0x2b>
	panic("sys_thread_new: cannot allocate thread struct");
  80a25b:	83 ec 04             	sub    $0x4,%esp
  80a25e:	68 60 22 81 00       	push   $0x812260
  80a263:	68 fd 00 00 00       	push   $0xfd
  80a268:	68 fc 22 81 00       	push   $0x8122fc
  80a26d:	e8 e6 40 00 00       	call   80e358 <_panic>

    if (stacksize > PGSIZE)
  80a272:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a279:	7e 17                	jle    80a292 <sys_thread_new+0x4b>
	panic("large stack %d", stacksize);
  80a27b:	ff 75 14             	pushl  0x14(%ebp)
  80a27e:	68 5a 23 81 00       	push   $0x81235a
  80a283:	68 00 01 00 00       	push   $0x100
  80a288:	68 fc 22 81 00       	push   $0x8122fc
  80a28d:	e8 c6 40 00 00       	call   80e358 <_panic>

    lt->func = thread;
  80a292:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a295:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a297:	8b 55 10             	mov    0x10(%ebp),%edx
  80a29a:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a29d:	50                   	push   %eax
  80a29e:	68 1e 9b 80 00       	push   $0x809b1e
  80a2a3:	ff 75 08             	pushl  0x8(%ebp)
  80a2a6:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a2a9:	50                   	push   %eax
  80a2aa:	e8 b8 01 00 00       	call   80a467 <thread_create>

    if (r < 0)
  80a2af:	83 c4 10             	add    $0x10,%esp
  80a2b2:	85 c0                	test   %eax,%eax
  80a2b4:	79 1e                	jns    80a2d4 <sys_thread_new+0x8d>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a2b6:	83 ec 0c             	sub    $0xc,%esp
  80a2b9:	50                   	push   %eax
  80a2ba:	e8 da 04 00 00       	call   80a799 <e2s>
  80a2bf:	50                   	push   %eax
  80a2c0:	68 90 22 81 00       	push   $0x812290
  80a2c5:	68 09 01 00 00       	push   $0x109
  80a2ca:	68 fc 22 81 00       	push   $0x8122fc
  80a2cf:	e8 84 40 00 00       	call   80e358 <_panic>

    return tid;
}
  80a2d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a2d7:	c9                   	leave  
  80a2d8:	c3                   	ret    

0080a2d9 <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a2d9:	55                   	push   %ebp
  80a2da:	89 e5                	mov    %esp,%ebp
  80a2dc:	57                   	push   %edi
  80a2dd:	56                   	push   %esi
  80a2de:	53                   	push   %ebx
  80a2df:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a2e2:	e8 06 01 00 00       	call   80a3ed <thread_id>
  80a2e7:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a2e9:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a2ee:	f7 e2                	mul    %edx
  80a2f0:	c1 ea 08             	shr    $0x8,%edx
  80a2f3:	89 d7                	mov    %edx,%edi
  80a2f5:	c1 e2 08             	shl    $0x8,%edx
  80a2f8:	01 d7                	add    %edx,%edi
  80a2fa:	89 f0                	mov    %esi,%eax
  80a2fc:	29 f8                	sub    %edi,%eax
  80a2fe:	89 c7                	mov    %eax,%edi
  80a300:	8b 1c 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%ebx
  80a307:	eb 0b                	jmp    80a314 <sys_arch_timeouts+0x3b>
	if (t->tid == tid)
  80a309:	3b 33                	cmp    (%ebx),%esi
  80a30b:	0f 84 a4 00 00 00    	je     80a3b5 <sys_arch_timeouts+0xdc>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a311:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a314:	85 db                	test   %ebx,%ebx
  80a316:	75 f1                	jne    80a309 <sys_arch_timeouts+0x30>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80a318:	83 ec 0c             	sub    $0xc,%esp
  80a31b:	6a 10                	push   $0x10
  80a31d:	e8 f5 5d 00 00       	call   810117 <malloc>
  80a322:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a324:	83 c4 10             	add    $0x10,%esp
  80a327:	85 c0                	test   %eax,%eax
  80a329:	75 17                	jne    80a342 <sys_arch_timeouts+0x69>
	panic("sys_arch_timeouts: cannot malloc");
  80a32b:	83 ec 04             	sub    $0x4,%esp
  80a32e:	68 bc 22 81 00       	push   $0x8122bc
  80a333:	68 2c 01 00 00       	push   $0x12c
  80a338:	68 fc 22 81 00       	push   $0x8122fc
  80a33d:	e8 16 40 00 00       	call   80e358 <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80a342:	83 ec 0c             	sub    $0xc,%esp
  80a345:	68 3d 9b 80 00       	push   $0x809b3d
  80a34a:	e8 ec 00 00 00       	call   80a43b <thread_onhalt>
    if (r < 0)
  80a34f:	83 c4 10             	add    $0x10,%esp
  80a352:	85 c0                	test   %eax,%eax
  80a354:	79 1e                	jns    80a374 <sys_arch_timeouts+0x9b>
	panic("thread_onhalt failed: %s", e2s(r));
  80a356:	83 ec 0c             	sub    $0xc,%esp
  80a359:	50                   	push   %eax
  80a35a:	e8 3a 04 00 00       	call   80a799 <e2s>
  80a35f:	50                   	push   %eax
  80a360:	68 69 23 81 00       	push   $0x812369
  80a365:	68 30 01 00 00       	push   $0x130
  80a36a:	68 fc 22 81 00       	push   $0x8122fc
  80a36f:	e8 e4 3f 00 00       	call   80e358 <_panic>

    t->tid = tid;
  80a374:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a376:	83 ec 04             	sub    $0x4,%esp
  80a379:	6a 04                	push   $0x4
  80a37b:	6a 00                	push   $0x0
  80a37d:	8d 43 04             	lea    0x4(%ebx),%eax
  80a380:	50                   	push   %eax
  80a381:	e8 75 47 00 00       	call   80eafb <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a386:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a38d:	89 43 08             	mov    %eax,0x8(%ebx)
  80a390:	83 c4 10             	add    $0x10,%esp
  80a393:	85 c0                	test   %eax,%eax
  80a395:	74 0d                	je     80a3a4 <sys_arch_timeouts+0xcb>
  80a397:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a39e:	8d 53 08             	lea    0x8(%ebx),%edx
  80a3a1:	89 50 0c             	mov    %edx,0xc(%eax)
  80a3a4:	89 1c bd 40 4b b3 00 	mov    %ebx,0xb34b40(,%edi,4)
  80a3ab:	8d 04 bd 40 4b b3 00 	lea    0xb34b40(,%edi,4),%eax
  80a3b2:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a3b5:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a3b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a3bb:	5b                   	pop    %ebx
  80a3bc:	5e                   	pop    %esi
  80a3bd:	5f                   	pop    %edi
  80a3be:	5d                   	pop    %ebp
  80a3bf:	c3                   	ret    

0080a3c0 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80a3c0:	55                   	push   %ebp
  80a3c1:	89 e5                	mov    %esp,%ebp
}
  80a3c3:	5d                   	pop    %ebp
  80a3c4:	c3                   	ret    

0080a3c5 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80a3c5:	55                   	push   %ebp
  80a3c6:	89 e5                	mov    %esp,%ebp
}
  80a3c8:	5d                   	pop    %ebp
  80a3c9:	c3                   	ret    

0080a3ca <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80a3ca:	55                   	push   %ebp
  80a3cb:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a3cd:	c7 05 88 b1 b3 00 00 	movl   $0x0,0xb3b188
  80a3d4:	00 00 00 
    tq->tq_last = 0;
  80a3d7:	c7 05 8c b1 b3 00 00 	movl   $0x0,0xb3b18c
  80a3de:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80a3e1:	c7 05 94 b1 b3 00 00 	movl   $0x0,0xb3b194
  80a3e8:	00 00 00 
}
  80a3eb:	5d                   	pop    %ebp
  80a3ec:	c3                   	ret    

0080a3ed <thread_id>:

uint32_t
thread_id(void) {
  80a3ed:	55                   	push   %ebp
  80a3ee:	89 e5                	mov    %esp,%ebp
    return cur_tc->tc_tid;
  80a3f0:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a3f5:	8b 00                	mov    (%eax),%eax
}
  80a3f7:	5d                   	pop    %ebp
  80a3f8:	c3                   	ret    

0080a3f9 <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a3f9:	55                   	push   %ebp
  80a3fa:	89 e5                	mov    %esp,%ebp
  80a3fc:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a3ff:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    while (tc) {
  80a404:	eb 0c                	jmp    80a412 <thread_wakeup+0x19>
	if (tc->tc_wait_addr == addr)
  80a406:	39 50 48             	cmp    %edx,0x48(%eax)
  80a409:	75 04                	jne    80a40f <thread_wakeup+0x16>
	    tc->tc_wakeup = 1;
  80a40b:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80a40f:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80a412:	85 c0                	test   %eax,%eax
  80a414:	75 f0                	jne    80a406 <thread_wakeup+0xd>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80a416:	5d                   	pop    %ebp
  80a417:	c3                   	ret    

0080a418 <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80a418:	55                   	push   %ebp
  80a419:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80a41b:	8b 15 88 b1 b3 00    	mov    0xb3b188,%edx
    int n = 0;
  80a421:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80a426:	eb 0d                	jmp    80a435 <thread_wakeups_pending+0x1d>
	if (tc->tc_wakeup)
  80a428:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80a42c:	80 f9 01             	cmp    $0x1,%cl
  80a42f:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80a432:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80a435:	85 d2                	test   %edx,%edx
  80a437:	75 ef                	jne    80a428 <thread_wakeups_pending+0x10>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80a439:	5d                   	pop    %ebp
  80a43a:	c3                   	ret    

0080a43b <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a43b:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a440:	8b 50 60             	mov    0x60(%eax),%edx
  80a443:	83 fa 03             	cmp    $0x3,%edx
  80a446:	7f 17                	jg     80a45f <thread_onhalt+0x24>
    }
    return n;
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80a448:	55                   	push   %ebp
  80a449:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a44b:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a44e:	89 48 60             	mov    %ecx,0x60(%eax)
  80a451:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a454:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a458:	b8 00 00 00 00       	mov    $0x0,%eax
  80a45d:	eb 06                	jmp    80a465 <thread_onhalt+0x2a>
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;
  80a45f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a464:	c3                   	ret    

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
    return 0;
}
  80a465:	5d                   	pop    %ebp
  80a466:	c3                   	ret    

0080a467 <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a467:	55                   	push   %ebp
  80a468:	89 e5                	mov    %esp,%ebp
  80a46a:	57                   	push   %edi
  80a46b:	56                   	push   %esi
  80a46c:	53                   	push   %ebx
  80a46d:	83 ec 18             	sub    $0x18,%esp
  80a470:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a473:	6a 68                	push   $0x68
  80a475:	e8 9d 5c 00 00       	call   810117 <malloc>
    if (!tc)
  80a47a:	83 c4 10             	add    $0x10,%esp
  80a47d:	85 c0                	test   %eax,%eax
  80a47f:	0f 84 f4 00 00 00    	je     80a579 <thread_create+0x112>
  80a485:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a487:	83 ec 04             	sub    $0x4,%esp
  80a48a:	6a 68                	push   $0x68
  80a48c:	6a 00                	push   $0x0
  80a48e:	50                   	push   %eax
  80a48f:	e8 67 46 00 00       	call   80eafb <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80a494:	83 c4 0c             	add    $0xc,%esp
  80a497:	6a 1f                	push   $0x1f
  80a499:	ff 75 0c             	pushl  0xc(%ebp)
  80a49c:	8d 43 08             	lea    0x8(%ebx),%eax
  80a49f:	50                   	push   %eax
  80a4a0:	e8 53 45 00 00       	call   80e9f8 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a4a5:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80a4a9:	8b 15 94 b1 b3 00    	mov    0xb3b194,%edx
  80a4af:	8d 42 01             	lea    0x1(%edx),%eax
  80a4b2:	a3 94 b1 b3 00       	mov    %eax,0xb3b194
    if (max_tid == (uint32_t)~0)
  80a4b7:	83 c4 10             	add    $0x10,%esp
  80a4ba:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a4bd:	75 14                	jne    80a4d3 <thread_create+0x6c>
	panic("alloc_tid: no more thread ids");
  80a4bf:	83 ec 04             	sub    $0x4,%esp
  80a4c2:	68 82 23 81 00       	push   $0x812382
  80a4c7:	6a 54                	push   $0x54
  80a4c9:	68 a0 23 81 00       	push   $0x8123a0
  80a4ce:	e8 85 3e 00 00       	call   80e358 <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a4d3:	89 13                	mov    %edx,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a4d5:	83 ec 0c             	sub    $0xc,%esp
  80a4d8:	68 00 10 00 00       	push   $0x1000
  80a4dd:	e8 35 5c 00 00       	call   810117 <malloc>
  80a4e2:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a4e5:	83 c4 10             	add    $0x10,%esp
  80a4e8:	85 c0                	test   %eax,%eax
  80a4ea:	75 16                	jne    80a502 <thread_create+0x9b>
	free(tc);
  80a4ec:	83 ec 0c             	sub    $0xc,%esp
  80a4ef:	53                   	push   %ebx
  80a4f0:	e8 74 5b 00 00       	call   810069 <free>
	return -E_NO_MEM;
  80a4f5:	83 c4 10             	add    $0x10,%esp
  80a4f8:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a4fd:	e9 83 00 00 00       	jmp    80a585 <thread_create+0x11e>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a502:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a508:	83 ec 04             	sub    $0x4,%esp
  80a50b:	6a 04                	push   $0x4
  80a50d:	6a 00                	push   $0x0
  80a50f:	57                   	push   %edi
  80a510:	e8 e6 45 00 00       	call   80eafb <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a515:	83 c4 0c             	add    $0xc,%esp
  80a518:	6a 18                	push   $0x18
  80a51a:	6a 00                	push   $0x0
  80a51c:	8d 43 30             	lea    0x30(%ebx),%eax
  80a51f:	50                   	push   %eax
  80a520:	e8 d6 45 00 00       	call   80eafb <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a525:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a528:	c7 43 30 11 a7 80 00 	movl   $0x80a711,0x30(%ebx)
    tc->tc_entry = entry;
  80a52f:	8b 45 10             	mov    0x10(%ebp),%eax
  80a532:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a535:	8b 45 14             	mov    0x14(%ebp),%eax
  80a538:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a53b:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a542:	83 c4 10             	add    $0x10,%esp
  80a545:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a54c:	75 0e                	jne    80a55c <thread_create+0xf5>
	tq->tq_first = tc;
  80a54e:	89 1d 88 b1 b3 00    	mov    %ebx,0xb3b188
	tq->tq_last = tc;
  80a554:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c
  80a55a:	eb 0e                	jmp    80a56a <thread_create+0x103>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a55c:	a1 8c b1 b3 00       	mov    0xb3b18c,%eax
  80a561:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a564:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c

    threadq_push(&thread_queue, tc);

    if (tid)
  80a56a:	85 f6                	test   %esi,%esi
  80a56c:	74 12                	je     80a580 <thread_create+0x119>
	*tid = tc->tc_tid;
  80a56e:	8b 03                	mov    (%ebx),%eax
  80a570:	89 06                	mov    %eax,(%esi)
    return 0;
  80a572:	b8 00 00 00 00       	mov    $0x0,%eax
  80a577:	eb 0c                	jmp    80a585 <thread_create+0x11e>
int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
    struct thread_context *tc = malloc(sizeof(struct thread_context));
    if (!tc)
	return -E_NO_MEM;
  80a579:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a57e:	eb 05                	jmp    80a585 <thread_create+0x11e>

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a580:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a585:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a588:	5b                   	pop    %ebx
  80a589:	5e                   	pop    %esi
  80a58a:	5f                   	pop    %edi
  80a58b:	5d                   	pop    %ebp
  80a58c:	c3                   	ret    

0080a58d <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80a58d:	55                   	push   %ebp
  80a58e:	89 e5                	mov    %esp,%ebp
  80a590:	53                   	push   %ebx
  80a591:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a594:	8b 1d 88 b1 b3 00    	mov    0xb3b188,%ebx
  80a59a:	85 db                	test   %ebx,%ebx
  80a59c:	74 6d                	je     80a60b <thread_yield+0x7e>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a59e:	8b 43 64             	mov    0x64(%ebx),%eax
  80a5a1:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
    tc->tc_queue_link = 0;
  80a5a6:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80a5ad:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a5b2:	85 c0                	test   %eax,%eax
  80a5b4:	74 42                	je     80a5f8 <thread_yield+0x6b>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80a5b6:	83 ec 0c             	sub    $0xc,%esp
  80a5b9:	83 c0 30             	add    $0x30,%eax
  80a5bc:	50                   	push   %eax
  80a5bd:	e8 6e 01 00 00       	call   80a730 <jos_setjmp>
  80a5c2:	83 c4 10             	add    $0x10,%esp
  80a5c5:	85 c0                	test   %eax,%eax
  80a5c7:	75 42                	jne    80a60b <thread_yield+0x7e>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80a5c9:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a5ce:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a5d5:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a5dc:	75 0c                	jne    80a5ea <thread_yield+0x5d>
	tq->tq_first = tc;
  80a5de:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
	tq->tq_last = tc;
  80a5e3:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
  80a5e8:	eb 0e                	jmp    80a5f8 <thread_yield+0x6b>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a5ea:	8b 15 8c b1 b3 00    	mov    0xb3b18c,%edx
  80a5f0:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a5f3:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
    }

    cur_tc = next_tc;
  80a5f8:	89 1d 90 b1 b3 00    	mov    %ebx,0xb3b190
    jos_longjmp(&cur_tc->tc_jb, 1);
  80a5fe:	8d 43 30             	lea    0x30(%ebx),%eax
  80a601:	ba 01 00 00 00       	mov    $0x1,%edx
  80a606:	e8 55 01 00 00       	call   80a760 <jos_longjmp>
}
  80a60b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a60e:	c9                   	leave  
  80a60f:	c3                   	ret    

0080a610 <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80a610:	55                   	push   %ebp
  80a611:	89 e5                	mov    %esp,%ebp
  80a613:	57                   	push   %edi
  80a614:	56                   	push   %esi
  80a615:	53                   	push   %ebx
  80a616:	83 ec 0c             	sub    $0xc,%esp
  80a619:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a61c:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80a61f:	e8 86 49 00 00       	call   80efaa <sys_time_msec>
  80a624:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80a626:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a62b:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a62e:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
    uint32_t s = sys_time_msec();
    uint32_t p = s;
  80a632:	89 f0                	mov    %esi,%eax

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80a634:	eb 22                	jmp    80a658 <thread_wait+0x48>
	if (p < s)
	    break;
	if (addr && *addr != val)
  80a636:	85 db                	test   %ebx,%ebx
  80a638:	74 07                	je     80a641 <thread_wait+0x31>
  80a63a:	8b 03                	mov    (%ebx),%eax
  80a63c:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80a63f:	75 1f                	jne    80a660 <thread_wait+0x50>
	    break;
	if (cur_tc->tc_wakeup)
  80a641:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a646:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80a64a:	84 c0                	test   %al,%al
  80a64c:	75 12                	jne    80a660 <thread_wait+0x50>
	    break;

	thread_yield();
  80a64e:	e8 3a ff ff ff       	call   80a58d <thread_yield>
	p = sys_time_msec();
  80a653:	e8 52 49 00 00       	call   80efaa <sys_time_msec>

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
	if (p < s)
  80a658:	39 f0                	cmp    %esi,%eax
  80a65a:	72 04                	jb     80a660 <thread_wait+0x50>
  80a65c:	39 f8                	cmp    %edi,%eax
  80a65e:	72 d6                	jb     80a636 <thread_wait+0x26>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80a660:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a665:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a66c:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80a670:	83 c4 0c             	add    $0xc,%esp
  80a673:	5b                   	pop    %ebx
  80a674:	5e                   	pop    %esi
  80a675:	5f                   	pop    %edi
  80a676:	5d                   	pop    %ebp
  80a677:	c3                   	ret    

0080a678 <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80a678:	55                   	push   %ebp
  80a679:	89 e5                	mov    %esp,%ebp
  80a67b:	56                   	push   %esi
  80a67c:	53                   	push   %ebx
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a67d:	8b 1d 80 b1 b3 00    	mov    0xb3b180,%ebx
  80a683:	85 db                	test   %ebx,%ebx
  80a685:	74 40                	je     80a6c7 <thread_halt+0x4f>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a687:	8b 43 64             	mov    0x64(%ebx),%eax
  80a68a:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
    tc->tc_queue_link = 0;
  80a68f:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80a696:	be 00 00 00 00       	mov    $0x0,%esi
  80a69b:	eb 0f                	jmp    80a6ac <thread_halt+0x34>
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
  80a69d:	83 ec 0c             	sub    $0xc,%esp
  80a6a0:	ff 33                	pushl  (%ebx)
  80a6a2:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a6a6:	83 c6 01             	add    $0x1,%esi
  80a6a9:	83 c4 10             	add    $0x10,%esp
  80a6ac:	3b 73 60             	cmp    0x60(%ebx),%esi
  80a6af:	7c ec                	jl     80a69d <thread_halt+0x25>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80a6b1:	83 ec 0c             	sub    $0xc,%esp
  80a6b4:	ff 73 04             	pushl  0x4(%ebx)
  80a6b7:	e8 ad 59 00 00       	call   810069 <free>
    free(tc);
  80a6bc:	89 1c 24             	mov    %ebx,(%esp)
  80a6bf:	e8 a5 59 00 00       	call   810069 <free>
  80a6c4:	83 c4 10             	add    $0x10,%esp
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80a6c7:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a6cc:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a6d3:	83 3d 80 b1 b3 00 00 	cmpl   $0x0,0xb3b180
  80a6da:	75 0c                	jne    80a6e8 <thread_halt+0x70>
	tq->tq_first = tc;
  80a6dc:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
	tq->tq_last = tc;
  80a6e1:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
  80a6e6:	eb 0e                	jmp    80a6f6 <thread_halt+0x7e>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a6e8:	8b 15 84 b1 b3 00    	mov    0xb3b184,%edx
  80a6ee:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a6f1:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
    cur_tc = NULL;
  80a6f6:	c7 05 90 b1 b3 00 00 	movl   $0x0,0xb3b190
  80a6fd:	00 00 00 
    thread_yield();
  80a700:	e8 88 fe ff ff       	call   80a58d <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80a705:	e8 34 3c 00 00       	call   80e33e <exit>
}
  80a70a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a70d:	5b                   	pop    %ebx
  80a70e:	5e                   	pop    %esi
  80a70f:	5d                   	pop    %ebp
  80a710:	c3                   	ret    

0080a711 <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80a711:	55                   	push   %ebp
  80a712:	89 e5                	mov    %esp,%ebp
  80a714:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80a717:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a71c:	ff 70 2c             	pushl  0x2c(%eax)
  80a71f:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80a722:	e8 51 ff ff ff       	call   80a678 <thread_halt>
}
  80a727:	83 c4 10             	add    $0x10,%esp
  80a72a:	c9                   	leave  
  80a72b:	c3                   	ret    
  80a72c:	66 90                	xchg   %ax,%ax
  80a72e:	66 90                	xchg   %ax,%ax

0080a730 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80a730:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80a734:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80a737:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80a739:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80a73d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80a740:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80a743:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80a746:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80a749:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80a74c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80a751:	c3                   	ret    
  80a752:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80a759:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080a760 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80a760:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80a762:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80a765:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80a768:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80a76b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80a76e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80a771:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80a773:	ff e1                	jmp    *%ecx

0080a775 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80a775:	55                   	push   %ebp
  80a776:	89 e5                	mov    %esp,%ebp
  80a778:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80a77b:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
};

void
perror(const char *s) {
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80a780:	ff 34 85 20 40 81 00 	pushl  0x814020(,%eax,4)
  80a787:	ff 75 08             	pushl  0x8(%ebp)
  80a78a:	68 bb 23 81 00       	push   $0x8123bb
  80a78f:	e8 9d 3c 00 00       	call   80e431 <cprintf>
}
  80a794:	83 c4 10             	add    $0x10,%esp
  80a797:	c9                   	leave  
  80a798:	c3                   	ret    

0080a799 <e2s>:

const char *
e2s(int err) {
  80a799:	55                   	push   %ebp
  80a79a:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80a79c:	8b 45 08             	mov    0x8(%ebp),%eax
  80a79f:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
}
  80a7a6:	5d                   	pop    %ebp
  80a7a7:	c3                   	ret    

0080a7a8 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80a7a8:	55                   	push   %ebp
  80a7a9:	89 e5                	mov    %esp,%ebp
  80a7ab:	57                   	push   %edi
  80a7ac:	56                   	push   %esi
  80a7ad:	53                   	push   %ebx
  80a7ae:	83 ec 20             	sub    $0x20,%esp
  80a7b1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80a7b4:	6a 07                	push   $0x7
  80a7b6:	68 00 00 00 10       	push   $0x10000000
  80a7bb:	6a 00                	push   $0x0
  80a7bd:	e8 f7 45 00 00       	call   80edb9 <sys_page_alloc>
    if (r < 0)
  80a7c2:	83 c4 10             	add    $0x10,%esp
  80a7c5:	85 c0                	test   %eax,%eax
  80a7c7:	79 14                	jns    80a7dd <low_level_output+0x35>
	panic("jif: could not allocate page of memory");
  80a7c9:	83 ec 04             	sub    $0x4,%esp
  80a7cc:	68 a0 28 81 00       	push   $0x8128a0
  80a7d1:	6a 55                	push   $0x55
  80a7d3:	68 f1 28 81 00       	push   $0x8128f1
  80a7d8:	e8 7b 3b 00 00       	call   80e358 <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80a7dd:	8b 45 08             	mov    0x8(%ebp),%eax
  80a7e0:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a7e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80a7e6:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80a7eb:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a7f0:	eb 46                	jmp    80a838 <low_level_output+0x90>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80a7f2:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a7f6:	0f b7 d0             	movzwl %ax,%edx
  80a7f9:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
  80a7fc:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80a802:	7e 16                	jle    80a81a <low_level_output+0x72>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80a804:	83 ec 0c             	sub    $0xc,%esp
  80a807:	56                   	push   %esi
  80a808:	52                   	push   %edx
  80a809:	68 c8 28 81 00       	push   $0x8128c8
  80a80e:	6a 64                	push   $0x64
  80a810:	68 f1 28 81 00       	push   $0x8128f1
  80a815:	e8 3e 3b 00 00       	call   80e358 <_panic>
	memcpy(&txbuf[txsize], q->payload, q->len);
  80a81a:	83 ec 04             	sub    $0x4,%esp
  80a81d:	0f b7 c0             	movzwl %ax,%eax
  80a820:	50                   	push   %eax
  80a821:	ff 73 04             	pushl  0x4(%ebx)
  80a824:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80a827:	50                   	push   %eax
  80a828:	e8 83 43 00 00       	call   80ebb0 <memcpy>
	txsize += q->len;
  80a82d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a831:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a833:	8b 1b                	mov    (%ebx),%ebx
  80a835:	83 c4 10             	add    $0x10,%esp
  80a838:	85 db                	test   %ebx,%ebx
  80a83a:	75 b6                	jne    80a7f2 <low_level_output+0x4a>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80a83c:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80a842:	6a 07                	push   $0x7
  80a844:	68 00 00 00 10       	push   $0x10000000
  80a849:	6a 0b                	push   $0xb
  80a84b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a84e:	ff 70 04             	pushl  0x4(%eax)
  80a851:	e8 10 4b 00 00       	call   80f366 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80a856:	83 c4 08             	add    $0x8,%esp
  80a859:	68 00 00 00 10       	push   $0x10000000
  80a85e:	6a 00                	push   $0x0
  80a860:	e8 d9 45 00 00       	call   80ee3e <sys_page_unmap>

    return ERR_OK;
}
  80a865:	b8 00 00 00 00       	mov    $0x0,%eax
  80a86a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a86d:	5b                   	pop    %ebx
  80a86e:	5e                   	pop    %esi
  80a86f:	5f                   	pop    %edi
  80a870:	5d                   	pop    %ebp
  80a871:	c3                   	ret    

0080a872 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80a872:	55                   	push   %ebp
  80a873:	89 e5                	mov    %esp,%ebp
  80a875:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80a878:	ff 75 10             	pushl  0x10(%ebp)
  80a87b:	ff 75 0c             	pushl  0xc(%ebp)
  80a87e:	ff 75 08             	pushl  0x8(%ebp)
  80a881:	e8 0a f1 ff ff       	call   809990 <etharp_output>
}
  80a886:	c9                   	leave  
  80a887:	c3                   	ret    

0080a888 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80a888:	55                   	push   %ebp
  80a889:	89 e5                	mov    %esp,%ebp
  80a88b:	57                   	push   %edi
  80a88c:	56                   	push   %esi
  80a88d:	53                   	push   %ebx
  80a88e:	83 ec 20             	sub    $0x20,%esp
  80a891:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80a894:	8b 45 08             	mov    0x8(%ebp),%eax
  80a897:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a89a:	89 45 d8             	mov    %eax,-0x28(%ebp)
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
    s16_t len = pkt->jp_len;
  80a89d:	8b 06                	mov    (%esi),%eax
  80a89f:	89 c3                	mov    %eax,%ebx

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80a8a1:	6a 03                	push   $0x3
  80a8a3:	0f b7 c0             	movzwl %ax,%eax
  80a8a6:	50                   	push   %eax
  80a8a7:	6a 03                	push   $0x3
  80a8a9:	e8 3c 9f ff ff       	call   8047ea <pbuf_alloc>
  80a8ae:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80a8b1:	83 c4 10             	add    $0x10,%esp
  80a8b4:	85 c0                	test   %eax,%eax
  80a8b6:	0f 84 b8 00 00 00    	je     80a974 <jif_input+0xec>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80a8bc:	8d 56 04             	lea    0x4(%esi),%edx
  80a8bf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a8c2:	89 c6                	mov    %eax,%esi
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
  80a8c4:	bf 00 00 00 00       	mov    $0x0,%edi
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
	if (bytes > (len - copied))
  80a8c9:	0f bf c3             	movswl %bx,%eax
  80a8cc:	89 45 e0             	mov    %eax,-0x20(%ebp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80a8cf:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
	if (bytes > (len - copied))
  80a8d3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a8d6:	29 f8                	sub    %edi,%eax
  80a8d8:	39 c3                	cmp    %eax,%ebx
  80a8da:	0f 4f d8             	cmovg  %eax,%ebx
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80a8dd:	83 ec 04             	sub    $0x4,%esp
  80a8e0:	53                   	push   %ebx
  80a8e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a8e4:	01 f8                	add    %edi,%eax
  80a8e6:	50                   	push   %eax
  80a8e7:	ff 76 04             	pushl  0x4(%esi)
  80a8ea:	e8 c1 42 00 00       	call   80ebb0 <memcpy>
	copied += bytes;
  80a8ef:	01 df                	add    %ebx,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a8f1:	8b 36                	mov    (%esi),%esi
  80a8f3:	83 c4 10             	add    $0x10,%esp
  80a8f6:	85 f6                	test   %esi,%esi
  80a8f8:	75 d5                	jne    80a8cf <jif_input+0x47>
  80a8fa:	eb 54                	jmp    80a950 <jif_input+0xc8>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80a8fc:	83 ec 08             	sub    $0x8,%esp
  80a8ff:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80a902:	57                   	push   %edi
  80a903:	ff 75 08             	pushl  0x8(%ebp)
  80a906:	e8 e7 ea ff ff       	call   8093f2 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80a90b:	83 c4 08             	add    $0x8,%esp
  80a90e:	6a f2                	push   $0xfffffff2
  80a910:	57                   	push   %edi
  80a911:	e8 3c 9d ff ff       	call   804652 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80a916:	83 c4 08             	add    $0x8,%esp
  80a919:	ff 75 08             	pushl  0x8(%ebp)
  80a91c:	57                   	push   %edi
  80a91d:	8b 45 08             	mov    0x8(%ebp),%eax
  80a920:	ff 50 10             	call   *0x10(%eax)
	break;
  80a923:	83 c4 10             	add    $0x10,%esp
  80a926:	eb 4c                	jmp    80a974 <jif_input+0xec>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80a928:	83 ec 04             	sub    $0x4,%esp
  80a92b:	ff 75 dc             	pushl  -0x24(%ebp)
  80a92e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a931:	ff 30                	pushl  (%eax)
  80a933:	ff 75 08             	pushl  0x8(%ebp)
  80a936:	e8 01 eb ff ff       	call   80943c <etharp_arp_input>
	break;
  80a93b:	83 c4 10             	add    $0x10,%esp
  80a93e:	eb 34                	jmp    80a974 <jif_input+0xec>

    default:
	pbuf_free(p);
  80a940:	83 ec 0c             	sub    $0xc,%esp
  80a943:	ff 75 dc             	pushl  -0x24(%ebp)
  80a946:	e8 d9 9d ff ff       	call   804724 <pbuf_free>
  80a94b:	83 c4 10             	add    $0x10,%esp
  80a94e:	eb 24                	jmp    80a974 <jif_input+0xec>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80a950:	83 ec 0c             	sub    $0xc,%esp
  80a953:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80a956:	8b 40 04             	mov    0x4(%eax),%eax
  80a959:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80a95d:	50                   	push   %eax
  80a95e:	e8 72 cc ff ff       	call   8075d5 <htons>
  80a963:	83 c4 10             	add    $0x10,%esp
  80a966:	66 3d 00 08          	cmp    $0x800,%ax
  80a96a:	74 90                	je     80a8fc <jif_input+0x74>
  80a96c:	66 3d 06 08          	cmp    $0x806,%ax
  80a970:	74 b6                	je     80a928 <jif_input+0xa0>
  80a972:	eb cc                	jmp    80a940 <jif_input+0xb8>
	break;

    default:
	pbuf_free(p);
    }
}
  80a974:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a977:	5b                   	pop    %ebx
  80a978:	5e                   	pop    %esi
  80a979:	5f                   	pop    %edi
  80a97a:	5d                   	pop    %ebp
  80a97b:	c3                   	ret    

0080a97c <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80a97c:	55                   	push   %ebp
  80a97d:	89 e5                	mov    %esp,%ebp
  80a97f:	57                   	push   %edi
  80a980:	56                   	push   %esi
  80a981:	53                   	push   %ebx
  80a982:	83 ec 28             	sub    $0x28,%esp
  80a985:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80a988:	6a 08                	push   $0x8
  80a98a:	e8 a5 97 ff ff       	call   804134 <mem_malloc>

    if (jif == NULL) {
  80a98f:	83 c4 10             	add    $0x10,%esp
  80a992:	85 c0                	test   %eax,%eax
  80a994:	0f 84 81 00 00 00    	je     80aa1b <jif_init+0x9f>
  80a99a:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80a99c:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80a99f:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80a9a2:	c7 43 14 72 a8 80 00 	movl   $0x80a872,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80a9a9:	c7 43 18 a8 a7 80 00 	movl   $0x80a7a8,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80a9b0:	83 ec 04             	sub    $0x4,%esp
  80a9b3:	6a 02                	push   $0x2
  80a9b5:	68 94 36 81 00       	push   $0x813694
  80a9ba:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80a9bd:	50                   	push   %eax
  80a9be:	e8 ed 41 00 00       	call   80ebb0 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80a9c3:	8d 43 25             	lea    0x25(%ebx),%eax
  80a9c6:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80a9c8:	8b 07                	mov    (%edi),%eax
  80a9ca:	89 46 04             	mov    %eax,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80a9cd:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80a9d1:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80a9d7:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  80a9db:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80a9df:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80a9e3:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80a9e7:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80a9eb:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80a9ef:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80a9f3:	c7 04 24 eb 0c 81 00 	movl   $0x810ceb,(%esp)
  80a9fa:	e8 ef cd ff ff       	call   8077ee <inet_addr>
  80a9ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80aa02:	83 c4 0c             	add    $0xc,%esp
  80aa05:	6a 00                	push   $0x0
  80aa07:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80aa0a:	50                   	push   %eax
  80aa0b:	53                   	push   %ebx
  80aa0c:	e8 43 ed ff ff       	call   809754 <etharp_query>

    return ERR_OK;
  80aa11:	83 c4 10             	add    $0x10,%esp
  80aa14:	b8 00 00 00 00       	mov    $0x0,%eax
  80aa19:	eb 05                	jmp    80aa20 <jif_init+0xa4>

    jif = mem_malloc(sizeof(struct jif));

    if (jif == NULL) {
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  80aa1b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);

    return ERR_OK;
}
  80aa20:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aa23:	5b                   	pop    %ebx
  80aa24:	5e                   	pop    %esi
  80aa25:	5f                   	pop    %edi
  80aa26:	5d                   	pop    %ebp
  80aa27:	c3                   	ret    

0080aa28 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80aa28:	55                   	push   %ebp
  80aa29:	89 e5                	mov    %esp,%ebp
  80aa2b:	56                   	push   %esi
  80aa2c:	53                   	push   %ebx
  80aa2d:	83 ec 28             	sub    $0x28,%esp
  80aa30:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80aa33:	ff 75 10             	pushl  0x10(%ebp)
  80aa36:	ff 75 08             	pushl  0x8(%ebp)
  80aa39:	e8 02 0f 00 00       	call   80b940 <netconn_alloc>
  
  if (conn != NULL ) {
  80aa3e:	83 c4 10             	add    $0x10,%esp
  80aa41:	85 c0                	test   %eax,%eax
  80aa43:	0f 84 bd 00 00 00    	je     80ab06 <netconn_new_with_proto_and_callback+0xde>
  80aa49:	89 c3                	mov    %eax,%ebx
    msg.function = do_newconn;
  80aa4b:	c7 45 e4 47 b8 80 00 	movl   $0x80b847,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80aa52:	89 f0                	mov    %esi,%eax
  80aa54:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80aa57:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80aa5a:	83 ec 0c             	sub    $0xc,%esp
  80aa5d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80aa60:	50                   	push   %eax
  80aa61:	e8 9c 78 ff ff       	call   802302 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80aa66:	83 c4 10             	add    $0x10,%esp
  80aa69:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80aa6d:	0f 84 9a 00 00 00    	je     80ab0d <netconn_new_with_proto_and_callback+0xe5>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80aa73:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80aa77:	74 14                	je     80aa8d <netconn_new_with_proto_and_callback+0x65>
  80aa79:	83 ec 04             	sub    $0x4,%esp
  80aa7c:	68 08 29 81 00       	push   $0x812908
  80aa81:	6a 52                	push   $0x52
  80aa83:	68 ba 29 81 00       	push   $0x8129ba
  80aa88:	e8 cb 38 00 00       	call   80e358 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80aa8d:	8b 43 10             	mov    0x10(%ebx),%eax
  80aa90:	83 f8 ff             	cmp    $0xffffffff,%eax
  80aa93:	75 14                	jne    80aaa9 <netconn_new_with_proto_and_callback+0x81>
  80aa95:	83 ec 04             	sub    $0x4,%esp
  80aa98:	68 d1 29 81 00       	push   $0x8129d1
  80aa9d:	6a 53                	push   $0x53
  80aa9f:	68 ba 29 81 00       	push   $0x8129ba
  80aaa4:	e8 af 38 00 00       	call   80e358 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80aaa9:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80aaad:	75 14                	jne    80aac3 <netconn_new_with_proto_and_callback+0x9b>
  80aaaf:	83 ec 04             	sub    $0x4,%esp
  80aab2:	68 ea 29 81 00       	push   $0x8129ea
  80aab7:	6a 54                	push   $0x54
  80aab9:	68 ba 29 81 00       	push   $0x8129ba
  80aabe:	e8 95 38 00 00       	call   80e358 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80aac3:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80aac7:	74 14                	je     80aadd <netconn_new_with_proto_and_callback+0xb5>
  80aac9:	83 ec 04             	sub    $0x4,%esp
  80aacc:	68 2c 29 81 00       	push   $0x81292c
  80aad1:	6a 55                	push   $0x55
  80aad3:	68 ba 29 81 00       	push   $0x8129ba
  80aad8:	e8 7b 38 00 00       	call   80e358 <_panic>
      sys_sem_free(conn->op_completed);
  80aadd:	83 ec 0c             	sub    $0xc,%esp
  80aae0:	50                   	push   %eax
  80aae1:	e8 c6 f1 ff ff       	call   809cac <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80aae6:	83 c4 04             	add    $0x4,%esp
  80aae9:	ff 73 14             	pushl  0x14(%ebx)
  80aaec:	e8 44 f2 ff ff       	call   809d35 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80aaf1:	83 c4 08             	add    $0x8,%esp
  80aaf4:	53                   	push   %ebx
  80aaf5:	6a 07                	push   $0x7
  80aaf7:	e8 b5 98 ff ff       	call   8043b1 <memp_free>
      return NULL;
  80aafc:	83 c4 10             	add    $0x10,%esp
  80aaff:	b8 00 00 00 00       	mov    $0x0,%eax
  80ab04:	eb 09                	jmp    80ab0f <netconn_new_with_proto_and_callback+0xe7>
    }
  }
  return conn;
  80ab06:	b8 00 00 00 00       	mov    $0x0,%eax
  80ab0b:	eb 02                	jmp    80ab0f <netconn_new_with_proto_and_callback+0xe7>
  80ab0d:	89 d8                	mov    %ebx,%eax
}
  80ab0f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ab12:	5b                   	pop    %ebx
  80ab13:	5e                   	pop    %esi
  80ab14:	5d                   	pop    %ebp
  80ab15:	c3                   	ret    

0080ab16 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80ab16:	55                   	push   %ebp
  80ab17:	89 e5                	mov    %esp,%ebp
  80ab19:	53                   	push   %ebx
  80ab1a:	83 ec 24             	sub    $0x24,%esp
  80ab1d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80ab20:	85 db                	test   %ebx,%ebx
  80ab22:	74 28                	je     80ab4c <netconn_delete+0x36>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80ab24:	c7 45 e4 88 bb 80 00 	movl   $0x80bb88,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ab2b:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80ab2e:	83 ec 0c             	sub    $0xc,%esp
  80ab31:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ab34:	50                   	push   %eax
  80ab35:	e8 c8 77 ff ff       	call   802302 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80ab3a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80ab41:	89 1c 24             	mov    %ebx,(%esp)
  80ab44:	e8 b0 0e 00 00       	call   80b9f9 <netconn_free>

  return ERR_OK;
  80ab49:	83 c4 10             	add    $0x10,%esp
}
  80ab4c:	b8 00 00 00 00       	mov    $0x0,%eax
  80ab51:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ab54:	c9                   	leave  
  80ab55:	c3                   	ret    

0080ab56 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80ab56:	55                   	push   %ebp
  80ab57:	89 e5                	mov    %esp,%ebp
  80ab59:	83 ec 08             	sub    $0x8,%esp
  80ab5c:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80ab5f:	85 c0                	test   %eax,%eax
  80ab61:	75 17                	jne    80ab7a <netconn_type+0x24>
  80ab63:	83 ec 04             	sub    $0x4,%esp
  80ab66:	68 ff 29 81 00       	push   $0x8129ff
  80ab6b:	68 84 00 00 00       	push   $0x84
  80ab70:	68 ba 29 81 00       	push   $0x8129ba
  80ab75:	e8 de 37 00 00       	call   80e358 <_panic>
  80ab7a:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80ab7c:	c9                   	leave  
  80ab7d:	c3                   	ret    

0080ab7e <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80ab7e:	55                   	push   %ebp
  80ab7f:	89 e5                	mov    %esp,%ebp
  80ab81:	53                   	push   %ebx
  80ab82:	83 ec 24             	sub    $0x24,%esp
  80ab85:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ab88:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ab8b:	8b 45 10             	mov    0x10(%ebp),%eax
  80ab8e:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80ab91:	85 db                	test   %ebx,%ebx
  80ab93:	75 17                	jne    80abac <netconn_getaddr+0x2e>
  80ab95:	83 ec 04             	sub    $0x4,%esp
  80ab98:	68 1a 2a 81 00       	push   $0x812a1a
  80ab9d:	68 98 00 00 00       	push   $0x98
  80aba2:	68 ba 29 81 00       	push   $0x8129ba
  80aba7:	e8 ac 37 00 00       	call   80e358 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80abac:	85 d2                	test   %edx,%edx
  80abae:	75 17                	jne    80abc7 <netconn_getaddr+0x49>
  80abb0:	83 ec 04             	sub    $0x4,%esp
  80abb3:	68 38 2a 81 00       	push   $0x812a38
  80abb8:	68 99 00 00 00       	push   $0x99
  80abbd:	68 ba 29 81 00       	push   $0x8129ba
  80abc2:	e8 91 37 00 00       	call   80e358 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80abc7:	85 c0                	test   %eax,%eax
  80abc9:	75 17                	jne    80abe2 <netconn_getaddr+0x64>
  80abcb:	83 ec 04             	sub    $0x4,%esp
  80abce:	68 56 2a 81 00       	push   $0x812a56
  80abd3:	68 9a 00 00 00       	push   $0x9a
  80abd8:	68 ba 29 81 00       	push   $0x8129ba
  80abdd:	e8 76 37 00 00       	call   80e358 <_panic>

  msg.function = do_getaddr;
  80abe2:	c7 45 e4 d7 bf 80 00 	movl   $0x80bfd7,-0x1c(%ebp)
  msg.msg.conn = conn;
  80abe9:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80abec:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80abef:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80abf2:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80abf5:	83 ec 0c             	sub    $0xc,%esp
  80abf8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80abfb:	50                   	push   %eax
  80abfc:	e8 01 77 ff ff       	call   802302 <tcpip_apimsg>

  return conn->err;
  80ac01:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ac05:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ac08:	c9                   	leave  
  80ac09:	c3                   	ret    

0080ac0a <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ac0a:	55                   	push   %ebp
  80ac0b:	89 e5                	mov    %esp,%ebp
  80ac0d:	53                   	push   %ebx
  80ac0e:	83 ec 24             	sub    $0x24,%esp
  80ac11:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ac14:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ac17:	85 db                	test   %ebx,%ebx
  80ac19:	75 17                	jne    80ac32 <netconn_bind+0x28>
  80ac1b:	83 ec 04             	sub    $0x4,%esp
  80ac1e:	68 74 2a 81 00       	push   $0x812a74
  80ac23:	68 b5 00 00 00       	push   $0xb5
  80ac28:	68 ba 29 81 00       	push   $0x8129ba
  80ac2d:	e8 26 37 00 00       	call   80e358 <_panic>

  msg.function = do_bind;
  80ac32:	c7 45 e4 31 bc 80 00 	movl   $0x80bc31,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ac39:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ac3c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ac3f:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ac42:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80ac46:	83 ec 0c             	sub    $0xc,%esp
  80ac49:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ac4c:	50                   	push   %eax
  80ac4d:	e8 b0 76 ff ff       	call   802302 <tcpip_apimsg>
  return conn->err;
  80ac52:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ac56:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ac59:	c9                   	leave  
  80ac5a:	c3                   	ret    

0080ac5b <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ac5b:	55                   	push   %ebp
  80ac5c:	89 e5                	mov    %esp,%ebp
  80ac5e:	53                   	push   %ebx
  80ac5f:	83 ec 24             	sub    $0x24,%esp
  80ac62:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ac65:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ac68:	85 db                	test   %ebx,%ebx
  80ac6a:	75 17                	jne    80ac83 <netconn_connect+0x28>
  80ac6c:	83 ec 04             	sub    $0x4,%esp
  80ac6f:	68 8f 2a 81 00       	push   $0x812a8f
  80ac74:	68 cc 00 00 00       	push   $0xcc
  80ac79:	68 ba 29 81 00       	push   $0x8129ba
  80ac7e:	e8 d5 36 00 00       	call   80e358 <_panic>

  msg.function = do_connect;
  80ac83:	c7 45 e4 c1 bc 80 00 	movl   $0x80bcc1,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ac8a:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ac8d:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ac90:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ac93:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80ac97:	83 ec 0c             	sub    $0xc,%esp
  80ac9a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ac9d:	50                   	push   %eax
  80ac9e:	e8 5f 76 ff ff       	call   802302 <tcpip_apimsg>
  return conn->err;
  80aca3:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80aca7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80acaa:	c9                   	leave  
  80acab:	c3                   	ret    

0080acac <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80acac:	55                   	push   %ebp
  80acad:	89 e5                	mov    %esp,%ebp
  80acaf:	53                   	push   %ebx
  80acb0:	83 ec 24             	sub    $0x24,%esp
  80acb3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80acb6:	85 db                	test   %ebx,%ebx
  80acb8:	75 17                	jne    80acd1 <netconn_disconnect+0x25>
  80acba:	83 ec 04             	sub    $0x4,%esp
  80acbd:	68 50 29 81 00       	push   $0x812950
  80acc2:	68 e2 00 00 00       	push   $0xe2
  80acc7:	68 ba 29 81 00       	push   $0x8129ba
  80accc:	e8 87 36 00 00       	call   80e358 <_panic>

  msg.function = do_disconnect;
  80acd1:	c7 45 e4 76 bd 80 00 	movl   $0x80bd76,-0x1c(%ebp)
  msg.msg.conn = conn;
  80acd8:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80acdb:	83 ec 0c             	sub    $0xc,%esp
  80acde:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ace1:	50                   	push   %eax
  80ace2:	e8 1b 76 ff ff       	call   802302 <tcpip_apimsg>
  return conn->err;
  80ace7:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80aceb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80acee:	c9                   	leave  
  80acef:	c3                   	ret    

0080acf0 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80acf0:	55                   	push   %ebp
  80acf1:	89 e5                	mov    %esp,%ebp
  80acf3:	53                   	push   %ebx
  80acf4:	83 ec 24             	sub    $0x24,%esp
  80acf7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80acfa:	85 db                	test   %ebx,%ebx
  80acfc:	75 17                	jne    80ad15 <netconn_listen_with_backlog+0x25>
  80acfe:	83 ec 04             	sub    $0x4,%esp
  80ad01:	68 ad 2a 81 00       	push   $0x812aad
  80ad06:	68 fa 00 00 00       	push   $0xfa
  80ad0b:	68 ba 29 81 00       	push   $0x8129ba
  80ad10:	e8 43 36 00 00       	call   80e358 <_panic>

  msg.function = do_listen;
  80ad15:	c7 45 e4 b1 bd 80 00 	movl   $0x80bdb1,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad1c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80ad1f:	83 ec 0c             	sub    $0xc,%esp
  80ad22:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad25:	50                   	push   %eax
  80ad26:	e8 d7 75 ff ff       	call   802302 <tcpip_apimsg>
  return conn->err;
  80ad2b:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad2f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad32:	c9                   	leave  
  80ad33:	c3                   	ret    

0080ad34 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80ad34:	55                   	push   %ebp
  80ad35:	89 e5                	mov    %esp,%ebp
  80ad37:	53                   	push   %ebx
  80ad38:	83 ec 14             	sub    $0x14,%esp
  80ad3b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80ad3e:	85 db                	test   %ebx,%ebx
  80ad40:	75 17                	jne    80ad59 <netconn_accept+0x25>
  80ad42:	83 ec 04             	sub    $0x4,%esp
  80ad45:	68 ca 2a 81 00       	push   $0x812aca
  80ad4a:	68 10 01 00 00       	push   $0x110
  80ad4f:	68 ba 29 81 00       	push   $0x8129ba
  80ad54:	e8 ff 35 00 00       	call   80e358 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80ad59:	8b 43 18             	mov    0x18(%ebx),%eax
  80ad5c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ad5f:	75 17                	jne    80ad78 <netconn_accept+0x44>
  80ad61:	83 ec 04             	sub    $0x4,%esp
  80ad64:	68 74 29 81 00       	push   $0x812974
  80ad69:	68 11 01 00 00       	push   $0x111
  80ad6e:	68 ba 29 81 00       	push   $0x8129ba
  80ad73:	e8 e0 35 00 00       	call   80e358 <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80ad78:	83 ec 04             	sub    $0x4,%esp
  80ad7b:	6a 00                	push   $0x0
  80ad7d:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80ad80:	52                   	push   %edx
  80ad81:	50                   	push   %eax
  80ad82:	e8 bf f3 ff ff       	call   80a146 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80ad87:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ad8a:	83 c4 10             	add    $0x10,%esp
  80ad8d:	85 c0                	test   %eax,%eax
  80ad8f:	74 0d                	je     80ad9e <netconn_accept+0x6a>
  80ad91:	83 ec 04             	sub    $0x4,%esp
  80ad94:	6a 00                	push   $0x0
  80ad96:	6a 01                	push   $0x1
  80ad98:	53                   	push   %ebx
  80ad99:	ff d0                	call   *%eax
  80ad9b:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80ad9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ada1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ada4:	c9                   	leave  
  80ada5:	c3                   	ret    

0080ada6 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80ada6:	55                   	push   %ebp
  80ada7:	89 e5                	mov    %esp,%ebp
  80ada9:	53                   	push   %ebx
  80adaa:	83 ec 24             	sub    $0x24,%esp
  80adad:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80adb0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80adb7:	85 db                	test   %ebx,%ebx
  80adb9:	75 17                	jne    80add2 <netconn_recv+0x2c>
  80adbb:	83 ec 04             	sub    $0x4,%esp
  80adbe:	68 e7 2a 81 00       	push   $0x812ae7
  80adc3:	68 3a 01 00 00       	push   $0x13a
  80adc8:	68 ba 29 81 00       	push   $0x8129ba
  80adcd:	e8 86 35 00 00       	call   80e358 <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80add2:	8b 43 14             	mov    0x14(%ebx),%eax
  80add5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80add8:	75 0e                	jne    80ade8 <netconn_recv+0x42>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80adda:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80adde:	b8 00 00 00 00       	mov    $0x0,%eax
  80ade3:	e9 5b 01 00 00       	jmp    80af43 <netconn_recv+0x19d>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80ade8:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80adec:	0f 8c 3a 01 00 00    	jl     80af2c <netconn_recv+0x186>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80adf2:	83 3b 10             	cmpl   $0x10,(%ebx)
  80adf5:	0f 85 f0 00 00 00    	jne    80aeeb <netconn_recv+0x145>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80adfb:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80adff:	75 0e                	jne    80ae0f <netconn_recv+0x69>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80ae01:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80ae05:	b8 00 00 00 00       	mov    $0x0,%eax
  80ae0a:	e9 34 01 00 00       	jmp    80af43 <netconn_recv+0x19d>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80ae0f:	83 ec 0c             	sub    $0xc,%esp
  80ae12:	6a 06                	push   $0x6
  80ae14:	e8 42 95 ff ff       	call   80435b <memp_malloc>
  80ae19:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80ae1c:	83 c4 10             	add    $0x10,%esp
  80ae1f:	85 c0                	test   %eax,%eax
  80ae21:	75 09                	jne    80ae2c <netconn_recv+0x86>
      conn->err = ERR_MEM;
  80ae23:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80ae27:	e9 17 01 00 00       	jmp    80af43 <netconn_recv+0x19d>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80ae2c:	83 ec 04             	sub    $0x4,%esp
  80ae2f:	6a 00                	push   $0x0
  80ae31:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80ae34:	50                   	push   %eax
  80ae35:	ff 73 14             	pushl  0x14(%ebx)
  80ae38:	e8 09 f3 ff ff       	call   80a146 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80ae3d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ae40:	83 c4 10             	add    $0x10,%esp
  80ae43:	85 c0                	test   %eax,%eax
  80ae45:	0f 84 e8 00 00 00    	je     80af33 <netconn_recv+0x18d>
      len = p->tot_len;
  80ae4b:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80ae4f:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80ae53:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80ae56:	85 c9                	test   %ecx,%ecx
  80ae58:	75 07                	jne    80ae61 <netconn_recv+0xbb>
  80ae5a:	eb 43                	jmp    80ae9f <netconn_recv+0xf9>

    if (p != NULL) {
      len = p->tot_len;
      SYS_ARCH_DEC(conn->recv_avail, len);
    } else {
      len = 0;
  80ae5c:	ba 00 00 00 00       	mov    $0x0,%edx
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80ae61:	83 ec 04             	sub    $0x4,%esp
  80ae64:	0f b7 d2             	movzwl %dx,%edx
  80ae67:	52                   	push   %edx
  80ae68:	6a 01                	push   $0x1
  80ae6a:	53                   	push   %ebx
  80ae6b:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80ae6d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ae70:	83 c4 10             	add    $0x10,%esp
  80ae73:	85 c0                	test   %eax,%eax
  80ae75:	75 28                	jne    80ae9f <netconn_recv+0xf9>
      memp_free(MEMP_NETBUF, buf);
  80ae77:	83 ec 08             	sub    $0x8,%esp
  80ae7a:	ff 75 e0             	pushl  -0x20(%ebp)
  80ae7d:	6a 06                	push   $0x6
  80ae7f:	e8 2d 95 ff ff       	call   8043b1 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80ae84:	83 c4 10             	add    $0x10,%esp
        conn->err = ERR_CLSD;
      }
      return NULL;
  80ae87:	b8 00 00 00 00       	mov    $0x0,%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
      memp_free(MEMP_NETBUF, buf);
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80ae8c:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ae90:	0f 85 ad 00 00 00    	jne    80af43 <netconn_recv+0x19d>
        conn->err = ERR_CLSD;
  80ae96:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80ae9a:	e9 a4 00 00 00       	jmp    80af43 <netconn_recv+0x19d>
      }
      return NULL;
    }

    buf->p = p;
  80ae9f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80aea2:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80aea4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80aea7:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80aeaa:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80aead:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80aeb3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80aeba:	c7 45 e4 43 bf 80 00 	movl   $0x80bf43,-0x1c(%ebp)
    msg.msg.conn = conn;
  80aec1:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80aec4:	85 c0                	test   %eax,%eax
  80aec6:	74 0c                	je     80aed4 <netconn_recv+0x12e>
      msg.msg.msg.r.len = buf->p->tot_len;
  80aec8:	8b 00                	mov    (%eax),%eax
  80aeca:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80aece:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80aed2:	eb 06                	jmp    80aeda <netconn_recv+0x134>
    } else {
      msg.msg.msg.r.len = 1;
  80aed4:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80aeda:	83 ec 0c             	sub    $0xc,%esp
  80aedd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80aee0:	50                   	push   %eax
  80aee1:	e8 1c 74 ff ff       	call   802302 <tcpip_apimsg>
  80aee6:	83 c4 10             	add    $0x10,%esp
  80aee9:	eb 3c                	jmp    80af27 <netconn_recv+0x181>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80aeeb:	83 ec 04             	sub    $0x4,%esp
  80aeee:	6a 00                	push   $0x0
  80aef0:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80aef3:	52                   	push   %edx
  80aef4:	50                   	push   %eax
  80aef5:	e8 4c f2 ff ff       	call   80a146 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80aefa:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80aefd:	83 c4 10             	add    $0x10,%esp
  80af00:	85 c0                	test   %eax,%eax
  80af02:	74 23                	je     80af27 <netconn_recv+0x181>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80af04:	8b 10                	mov    (%eax),%edx
  80af06:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80af0a:	66 29 53 20          	sub    %dx,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80af0e:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80af11:	85 d2                	test   %edx,%edx
  80af13:	74 12                	je     80af27 <netconn_recv+0x181>
  80af15:	83 ec 04             	sub    $0x4,%esp
  80af18:	8b 00                	mov    (%eax),%eax
  80af1a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80af1e:	50                   	push   %eax
  80af1f:	6a 01                	push   $0x1
  80af21:	53                   	push   %ebx
  80af22:	ff d2                	call   *%edx
  80af24:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80af27:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80af2a:	eb 17                	jmp    80af43 <netconn_recv+0x19d>
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
    return NULL;
  80af2c:	b8 00 00 00 00       	mov    $0x0,%eax
  80af31:	eb 10                	jmp    80af43 <netconn_recv+0x19d>
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80af33:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80af36:	85 c9                	test   %ecx,%ecx
  80af38:	0f 85 1e ff ff ff    	jne    80ae5c <netconn_recv+0xb6>
  80af3e:	e9 34 ff ff ff       	jmp    80ae77 <netconn_recv+0xd1>
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
}
  80af43:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80af46:	c9                   	leave  
  80af47:	c3                   	ret    

0080af48 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80af48:	55                   	push   %ebp
  80af49:	89 e5                	mov    %esp,%ebp
  80af4b:	53                   	push   %ebx
  80af4c:	83 ec 24             	sub    $0x24,%esp
  80af4f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80af52:	85 db                	test   %ebx,%ebx
  80af54:	75 17                	jne    80af6d <netconn_send+0x25>
  80af56:	83 ec 04             	sub    $0x4,%esp
  80af59:	68 02 2b 81 00       	push   $0x812b02
  80af5e:	68 b9 01 00 00       	push   $0x1b9
  80af63:	68 ba 29 81 00       	push   $0x8129ba
  80af68:	e8 eb 33 00 00       	call   80e358 <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80af6d:	c7 45 e4 9d be 80 00 	movl   $0x80be9d,-0x1c(%ebp)
  msg.msg.conn = conn;
  80af74:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80af77:	8b 45 0c             	mov    0xc(%ebp),%eax
  80af7a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80af7d:	83 ec 0c             	sub    $0xc,%esp
  80af80:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af83:	50                   	push   %eax
  80af84:	e8 79 73 ff ff       	call   802302 <tcpip_apimsg>
  return conn->err;
  80af89:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80af8d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80af90:	c9                   	leave  
  80af91:	c3                   	ret    

0080af92 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80af92:	55                   	push   %ebp
  80af93:	89 e5                	mov    %esp,%ebp
  80af95:	83 ec 08             	sub    $0x8,%esp
  80af98:	8b 45 0c             	mov    0xc(%ebp),%eax
  80af9b:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80af9e:	85 c0                	test   %eax,%eax
  80afa0:	74 1b                	je     80afbd <netconn_sendto+0x2b>
    buf->addr = addr;
  80afa2:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80afa5:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80afa8:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80afac:	83 ec 08             	sub    $0x8,%esp
  80afaf:	50                   	push   %eax
  80afb0:	ff 75 08             	pushl  0x8(%ebp)
  80afb3:	e8 90 ff ff ff       	call   80af48 <netconn_send>
  80afb8:	83 c4 10             	add    $0x10,%esp
  80afbb:	eb 05                	jmp    80afc2 <netconn_sendto+0x30>
  }
  return ERR_VAL;
  80afbd:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80afc2:	c9                   	leave  
  80afc3:	c3                   	ret    

0080afc4 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80afc4:	55                   	push   %ebp
  80afc5:	89 e5                	mov    %esp,%ebp
  80afc7:	53                   	push   %ebx
  80afc8:	83 ec 24             	sub    $0x24,%esp
  80afcb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80afce:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80afd1:	85 db                	test   %ebx,%ebx
  80afd3:	75 17                	jne    80afec <netconn_write+0x28>
  80afd5:	83 ec 04             	sub    $0x4,%esp
  80afd8:	68 1d 2b 81 00       	push   $0x812b1d
  80afdd:	68 d3 01 00 00       	push   $0x1d3
  80afe2:	68 ba 29 81 00       	push   $0x8129ba
  80afe7:	e8 6c 33 00 00       	call   80e358 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80afec:	83 3b 10             	cmpl   $0x10,(%ebx)
  80afef:	74 17                	je     80b008 <netconn_write+0x44>
  80aff1:	83 ec 04             	sub    $0x4,%esp
  80aff4:	68 98 29 81 00       	push   $0x812998
  80aff9:	68 d4 01 00 00       	push   $0x1d4
  80affe:	68 ba 29 81 00       	push   $0x8129ba
  80b003:	e8 50 33 00 00       	call   80e358 <_panic>

  msg.function = do_write;
  80b008:	c7 45 e4 87 bf 80 00 	movl   $0x80bf87,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b00f:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b012:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b015:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b018:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b01b:	8b 45 10             	mov    0x10(%ebp),%eax
  80b01e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b021:	83 ec 0c             	sub    $0xc,%esp
  80b024:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b027:	50                   	push   %eax
  80b028:	e8 d5 72 ff ff       	call   802302 <tcpip_apimsg>
  return conn->err;
  80b02d:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b031:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b034:	c9                   	leave  
  80b035:	c3                   	ret    

0080b036 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b036:	55                   	push   %ebp
  80b037:	89 e5                	mov    %esp,%ebp
  80b039:	53                   	push   %ebx
  80b03a:	83 ec 24             	sub    $0x24,%esp
  80b03d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b040:	85 db                	test   %ebx,%ebx
  80b042:	75 17                	jne    80b05b <netconn_close+0x25>
  80b044:	83 ec 04             	sub    $0x4,%esp
  80b047:	68 39 2b 81 00       	push   $0x812b39
  80b04c:	68 ed 01 00 00       	push   $0x1ed
  80b051:	68 ba 29 81 00       	push   $0x8129ba
  80b056:	e8 fd 32 00 00       	call   80e358 <_panic>

  msg.function = do_close;
  80b05b:	c7 45 e4 9b c0 80 00 	movl   $0x80c09b,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b062:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b065:	83 ec 0c             	sub    $0xc,%esp
  80b068:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b06b:	50                   	push   %eax
  80b06c:	e8 91 72 ff ff       	call   802302 <tcpip_apimsg>
  return conn->err;
  80b071:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b075:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b078:	c9                   	leave  
  80b079:	c3                   	ret    

0080b07a <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b07a:	55                   	push   %ebp
  80b07b:	89 e5                	mov    %esp,%ebp
  80b07d:	56                   	push   %esi
  80b07e:	53                   	push   %ebx
  80b07f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b082:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b085:	8b 75 10             	mov    0x10(%ebp),%esi
  80b088:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b08b:	85 c0                	test   %eax,%eax
  80b08d:	75 17                	jne    80b0a6 <recv_tcp+0x2c>
  80b08f:	83 ec 04             	sub    $0x4,%esp
  80b092:	68 58 2b 81 00       	push   $0x812b58
  80b097:	68 c1 00 00 00       	push   $0xc1
  80b09c:	68 a2 2c 81 00       	push   $0x812ca2
  80b0a1:	e8 b2 32 00 00       	call   80e358 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b0a6:	85 db                	test   %ebx,%ebx
  80b0a8:	75 17                	jne    80b0c1 <recv_tcp+0x47>
  80b0aa:	83 ec 04             	sub    $0x4,%esp
  80b0ad:	68 7c 2b 81 00       	push   $0x812b7c
  80b0b2:	68 c2 00 00 00       	push   $0xc2
  80b0b7:	68 a2 2c 81 00       	push   $0x812ca2
  80b0bc:	e8 97 32 00 00       	call   80e358 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b0c1:	3b 43 08             	cmp    0x8(%ebx),%eax
  80b0c4:	74 17                	je     80b0dd <recv_tcp+0x63>
  80b0c6:	83 ec 04             	sub    $0x4,%esp
  80b0c9:	68 b9 2c 81 00       	push   $0x812cb9
  80b0ce:	68 c4 00 00 00       	push   $0xc4
  80b0d3:	68 a2 2c 81 00       	push   $0x812ca2
  80b0d8:	e8 7b 32 00 00       	call   80e358 <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b0dd:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b0e1:	74 44                	je     80b127 <recv_tcp+0xad>
    return ERR_VAL;
  }

  conn->err = err;
  80b0e3:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80b0e6:	85 f6                	test   %esi,%esi
  80b0e8:	74 0a                	je     80b0f4 <recv_tcp+0x7a>
    len = p->tot_len;
  80b0ea:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b0ee:	66 01 43 20          	add    %ax,0x20(%ebx)
  80b0f2:	eb 05                	jmp    80b0f9 <recv_tcp+0x7f>
  } else {
    len = 0;
  80b0f4:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b0f9:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b0fc:	85 d2                	test   %edx,%edx
  80b0fe:	74 0f                	je     80b10f <recv_tcp+0x95>
  80b100:	83 ec 04             	sub    $0x4,%esp
  80b103:	0f b7 c0             	movzwl %ax,%eax
  80b106:	50                   	push   %eax
  80b107:	6a 00                	push   $0x0
  80b109:	53                   	push   %ebx
  80b10a:	ff d2                	call   *%edx
  80b10c:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b10f:	83 ec 08             	sub    $0x8,%esp
  80b112:	56                   	push   %esi
  80b113:	ff 73 14             	pushl  0x14(%ebx)
  80b116:	e8 38 ef ff ff       	call   80a053 <sys_mbox_trypost>
  80b11b:	83 c4 10             	add    $0x10,%esp
  80b11e:	84 c0                	test   %al,%al
  80b120:	0f 95 c0             	setne  %al
  80b123:	f7 d8                	neg    %eax
  80b125:	eb 05                	jmp    80b12c <recv_tcp+0xb2>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
    return ERR_VAL;
  80b127:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b12c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b12f:	5b                   	pop    %ebx
  80b130:	5e                   	pop    %esi
  80b131:	5d                   	pop    %ebp
  80b132:	c3                   	ret    

0080b133 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80b133:	55                   	push   %ebp
  80b134:	89 e5                	mov    %esp,%ebp
  80b136:	57                   	push   %edi
  80b137:	56                   	push   %esi
  80b138:	53                   	push   %ebx
  80b139:	83 ec 1c             	sub    $0x1c,%esp
  80b13c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b13f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b142:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b145:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b148:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b14b:	85 c0                	test   %eax,%eax
  80b14d:	75 17                	jne    80b166 <recv_udp+0x33>
  80b14f:	83 ec 04             	sub    $0x4,%esp
  80b152:	68 9c 2b 81 00       	push   $0x812b9c
  80b157:	68 8e 00 00 00       	push   $0x8e
  80b15c:	68 a2 2c 81 00       	push   $0x812ca2
  80b161:	e8 f2 31 00 00       	call   80e358 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b166:	85 db                	test   %ebx,%ebx
  80b168:	75 17                	jne    80b181 <recv_udp+0x4e>
  80b16a:	83 ec 04             	sub    $0x4,%esp
  80b16d:	68 c0 2b 81 00       	push   $0x812bc0
  80b172:	68 8f 00 00 00       	push   $0x8f
  80b177:	68 a2 2c 81 00       	push   $0x812ca2
  80b17c:	e8 d7 31 00 00       	call   80e358 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b181:	3b 43 08             	cmp    0x8(%ebx),%eax
  80b184:	74 17                	je     80b19d <recv_udp+0x6a>
  80b186:	83 ec 04             	sub    $0x4,%esp
  80b189:	68 d7 2c 81 00       	push   $0x812cd7
  80b18e:	68 91 00 00 00       	push   $0x91
  80b193:	68 a2 2c 81 00       	push   $0x812ca2
  80b198:	e8 bb 31 00 00       	call   80e358 <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b19d:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b1a1:	75 0e                	jne    80b1b1 <recv_udp+0x7e>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80b1a3:	83 ec 0c             	sub    $0xc,%esp
  80b1a6:	57                   	push   %edi
  80b1a7:	e8 78 95 ff ff       	call   804724 <pbuf_free>
    return;
  80b1ac:	83 c4 10             	add    $0x10,%esp
  80b1af:	eb 72                	jmp    80b223 <recv_udp+0xf0>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80b1b1:	83 ec 0c             	sub    $0xc,%esp
  80b1b4:	6a 06                	push   $0x6
  80b1b6:	e8 a0 91 ff ff       	call   80435b <memp_malloc>
  80b1bb:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b1bd:	83 c4 10             	add    $0x10,%esp
  80b1c0:	85 c0                	test   %eax,%eax
  80b1c2:	75 0e                	jne    80b1d2 <recv_udp+0x9f>
    pbuf_free(p);
  80b1c4:	83 ec 0c             	sub    $0xc,%esp
  80b1c7:	57                   	push   %edi
  80b1c8:	e8 57 95 ff ff       	call   804724 <pbuf_free>
    return;
  80b1cd:	83 c4 10             	add    $0x10,%esp
  80b1d0:	eb 51                	jmp    80b223 <recv_udp+0xf0>
  } else {
    buf->p = p;
  80b1d2:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b1d4:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b1d7:	8b 45 14             	mov    0x14(%ebp),%eax
  80b1da:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b1dd:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b1e1:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b1e5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b1e9:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b1ed:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b1f0:	85 c0                	test   %eax,%eax
  80b1f2:	74 10                	je     80b204 <recv_udp+0xd1>
  80b1f4:	83 ec 04             	sub    $0x4,%esp
  80b1f7:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b1fb:	52                   	push   %edx
  80b1fc:	6a 00                	push   $0x0
  80b1fe:	53                   	push   %ebx
  80b1ff:	ff d0                	call   *%eax
  80b201:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b204:	83 ec 08             	sub    $0x8,%esp
  80b207:	56                   	push   %esi
  80b208:	ff 73 14             	pushl  0x14(%ebx)
  80b20b:	e8 43 ee ff ff       	call   80a053 <sys_mbox_trypost>
  80b210:	83 c4 10             	add    $0x10,%esp
  80b213:	84 c0                	test   %al,%al
  80b215:	74 0c                	je     80b223 <recv_udp+0xf0>
    netbuf_delete(buf);
  80b217:	83 ec 0c             	sub    $0xc,%esp
  80b21a:	56                   	push   %esi
  80b21b:	e8 d2 71 ff ff       	call   8023f2 <netbuf_delete>
    return;
  80b220:	83 c4 10             	add    $0x10,%esp
  }
}
  80b223:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b226:	5b                   	pop    %ebx
  80b227:	5e                   	pop    %esi
  80b228:	5f                   	pop    %edi
  80b229:	5d                   	pop    %ebp
  80b22a:	c3                   	ret    

0080b22b <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80b22b:	55                   	push   %ebp
  80b22c:	89 e5                	mov    %esp,%ebp
  80b22e:	57                   	push   %edi
  80b22f:	56                   	push   %esi
  80b230:	53                   	push   %ebx
  80b231:	83 ec 0c             	sub    $0xc,%esp
  80b234:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b237:	85 db                	test   %ebx,%ebx
  80b239:	0f 84 c8 00 00 00    	je     80b307 <recv_raw+0xdc>
  80b23f:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b243:	0f 84 be 00 00 00    	je     80b307 <recv_raw+0xdc>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b249:	83 ec 04             	sub    $0x4,%esp
  80b24c:	6a 00                	push   $0x0
  80b24e:	8b 45 10             	mov    0x10(%ebp),%eax
  80b251:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b255:	50                   	push   %eax
  80b256:	6a 03                	push   $0x3
  80b258:	e8 8d 95 ff ff       	call   8047ea <pbuf_alloc>
  80b25d:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b25f:	83 c4 10             	add    $0x10,%esp
  80b262:	85 c0                	test   %eax,%eax
  80b264:	0f 84 9d 00 00 00    	je     80b307 <recv_raw+0xdc>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b26a:	83 ec 08             	sub    $0x8,%esp
  80b26d:	ff 75 10             	pushl  0x10(%ebp)
  80b270:	50                   	push   %eax
  80b271:	e8 72 9a ff ff       	call   804ce8 <pbuf_copy>
  80b276:	83 c4 10             	add    $0x10,%esp
  80b279:	84 c0                	test   %al,%al
  80b27b:	74 75                	je     80b2f2 <recv_raw+0xc7>
        pbuf_free(q);
  80b27d:	83 ec 0c             	sub    $0xc,%esp
  80b280:	56                   	push   %esi
  80b281:	e8 9e 94 ff ff       	call   804724 <pbuf_free>
  80b286:	83 c4 10             	add    $0x10,%esp
  80b289:	eb 7c                	jmp    80b307 <recv_raw+0xdc>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80b28b:	83 ec 0c             	sub    $0xc,%esp
  80b28e:	56                   	push   %esi
  80b28f:	e8 90 94 ff ff       	call   804724 <pbuf_free>
        return 0;
  80b294:	83 c4 10             	add    $0x10,%esp
  80b297:	eb 6e                	jmp    80b307 <recv_raw+0xdc>
      }

      buf->p = q;
  80b299:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b29b:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b29e:	8b 46 04             	mov    0x4(%esi),%eax
  80b2a1:	83 c0 0c             	add    $0xc,%eax
  80b2a4:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b2a7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b2aa:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b2ae:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b2b2:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b2b6:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b2ba:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b2bd:	85 c0                	test   %eax,%eax
  80b2bf:	74 10                	je     80b2d1 <recv_raw+0xa6>
  80b2c1:	83 ec 04             	sub    $0x4,%esp
  80b2c4:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b2c8:	52                   	push   %edx
  80b2c9:	6a 00                	push   $0x0
  80b2cb:	53                   	push   %ebx
  80b2cc:	ff d0                	call   *%eax
  80b2ce:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b2d1:	83 ec 08             	sub    $0x8,%esp
  80b2d4:	57                   	push   %edi
  80b2d5:	ff 73 14             	pushl  0x14(%ebx)
  80b2d8:	e8 76 ed ff ff       	call   80a053 <sys_mbox_trypost>
  80b2dd:	83 c4 10             	add    $0x10,%esp
  80b2e0:	84 c0                	test   %al,%al
  80b2e2:	74 23                	je     80b307 <recv_raw+0xdc>
        netbuf_delete(buf);
  80b2e4:	83 ec 0c             	sub    $0xc,%esp
  80b2e7:	57                   	push   %edi
  80b2e8:	e8 05 71 ff ff       	call   8023f2 <netbuf_delete>
  80b2ed:	83 c4 10             	add    $0x10,%esp
  80b2f0:	eb 15                	jmp    80b307 <recv_raw+0xdc>
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80b2f2:	83 ec 0c             	sub    $0xc,%esp
  80b2f5:	6a 06                	push   $0x6
  80b2f7:	e8 5f 90 ff ff       	call   80435b <memp_malloc>
  80b2fc:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b2fe:	83 c4 10             	add    $0x10,%esp
  80b301:	85 c0                	test   %eax,%eax
  80b303:	75 94                	jne    80b299 <recv_raw+0x6e>
  80b305:	eb 84                	jmp    80b28b <recv_raw+0x60>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80b307:	b8 00 00 00 00       	mov    $0x0,%eax
  80b30c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b30f:	5b                   	pop    %ebx
  80b310:	5e                   	pop    %esi
  80b311:	5f                   	pop    %edi
  80b312:	5d                   	pop    %ebp
  80b313:	c3                   	ret    

0080b314 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b314:	55                   	push   %ebp
  80b315:	89 e5                	mov    %esp,%ebp
  80b317:	53                   	push   %ebx
  80b318:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b31b:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b31e:	50                   	push   %eax
  80b31f:	53                   	push   %ebx
  80b320:	e8 ff a3 ff ff       	call   805724 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b325:	83 c4 08             	add    $0x8,%esp
  80b328:	68 7a b0 80 00       	push   $0x80b07a
  80b32d:	53                   	push   %ebx
  80b32e:	e8 ff a3 ff ff       	call   805732 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b333:	83 c4 08             	add    $0x8,%esp
  80b336:	68 b2 b7 80 00       	push   $0x80b7b2
  80b33b:	53                   	push   %ebx
  80b33c:	e8 02 a4 ff ff       	call   805743 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b341:	83 c4 0c             	add    $0xc,%esp
  80b344:	6a 04                	push   $0x4
  80b346:	68 6e b7 80 00       	push   $0x80b76e
  80b34b:	53                   	push   %ebx
  80b34c:	e8 22 a4 ff ff       	call   805773 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b351:	83 c4 08             	add    $0x8,%esp
  80b354:	68 b1 b3 80 00       	push   $0x80b3b1
  80b359:	53                   	push   %ebx
  80b35a:	e8 f5 a3 ff ff       	call   805754 <tcp_err>
}
  80b35f:	83 c4 10             	add    $0x10,%esp
  80b362:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b365:	c9                   	leave  
  80b366:	c3                   	ret    

0080b367 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b367:	55                   	push   %ebp
  80b368:	89 e5                	mov    %esp,%ebp
  80b36a:	53                   	push   %ebx
  80b36b:	83 ec 04             	sub    $0x4,%esp
  80b36e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b371:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b374:	85 db                	test   %ebx,%ebx
  80b376:	74 2f                	je     80b3a7 <do_connected+0x40>
    return ERR_VAL;
  }

  conn->err = err;
  80b378:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b37b:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b37e:	75 0b                	jne    80b38b <do_connected+0x24>
  80b380:	84 c0                	test   %al,%al
  80b382:	75 07                	jne    80b38b <do_connected+0x24>
    setup_tcp(conn);
  80b384:	89 d8                	mov    %ebx,%eax
  80b386:	e8 89 ff ff ff       	call   80b314 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80b38b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b392:	83 ec 0c             	sub    $0xc,%esp
  80b395:	ff 73 10             	pushl  0x10(%ebx)
  80b398:	e8 3a eb ff ff       	call   809ed7 <sys_sem_signal>
  return ERR_OK;
  80b39d:	83 c4 10             	add    $0x10,%esp
  80b3a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3a5:	eb 05                	jmp    80b3ac <do_connected+0x45>
  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
    return ERR_VAL;
  80b3a7:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  sys_sem_signal(conn->op_completed);
  return ERR_OK;
}
  80b3ac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b3af:	c9                   	leave  
  80b3b0:	c3                   	ret    

0080b3b1 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80b3b1:	55                   	push   %ebp
  80b3b2:	89 e5                	mov    %esp,%ebp
  80b3b4:	53                   	push   %ebx
  80b3b5:	83 ec 04             	sub    $0x4,%esp
  80b3b8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b3bb:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b3be:	85 db                	test   %ebx,%ebx
  80b3c0:	75 17                	jne    80b3d9 <err_tcp+0x28>
  80b3c2:	83 ec 04             	sub    $0x4,%esp
  80b3c5:	68 f5 2c 81 00       	push   $0x812cf5
  80b3ca:	68 22 01 00 00       	push   $0x122
  80b3cf:	68 a2 2c 81 00       	push   $0x812ca2
  80b3d4:	e8 7f 2f 00 00       	call   80e358 <_panic>

  conn->pcb.tcp = NULL;
  80b3d9:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80b3e0:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b3e3:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b3e7:	74 24                	je     80b40d <err_tcp+0x5c>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b3e9:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b3ec:	85 c0                	test   %eax,%eax
  80b3ee:	74 0d                	je     80b3fd <err_tcp+0x4c>
  80b3f0:	83 ec 04             	sub    $0x4,%esp
  80b3f3:	6a 00                	push   $0x0
  80b3f5:	6a 00                	push   $0x0
  80b3f7:	53                   	push   %ebx
  80b3f8:	ff d0                	call   *%eax
  80b3fa:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b3fd:	83 ec 08             	sub    $0x8,%esp
  80b400:	6a 00                	push   $0x0
  80b402:	ff 73 14             	pushl  0x14(%ebx)
  80b405:	e8 0c ed ff ff       	call   80a116 <sys_mbox_post>
  80b40a:	83 c4 10             	add    $0x10,%esp
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b40d:	8b 43 10             	mov    0x10(%ebx),%eax
  80b410:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b413:	74 19                	je     80b42e <err_tcp+0x7d>
  80b415:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b419:	75 13                	jne    80b42e <err_tcp+0x7d>
    conn->state = NETCONN_NONE;
  80b41b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b422:	83 ec 0c             	sub    $0xc,%esp
  80b425:	50                   	push   %eax
  80b426:	e8 ac ea ff ff       	call   809ed7 <sys_sem_signal>
  80b42b:	83 c4 10             	add    $0x10,%esp
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b42e:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b432:	74 24                	je     80b458 <err_tcp+0xa7>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b434:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b437:	85 c0                	test   %eax,%eax
  80b439:	74 0d                	je     80b448 <err_tcp+0x97>
  80b43b:	83 ec 04             	sub    $0x4,%esp
  80b43e:	6a 00                	push   $0x0
  80b440:	6a 00                	push   $0x0
  80b442:	53                   	push   %ebx
  80b443:	ff d0                	call   *%eax
  80b445:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b448:	83 ec 08             	sub    $0x8,%esp
  80b44b:	6a 00                	push   $0x0
  80b44d:	ff 73 18             	pushl  0x18(%ebx)
  80b450:	e8 c1 ec ff ff       	call   80a116 <sys_mbox_post>
  80b455:	83 c4 10             	add    $0x10,%esp
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b458:	8b 43 04             	mov    0x4(%ebx),%eax
  80b45b:	83 f8 01             	cmp    $0x1,%eax
  80b45e:	74 05                	je     80b465 <err_tcp+0xb4>
  80b460:	83 f8 04             	cmp    $0x4,%eax
  80b463:	75 15                	jne    80b47a <err_tcp+0xc9>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80b465:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80b46c:	83 ec 0c             	sub    $0xc,%esp
  80b46f:	ff 73 10             	pushl  0x10(%ebx)
  80b472:	e8 60 ea ff ff       	call   809ed7 <sys_sem_signal>
  80b477:	83 c4 10             	add    $0x10,%esp
  }
}
  80b47a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b47d:	c9                   	leave  
  80b47e:	c3                   	ret    

0080b47f <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b47f:	55                   	push   %ebp
  80b480:	89 e5                	mov    %esp,%ebp
  80b482:	57                   	push   %edi
  80b483:	56                   	push   %esi
  80b484:	53                   	push   %ebx
  80b485:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b488:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b48c:	74 17                	je     80b4a5 <do_writemore+0x26>
  80b48e:	83 ec 04             	sub    $0x4,%esp
  80b491:	68 02 2d 81 00       	push   $0x812d02
  80b496:	68 b8 03 00 00       	push   $0x3b8
  80b49b:	68 a2 2c 81 00       	push   $0x812ca2
  80b4a0:	e8 b3 2e 00 00       	call   80e358 <_panic>
  80b4a5:	89 c6                	mov    %eax,%esi

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b4a7:	8b 50 24             	mov    0x24(%eax),%edx
  80b4aa:	8b 78 28             	mov    0x28(%eax),%edi
  80b4ad:	89 f9                	mov    %edi,%ecx
  80b4af:	03 4a 04             	add    0x4(%edx),%ecx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b4b2:	8b 42 08             	mov    0x8(%edx),%eax
  80b4b5:	89 c3                	mov    %eax,%ebx
  80b4b7:	29 fb                	sub    %edi,%ebx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b4b9:	29 f8                	sub    %edi,%eax
  80b4bb:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  80b4c1:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80b4c6:	0f 4f c3             	cmovg  %ebx,%eax
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b4c9:	8b 7e 08             	mov    0x8(%esi),%edi
  80b4cc:	0f b7 5f 6e          	movzwl 0x6e(%edi),%ebx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b4d0:	66 39 d8             	cmp    %bx,%ax
  80b4d3:	0f 46 d8             	cmovbe %eax,%ebx
  80b4d6:	0f b7 db             	movzwl %bx,%ebx
  80b4d9:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  80b4dd:	50                   	push   %eax
  80b4de:	53                   	push   %ebx
  80b4df:	51                   	push   %ecx
  80b4e0:	57                   	push   %edi
  80b4e1:	e8 c0 c9 ff ff       	call   807ea6 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b4e6:	89 da                	mov    %ebx,%edx
  80b4e8:	03 56 28             	add    0x28(%esi),%edx
  80b4eb:	8b 4e 24             	mov    0x24(%esi),%ecx
  80b4ee:	83 c4 10             	add    $0x10,%esp
  80b4f1:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b4f4:	7e 17                	jle    80b50d <do_writemore+0x8e>
  80b4f6:	83 ec 04             	sub    $0x4,%esp
  80b4f9:	68 1f 2d 81 00       	push   $0x812d1f
  80b4fe:	68 cd 03 00 00       	push   $0x3cd
  80b503:	68 a2 2c 81 00       	push   $0x812ca2
  80b508:	e8 4b 2e 00 00       	call   80e358 <_panic>
  if (err == ERR_OK) {
  80b50d:	84 c0                	test   %al,%al
  80b50f:	75 6e                	jne    80b57f <do_writemore+0x100>
    conn->write_offset += len;
  80b511:	89 56 28             	mov    %edx,0x28(%esi)
do_writemore(struct netconn *conn)
{
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  80b514:	bf 00 00 00 00       	mov    $0x0,%edi

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80b519:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b51c:	75 13                	jne    80b531 <do_writemore+0xb2>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80b51e:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
      conn->write_offset = 0;
  80b525:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
      /* everything was written */
      write_finished = 1;
  80b52c:	bf 01 00 00 00       	mov    $0x1,%edi
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80b531:	8b 46 08             	mov    0x8(%esi),%eax
  80b534:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b538:	74 12                	je     80b54c <do_writemore+0xcd>
  80b53a:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80b53e:	75 0c                	jne    80b54c <do_writemore+0xcd>
  80b540:	8b 50 74             	mov    0x74(%eax),%edx
  80b543:	85 d2                	test   %edx,%edx
  80b545:	74 6e                	je     80b5b5 <do_writemore+0x136>
  80b547:	83 3a 00             	cmpl   $0x0,(%edx)
  80b54a:	74 69                	je     80b5b5 <do_writemore+0x136>
  80b54c:	83 ec 0c             	sub    $0xc,%esp
  80b54f:	50                   	push   %eax
  80b550:	e8 a4 c9 ff ff       	call   807ef9 <tcp_output>
    conn->err = err;
  80b555:	88 46 0c             	mov    %al,0xc(%esi)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80b558:	83 c4 10             	add    $0x10,%esp
  80b55b:	84 c0                	test   %al,%al
  80b55d:	75 39                	jne    80b598 <do_writemore+0x119>
  80b55f:	8b 46 08             	mov    0x8(%esi),%eax
  80b562:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b568:	77 2e                	ja     80b598 <do_writemore+0x119>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80b56a:	8b 46 2c             	mov    0x2c(%esi),%eax
  80b56d:	85 c0                	test   %eax,%eax
  80b56f:	74 27                	je     80b598 <do_writemore+0x119>
  80b571:	83 ec 04             	sub    $0x4,%esp
  80b574:	53                   	push   %ebx
  80b575:	6a 03                	push   $0x3
  80b577:	56                   	push   %esi
  80b578:	ff d0                	call   *%eax
  80b57a:	83 c4 10             	add    $0x10,%esp
  80b57d:	eb 19                	jmp    80b598 <do_writemore+0x119>
    }
  } else if (err == ERR_MEM) {
  80b57f:	3c ff                	cmp    $0xff,%al
  80b581:	75 10                	jne    80b593 <do_writemore+0x114>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80b583:	83 ec 0c             	sub    $0xc,%esp
  80b586:	ff 76 08             	pushl  0x8(%esi)
  80b589:	e8 6b c9 ff ff       	call   807ef9 <tcp_output>
  80b58e:	83 c4 10             	add    $0x10,%esp
  80b591:	eb 28                	jmp    80b5bb <do_writemore+0x13c>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80b593:	88 46 0c             	mov    %al,0xc(%esi)
  80b596:	eb 06                	jmp    80b59e <do_writemore+0x11f>
    write_finished = 1;
  }

  if (write_finished) {
  80b598:	89 f8                	mov    %edi,%eax
  80b59a:	84 c0                	test   %al,%al
  80b59c:	74 1d                	je     80b5bb <do_writemore+0x13c>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80b59e:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80b5a5:	83 ec 0c             	sub    $0xc,%esp
  80b5a8:	ff 76 10             	pushl  0x10(%esi)
  80b5ab:	e8 27 e9 ff ff       	call   809ed7 <sys_sem_signal>
  80b5b0:	83 c4 10             	add    $0x10,%esp
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
  80b5b3:	eb 06                	jmp    80b5bb <do_writemore+0x13c>
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80b5b5:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b5b9:	eb a4                	jmp    80b55f <do_writemore+0xe0>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80b5bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80b5c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b5c3:	5b                   	pop    %ebx
  80b5c4:	5e                   	pop    %esi
  80b5c5:	5f                   	pop    %edi
  80b5c6:	5d                   	pop    %ebp
  80b5c7:	c3                   	ret    

0080b5c8 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80b5c8:	55                   	push   %ebp
  80b5c9:	89 e5                	mov    %esp,%ebp
  80b5cb:	53                   	push   %ebx
  80b5cc:	83 ec 04             	sub    $0x4,%esp
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b5cf:	85 c0                	test   %eax,%eax
  80b5d1:	75 17                	jne    80b5ea <do_close_internal+0x22>
  80b5d3:	83 ec 04             	sub    $0x4,%esp
  80b5d6:	68 10 2b 81 00       	push   $0x812b10
  80b5db:	68 53 02 00 00       	push   $0x253
  80b5e0:	68 a2 2c 81 00       	push   $0x812ca2
  80b5e5:	e8 6e 2d 00 00       	call   80e358 <_panic>
  80b5ea:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b5ec:	83 38 10             	cmpl   $0x10,(%eax)
  80b5ef:	74 17                	je     80b608 <do_close_internal+0x40>
  80b5f1:	83 ec 04             	sub    $0x4,%esp
  80b5f4:	68 3d 2d 81 00       	push   $0x812d3d
  80b5f9:	68 54 02 00 00       	push   $0x254
  80b5fe:	68 a2 2c 81 00       	push   $0x812ca2
  80b603:	e8 50 2d 00 00       	call   80e358 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b608:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80b60c:	74 17                	je     80b625 <do_close_internal+0x5d>
  80b60e:	83 ec 04             	sub    $0x4,%esp
  80b611:	68 e0 2b 81 00       	push   $0x812be0
  80b616:	68 55 02 00 00       	push   $0x255
  80b61b:	68 a2 2c 81 00       	push   $0x812ca2
  80b620:	e8 33 2d 00 00       	call   80e358 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b625:	8b 40 08             	mov    0x8(%eax),%eax
  80b628:	85 c0                	test   %eax,%eax
  80b62a:	75 17                	jne    80b643 <do_close_internal+0x7b>
  80b62c:	83 ec 04             	sub    $0x4,%esp
  80b62f:	68 5b 2d 81 00       	push   $0x812d5b
  80b634:	68 56 02 00 00       	push   $0x256
  80b639:	68 a2 2c 81 00       	push   $0x812ca2
  80b63e:	e8 15 2d 00 00       	call   80e358 <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80b643:	83 ec 08             	sub    $0x8,%esp
  80b646:	6a 00                	push   $0x0
  80b648:	50                   	push   %eax
  80b649:	e8 d6 a0 ff ff       	call   805724 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80b64e:	8b 43 08             	mov    0x8(%ebx),%eax
  80b651:	83 c4 10             	add    $0x10,%esp
  80b654:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b658:	75 10                	jne    80b66a <do_close_internal+0xa2>
    tcp_accept(conn->pcb.tcp, NULL);
  80b65a:	83 ec 08             	sub    $0x8,%esp
  80b65d:	6a 00                	push   $0x0
  80b65f:	50                   	push   %eax
  80b660:	e8 00 a1 ff ff       	call   805765 <tcp_accept>
  80b665:	83 c4 10             	add    $0x10,%esp
  80b668:	eb 44                	jmp    80b6ae <do_close_internal+0xe6>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80b66a:	83 ec 08             	sub    $0x8,%esp
  80b66d:	6a 00                	push   $0x0
  80b66f:	50                   	push   %eax
  80b670:	e8 bd a0 ff ff       	call   805732 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80b675:	83 c4 08             	add    $0x8,%esp
  80b678:	6a 00                	push   $0x0
  80b67a:	ff 73 08             	pushl  0x8(%ebx)
  80b67d:	e8 e3 a0 ff ff       	call   805765 <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80b682:	83 c4 08             	add    $0x8,%esp
  80b685:	6a 00                	push   $0x0
  80b687:	ff 73 08             	pushl  0x8(%ebx)
  80b68a:	e8 b4 a0 ff ff       	call   805743 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80b68f:	83 c4 0c             	add    $0xc,%esp
  80b692:	6a 04                	push   $0x4
  80b694:	6a 00                	push   $0x0
  80b696:	ff 73 08             	pushl  0x8(%ebx)
  80b699:	e8 d5 a0 ff ff       	call   805773 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80b69e:	83 c4 08             	add    $0x8,%esp
  80b6a1:	6a 00                	push   $0x0
  80b6a3:	ff 73 08             	pushl  0x8(%ebx)
  80b6a6:	e8 a9 a0 ff ff       	call   805754 <tcp_err>
  80b6ab:	83 c4 10             	add    $0x10,%esp
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80b6ae:	83 ec 0c             	sub    $0xc,%esp
  80b6b1:	ff 73 08             	pushl  0x8(%ebx)
  80b6b4:	e8 78 a2 ff ff       	call   805931 <tcp_close>
  if (err == ERR_OK) {
  80b6b9:	83 c4 10             	add    $0x10,%esp
  80b6bc:	84 c0                	test   %al,%al
  80b6be:	75 4a                	jne    80b70a <do_close_internal+0x142>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80b6c0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80b6c7:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80b6ce:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b6d2:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b6d5:	85 c0                	test   %eax,%eax
  80b6d7:	74 21                	je     80b6fa <do_close_internal+0x132>
  80b6d9:	83 ec 04             	sub    $0x4,%esp
  80b6dc:	6a 00                	push   $0x0
  80b6de:	6a 00                	push   $0x0
  80b6e0:	53                   	push   %ebx
  80b6e1:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80b6e3:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b6e6:	83 c4 10             	add    $0x10,%esp
  80b6e9:	85 c0                	test   %eax,%eax
  80b6eb:	74 0d                	je     80b6fa <do_close_internal+0x132>
  80b6ed:	83 ec 04             	sub    $0x4,%esp
  80b6f0:	6a 00                	push   $0x0
  80b6f2:	6a 02                	push   $0x2
  80b6f4:	53                   	push   %ebx
  80b6f5:	ff d0                	call   *%eax
  80b6f7:	83 c4 10             	add    $0x10,%esp
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80b6fa:	83 ec 0c             	sub    $0xc,%esp
  80b6fd:	ff 73 10             	pushl  0x10(%ebx)
  80b700:	e8 d2 e7 ff ff       	call   809ed7 <sys_sem_signal>
  80b705:	83 c4 10             	add    $0x10,%esp
  80b708:	eb 5f                	jmp    80b769 <do_close_internal+0x1a1>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b70a:	8b 43 08             	mov    0x8(%ebx),%eax
  80b70d:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b711:	75 17                	jne    80b72a <do_close_internal+0x162>
  80b713:	83 ec 04             	sub    $0x4,%esp
  80b716:	68 04 2c 81 00       	push   $0x812c04
  80b71b:	68 75 02 00 00       	push   $0x275
  80b720:	68 a2 2c 81 00       	push   $0x812ca2
  80b725:	e8 2e 2c 00 00       	call   80e358 <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80b72a:	83 ec 08             	sub    $0x8,%esp
  80b72d:	68 b2 b7 80 00       	push   $0x80b7b2
  80b732:	50                   	push   %eax
  80b733:	e8 0b a0 ff ff       	call   805743 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80b738:	83 c4 0c             	add    $0xc,%esp
  80b73b:	6a 04                	push   $0x4
  80b73d:	68 6e b7 80 00       	push   $0x80b76e
  80b742:	ff 73 08             	pushl  0x8(%ebx)
  80b745:	e8 29 a0 ff ff       	call   805773 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80b74a:	83 c4 08             	add    $0x8,%esp
  80b74d:	68 b1 b3 80 00       	push   $0x80b3b1
  80b752:	ff 73 08             	pushl  0x8(%ebx)
  80b755:	e8 fa 9f ff ff       	call   805754 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80b75a:	83 c4 08             	add    $0x8,%esp
  80b75d:	53                   	push   %ebx
  80b75e:	ff 73 08             	pushl  0x8(%ebx)
  80b761:	e8 be 9f ff ff       	call   805724 <tcp_arg>
  80b766:	83 c4 10             	add    $0x10,%esp
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80b769:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b76c:	c9                   	leave  
  80b76d:	c3                   	ret    

0080b76e <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80b76e:	55                   	push   %ebp
  80b76f:	89 e5                	mov    %esp,%ebp
  80b771:	83 ec 08             	sub    $0x8,%esp
  80b774:	8b 45 08             	mov    0x8(%ebp),%eax
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b777:	85 c0                	test   %eax,%eax
  80b779:	75 17                	jne    80b792 <poll_tcp+0x24>
  80b77b:	83 ec 04             	sub    $0x4,%esp
  80b77e:	68 f5 2c 81 00       	push   $0x812cf5
  80b783:	68 eb 00 00 00       	push   $0xeb
  80b788:	68 a2 2c 81 00       	push   $0x812ca2
  80b78d:	e8 c6 2b 00 00       	call   80e358 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80b792:	8b 50 04             	mov    0x4(%eax),%edx
  80b795:	83 fa 01             	cmp    $0x1,%edx
  80b798:	75 07                	jne    80b7a1 <poll_tcp+0x33>
    do_writemore(conn);
  80b79a:	e8 e0 fc ff ff       	call   80b47f <do_writemore>
  80b79f:	eb 0a                	jmp    80b7ab <poll_tcp+0x3d>
  } else if (conn->state == NETCONN_CLOSE) {
  80b7a1:	83 fa 04             	cmp    $0x4,%edx
  80b7a4:	75 05                	jne    80b7ab <poll_tcp+0x3d>
    do_close_internal(conn);
  80b7a6:	e8 1d fe ff ff       	call   80b5c8 <do_close_internal>
  }

  return ERR_OK;
}
  80b7ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80b7b0:	c9                   	leave  
  80b7b1:	c3                   	ret    

0080b7b2 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80b7b2:	55                   	push   %ebp
  80b7b3:	89 e5                	mov    %esp,%ebp
  80b7b5:	56                   	push   %esi
  80b7b6:	53                   	push   %ebx
  80b7b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b7ba:	8b 75 10             	mov    0x10(%ebp),%esi
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b7bd:	85 db                	test   %ebx,%ebx
  80b7bf:	75 17                	jne    80b7d8 <sent_tcp+0x26>
  80b7c1:	83 ec 04             	sub    $0x4,%esp
  80b7c4:	68 f5 2c 81 00       	push   $0x812cf5
  80b7c9:	68 03 01 00 00       	push   $0x103
  80b7ce:	68 a2 2c 81 00       	push   $0x812ca2
  80b7d3:	e8 80 2b 00 00       	call   80e358 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80b7d8:	8b 43 04             	mov    0x4(%ebx),%eax
  80b7db:	83 f8 01             	cmp    $0x1,%eax
  80b7de:	75 26                	jne    80b806 <sent_tcp+0x54>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80b7e0:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80b7e4:	75 17                	jne    80b7fd <sent_tcp+0x4b>
  80b7e6:	83 ec 04             	sub    $0x4,%esp
  80b7e9:	68 6e 2d 81 00       	push   $0x812d6e
  80b7ee:	68 06 01 00 00       	push   $0x106
  80b7f3:	68 a2 2c 81 00       	push   $0x812ca2
  80b7f8:	e8 5b 2b 00 00       	call   80e358 <_panic>
    do_writemore(conn);
  80b7fd:	89 d8                	mov    %ebx,%eax
  80b7ff:	e8 7b fc ff ff       	call   80b47f <do_writemore>
  80b804:	eb 2e                	jmp    80b834 <sent_tcp+0x82>
  } else if (conn->state == NETCONN_CLOSE) {
  80b806:	83 f8 04             	cmp    $0x4,%eax
  80b809:	75 29                	jne    80b834 <sent_tcp+0x82>
    do_close_internal(conn);
  80b80b:	89 d8                	mov    %ebx,%eax
  80b80d:	e8 b6 fd ff ff       	call   80b5c8 <do_close_internal>
  80b812:	eb 20                	jmp    80b834 <sent_tcp+0x82>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80b814:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b81a:	76 1f                	jbe    80b83b <sent_tcp+0x89>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80b81c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b81f:	85 c0                	test   %eax,%eax
  80b821:	74 18                	je     80b83b <sent_tcp+0x89>
  80b823:	83 ec 04             	sub    $0x4,%esp
  80b826:	0f b7 f6             	movzwl %si,%esi
  80b829:	56                   	push   %esi
  80b82a:	6a 02                	push   $0x2
  80b82c:	53                   	push   %ebx
  80b82d:	ff d0                	call   *%eax
  80b82f:	83 c4 10             	add    $0x10,%esp
  80b832:	eb 07                	jmp    80b83b <sent_tcp+0x89>
  } else if (conn->state == NETCONN_CLOSE) {
    do_close_internal(conn);
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80b834:	8b 43 08             	mov    0x8(%ebx),%eax
  80b837:	85 c0                	test   %eax,%eax
  80b839:	75 d9                	jne    80b814 <sent_tcp+0x62>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
    }
  }
  
  return ERR_OK;
}
  80b83b:	b8 00 00 00 00       	mov    $0x0,%eax
  80b840:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b843:	5b                   	pop    %ebx
  80b844:	5e                   	pop    %esi
  80b845:	5d                   	pop    %ebp
  80b846:	c3                   	ret    

0080b847 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80b847:	55                   	push   %ebp
  80b848:	89 e5                	mov    %esp,%ebp
  80b84a:	56                   	push   %esi
  80b84b:	53                   	push   %ebx
  80b84c:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80b84f:	8b 03                	mov    (%ebx),%eax
  80b851:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80b855:	0f 85 ce 00 00 00    	jne    80b929 <do_newconn+0xe2>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80b85b:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80b85f:	8b 33                	mov    (%ebx),%esi
  80b861:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80b865:	74 17                	je     80b87e <do_newconn+0x37>
  80b867:	83 ec 04             	sub    $0x4,%esp
  80b86a:	68 28 2c 81 00       	push   $0x812c28
  80b86f:	68 8a 01 00 00       	push   $0x18a
  80b874:	68 a2 2c 81 00       	push   $0x812ca2
  80b879:	e8 da 2a 00 00       	call   80e358 <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80b87e:	8b 06                	mov    (%esi),%eax
  80b880:	25 f0 00 00 00       	and    $0xf0,%eax
  80b885:	83 f8 20             	cmp    $0x20,%eax
  80b888:	74 46                	je     80b8d0 <do_newconn+0x89>
  80b88a:	83 f8 40             	cmp    $0x40,%eax
  80b88d:	74 0b                	je     80b89a <do_newconn+0x53>
  80b88f:	83 f8 10             	cmp    $0x10,%eax
  80b892:	0f 85 8d 00 00 00    	jne    80b925 <do_newconn+0xde>
  80b898:	eb 6e                	jmp    80b908 <do_newconn+0xc1>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80b89a:	83 ec 0c             	sub    $0xc,%esp
  80b89d:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80b8a1:	50                   	push   %eax
  80b8a2:	e8 2c 25 00 00       	call   80ddd3 <raw_new>
  80b8a7:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80b8aa:	8b 03                	mov    (%ebx),%eax
  80b8ac:	8b 50 08             	mov    0x8(%eax),%edx
  80b8af:	83 c4 10             	add    $0x10,%esp
  80b8b2:	85 d2                	test   %edx,%edx
  80b8b4:	75 06                	jne    80b8bc <do_newconn+0x75>
       msg->conn->err = ERR_MEM;
  80b8b6:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80b8ba:	eb 6d                	jmp    80b929 <do_newconn+0xe2>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80b8bc:	83 ec 04             	sub    $0x4,%esp
  80b8bf:	50                   	push   %eax
  80b8c0:	68 2b b2 80 00       	push   $0x80b22b
  80b8c5:	52                   	push   %edx
  80b8c6:	e8 86 23 00 00       	call   80dc51 <raw_recv>
  80b8cb:	83 c4 10             	add    $0x10,%esp
  80b8ce:	eb 59                	jmp    80b929 <do_newconn+0xe2>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80b8d0:	e8 98 d5 ff ff       	call   808e6d <udp_new>
  80b8d5:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80b8d8:	8b 03                	mov    (%ebx),%eax
  80b8da:	8b 50 08             	mov    0x8(%eax),%edx
  80b8dd:	85 d2                	test   %edx,%edx
  80b8df:	75 06                	jne    80b8e7 <do_newconn+0xa0>
       msg->conn->err = ERR_MEM;
  80b8e1:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80b8e5:	eb 42                	jmp    80b929 <do_newconn+0xe2>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80b8e7:	83 38 22             	cmpl   $0x22,(%eax)
  80b8ea:	75 04                	jne    80b8f0 <do_newconn+0xa9>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80b8ec:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80b8f0:	8b 03                	mov    (%ebx),%eax
  80b8f2:	83 ec 04             	sub    $0x4,%esp
  80b8f5:	50                   	push   %eax
  80b8f6:	68 33 b1 80 00       	push   $0x80b133
  80b8fb:	ff 70 08             	pushl  0x8(%eax)
  80b8fe:	e8 12 d5 ff ff       	call   808e15 <udp_recv>
  80b903:	83 c4 10             	add    $0x10,%esp
  80b906:	eb 21                	jmp    80b929 <do_newconn+0xe2>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80b908:	e8 e8 a8 ff ff       	call   8061f5 <tcp_new>
  80b90d:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80b910:	8b 03                	mov    (%ebx),%eax
  80b912:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80b916:	75 06                	jne    80b91e <do_newconn+0xd7>
       msg->conn->err = ERR_MEM;
  80b918:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80b91c:	eb 0b                	jmp    80b929 <do_newconn+0xe2>
       break;
     }
     setup_tcp(msg->conn);
  80b91e:	e8 f1 f9 ff ff       	call   80b314 <setup_tcp>
  80b923:	eb 04                	jmp    80b929 <do_newconn+0xe2>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80b925:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80b929:	83 ec 0c             	sub    $0xc,%esp
  80b92c:	8b 03                	mov    (%ebx),%eax
  80b92e:	ff 70 10             	pushl  0x10(%eax)
  80b931:	e8 a1 e5 ff ff       	call   809ed7 <sys_sem_signal>
}
  80b936:	83 c4 10             	add    $0x10,%esp
  80b939:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b93c:	5b                   	pop    %ebx
  80b93d:	5e                   	pop    %esi
  80b93e:	5d                   	pop    %ebp
  80b93f:	c3                   	ret    

0080b940 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80b940:	55                   	push   %ebp
  80b941:	89 e5                	mov    %esp,%ebp
  80b943:	53                   	push   %ebx
  80b944:	83 ec 10             	sub    $0x10,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80b947:	6a 07                	push   $0x7
  80b949:	e8 0d 8a ff ff       	call   80435b <memp_malloc>
  if (conn == NULL) {
  80b94e:	83 c4 10             	add    $0x10,%esp
  80b951:	85 c0                	test   %eax,%eax
  80b953:	0f 84 96 00 00 00    	je     80b9ef <netconn_alloc+0xaf>
  80b959:	89 c3                	mov    %eax,%ebx
    return NULL;
  }

  conn->err = ERR_OK;
  80b95b:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80b95f:	8b 45 08             	mov    0x8(%ebp),%eax
  80b962:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80b964:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80b96b:	83 ec 0c             	sub    $0xc,%esp
  80b96e:	6a 00                	push   $0x0
  80b970:	e8 b6 e2 ff ff       	call   809c2b <sys_sem_new>
  80b975:	89 43 10             	mov    %eax,0x10(%ebx)
  80b978:	83 c4 10             	add    $0x10,%esp
  80b97b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b97e:	75 15                	jne    80b995 <netconn_alloc+0x55>
    memp_free(MEMP_NETCONN, conn);
  80b980:	83 ec 08             	sub    $0x8,%esp
  80b983:	53                   	push   %ebx
  80b984:	6a 07                	push   $0x7
  80b986:	e8 26 8a ff ff       	call   8043b1 <memp_free>
    return NULL;
  80b98b:	83 c4 10             	add    $0x10,%esp
  80b98e:	b8 00 00 00 00       	mov    $0x0,%eax
  80b993:	eb 5f                	jmp    80b9f4 <netconn_alloc+0xb4>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80b995:	83 ec 0c             	sub    $0xc,%esp
  80b998:	6a 00                	push   $0x0
  80b99a:	e8 35 e4 ff ff       	call   809dd4 <sys_mbox_new>
  80b99f:	89 43 14             	mov    %eax,0x14(%ebx)
  80b9a2:	83 c4 10             	add    $0x10,%esp
  80b9a5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b9a8:	75 20                	jne    80b9ca <netconn_alloc+0x8a>
    sys_sem_free(conn->op_completed);
  80b9aa:	83 ec 0c             	sub    $0xc,%esp
  80b9ad:	ff 73 10             	pushl  0x10(%ebx)
  80b9b0:	e8 f7 e2 ff ff       	call   809cac <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80b9b5:	83 c4 08             	add    $0x8,%esp
  80b9b8:	53                   	push   %ebx
  80b9b9:	6a 07                	push   $0x7
  80b9bb:	e8 f1 89 ff ff       	call   8043b1 <memp_free>
    return NULL;
  80b9c0:	83 c4 10             	add    $0x10,%esp
  80b9c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9c8:	eb 2a                	jmp    80b9f4 <netconn_alloc+0xb4>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80b9ca:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80b9d1:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80b9d8:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80b9df:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b9e2:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80b9e5:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  80b9eb:	89 d8                	mov    %ebx,%eax
  80b9ed:	eb 05                	jmp    80b9f4 <netconn_alloc+0xb4>
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  if (conn == NULL) {
    return NULL;
  80b9ef:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80b9f4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b9f7:	c9                   	leave  
  80b9f8:	c3                   	ret    

0080b9f9 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80b9f9:	55                   	push   %ebp
  80b9fa:	89 e5                	mov    %esp,%ebp
  80b9fc:	56                   	push   %esi
  80b9fd:	53                   	push   %ebx
  80b9fe:	83 ec 10             	sub    $0x10,%esp
  80ba01:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80ba04:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80ba08:	74 17                	je     80ba21 <netconn_free+0x28>
  80ba0a:	83 ec 04             	sub    $0x4,%esp
  80ba0d:	68 48 2c 81 00       	push   $0x812c48
  80ba12:	68 26 02 00 00       	push   $0x226
  80ba17:	68 a2 2c 81 00       	push   $0x812ca2
  80ba1c:	e8 37 29 00 00       	call   80e358 <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80ba21:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80ba24:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80ba28:	75 2a                	jne    80ba54 <netconn_free+0x5b>
  80ba2a:	eb 51                	jmp    80ba7d <netconn_free+0x84>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80ba2c:	83 3b 10             	cmpl   $0x10,(%ebx)
  80ba2f:	75 15                	jne    80ba46 <netconn_free+0x4d>
        if(mem != NULL) {
  80ba31:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ba34:	85 c0                	test   %eax,%eax
  80ba36:	74 1c                	je     80ba54 <netconn_free+0x5b>
          pbuf_free((struct pbuf *)mem);
  80ba38:	83 ec 0c             	sub    $0xc,%esp
  80ba3b:	50                   	push   %eax
  80ba3c:	e8 e3 8c ff ff       	call   804724 <pbuf_free>
  80ba41:	83 c4 10             	add    $0x10,%esp
  80ba44:	eb 0e                	jmp    80ba54 <netconn_free+0x5b>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80ba46:	83 ec 0c             	sub    $0xc,%esp
  80ba49:	ff 75 f4             	pushl  -0xc(%ebp)
  80ba4c:	e8 a1 69 ff ff       	call   8023f2 <netbuf_delete>
  80ba51:	83 c4 10             	add    $0x10,%esp
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80ba54:	83 ec 08             	sub    $0x8,%esp
  80ba57:	56                   	push   %esi
  80ba58:	ff 73 14             	pushl  0x14(%ebx)
  80ba5b:	e8 d2 e7 ff ff       	call   80a232 <sys_arch_mbox_tryfetch>
  80ba60:	83 c4 10             	add    $0x10,%esp
  80ba63:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ba66:	75 c4                	jne    80ba2c <netconn_free+0x33>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80ba68:	83 ec 0c             	sub    $0xc,%esp
  80ba6b:	ff 73 14             	pushl  0x14(%ebx)
  80ba6e:	e8 c2 e2 ff ff       	call   809d35 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80ba73:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80ba7a:	83 c4 10             	add    $0x10,%esp
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80ba7d:	8d 75 f4             	lea    -0xc(%ebp),%esi
    sys_mbox_free(conn->recvmbox);
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80ba80:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80ba84:	75 10                	jne    80ba96 <netconn_free+0x9d>
  80ba86:	eb 37                	jmp    80babf <netconn_free+0xc6>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80ba88:	83 ec 0c             	sub    $0xc,%esp
  80ba8b:	ff 75 f4             	pushl  -0xc(%ebp)
  80ba8e:	e8 83 f0 ff ff       	call   80ab16 <netconn_delete>
  80ba93:	83 c4 10             	add    $0x10,%esp
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80ba96:	83 ec 08             	sub    $0x8,%esp
  80ba99:	56                   	push   %esi
  80ba9a:	ff 73 18             	pushl  0x18(%ebx)
  80ba9d:	e8 90 e7 ff ff       	call   80a232 <sys_arch_mbox_tryfetch>
  80baa2:	83 c4 10             	add    $0x10,%esp
  80baa5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80baa8:	75 de                	jne    80ba88 <netconn_free+0x8f>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80baaa:	83 ec 0c             	sub    $0xc,%esp
  80baad:	ff 73 18             	pushl  0x18(%ebx)
  80bab0:	e8 80 e2 ff ff       	call   809d35 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80bab5:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80babc:	83 c4 10             	add    $0x10,%esp
  }

  sys_sem_free(conn->op_completed);
  80babf:	83 ec 0c             	sub    $0xc,%esp
  80bac2:	ff 73 10             	pushl  0x10(%ebx)
  80bac5:	e8 e2 e1 ff ff       	call   809cac <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80baca:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80bad1:	83 c4 08             	add    $0x8,%esp
  80bad4:	53                   	push   %ebx
  80bad5:	6a 07                	push   $0x7
  80bad7:	e8 d5 88 ff ff       	call   8043b1 <memp_free>
}
  80badc:	83 c4 10             	add    $0x10,%esp
  80badf:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bae2:	5b                   	pop    %ebx
  80bae3:	5e                   	pop    %esi
  80bae4:	5d                   	pop    %ebp
  80bae5:	c3                   	ret    

0080bae6 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80bae6:	55                   	push   %ebp
  80bae7:	89 e5                	mov    %esp,%ebp
  80bae9:	57                   	push   %edi
  80baea:	56                   	push   %esi
  80baeb:	53                   	push   %ebx
  80baec:	83 ec 0c             	sub    $0xc,%esp
  80baef:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80baf2:	8b 7d 10             	mov    0x10(%ebp),%edi
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80baf5:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80baf9:	75 17                	jne    80bb12 <accept_function+0x2c>
  80bafb:	83 ec 04             	sub    $0x4,%esp
  80bafe:	68 78 2c 81 00       	push   $0x812c78
  80bb03:	68 65 01 00 00       	push   $0x165
  80bb08:	68 a2 2c 81 00       	push   $0x812ca2
  80bb0d:	e8 46 28 00 00       	call   80e358 <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80bb12:	83 ec 08             	sub    $0x8,%esp
  80bb15:	ff 73 2c             	pushl  0x2c(%ebx)
  80bb18:	ff 33                	pushl  (%ebx)
  80bb1a:	e8 21 fe ff ff       	call   80b940 <netconn_alloc>
  80bb1f:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80bb21:	83 c4 10             	add    $0x10,%esp
  80bb24:	85 c0                	test   %eax,%eax
  80bb26:	74 53                	je     80bb7b <accept_function+0x95>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80bb28:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bb2b:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80bb2e:	89 f0                	mov    %esi,%eax
  80bb30:	e8 df f7 ff ff       	call   80b314 <setup_tcp>
  newconn->err = err;
  80bb35:	89 f8                	mov    %edi,%eax
  80bb37:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bb3a:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bb3d:	85 c0                	test   %eax,%eax
  80bb3f:	74 0d                	je     80bb4e <accept_function+0x68>
  80bb41:	83 ec 04             	sub    $0x4,%esp
  80bb44:	6a 00                	push   $0x0
  80bb46:	6a 00                	push   $0x0
  80bb48:	53                   	push   %ebx
  80bb49:	ff d0                	call   *%eax
  80bb4b:	83 c4 10             	add    $0x10,%esp

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80bb4e:	83 ec 08             	sub    $0x8,%esp
  80bb51:	56                   	push   %esi
  80bb52:	ff 73 18             	pushl  0x18(%ebx)
  80bb55:	e8 f9 e4 ff ff       	call   80a053 <sys_mbox_trypost>
  80bb5a:	83 c4 10             	add    $0x10,%esp
  80bb5d:	84 c0                	test   %al,%al
  80bb5f:	74 1f                	je     80bb80 <accept_function+0x9a>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80bb61:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80bb68:	83 ec 0c             	sub    $0xc,%esp
  80bb6b:	56                   	push   %esi
  80bb6c:	e8 88 fe ff ff       	call   80b9f9 <netconn_free>
    return ERR_MEM;
  80bb71:	83 c4 10             	add    $0x10,%esp
  80bb74:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bb79:	eb 05                	jmp    80bb80 <accept_function+0x9a>

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  if (newconn == NULL) {
    return ERR_MEM;
  80bb7b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    newconn->pcb.tcp = NULL;
    netconn_free(newconn);
    return ERR_MEM;
  }
  return ERR_OK;
}
  80bb80:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bb83:	5b                   	pop    %ebx
  80bb84:	5e                   	pop    %esi
  80bb85:	5f                   	pop    %edi
  80bb86:	5d                   	pop    %ebp
  80bb87:	c3                   	ret    

0080bb88 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80bb88:	55                   	push   %ebp
  80bb89:	89 e5                	mov    %esp,%ebp
  80bb8b:	53                   	push   %ebx
  80bb8c:	83 ec 04             	sub    $0x4,%esp
  80bb8f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80bb92:	8b 13                	mov    (%ebx),%edx
  80bb94:	8b 4a 08             	mov    0x8(%edx),%ecx
  80bb97:	85 c9                	test   %ecx,%ecx
  80bb99:	74 4f                	je     80bbea <do_delconn+0x62>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bb9b:	8b 02                	mov    (%edx),%eax
  80bb9d:	25 f0 00 00 00       	and    $0xf0,%eax
  80bba2:	83 f8 20             	cmp    $0x20,%eax
  80bba5:	74 1a                	je     80bbc1 <do_delconn+0x39>
  80bba7:	83 f8 40             	cmp    $0x40,%eax
  80bbaa:	74 07                	je     80bbb3 <do_delconn+0x2b>
  80bbac:	83 f8 10             	cmp    $0x10,%eax
  80bbaf:	75 39                	jne    80bbea <do_delconn+0x62>
  80bbb1:	eb 27                	jmp    80bbda <do_delconn+0x52>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80bbb3:	83 ec 0c             	sub    $0xc,%esp
  80bbb6:	51                   	push   %ecx
  80bbb7:	e8 d3 21 00 00       	call   80dd8f <raw_remove>
      break;
  80bbbc:	83 c4 10             	add    $0x10,%esp
  80bbbf:	eb 29                	jmp    80bbea <do_delconn+0x62>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80bbc1:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80bbc8:	83 ec 0c             	sub    $0xc,%esp
  80bbcb:	8b 03                	mov    (%ebx),%eax
  80bbcd:	ff 70 08             	pushl  0x8(%eax)
  80bbd0:	e8 54 d2 ff ff       	call   808e29 <udp_remove>
      break;
  80bbd5:	83 c4 10             	add    $0x10,%esp
  80bbd8:	eb 10                	jmp    80bbea <do_delconn+0x62>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80bbda:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80bbe1:	8b 03                	mov    (%ebx),%eax
  80bbe3:	e8 e0 f9 ff ff       	call   80b5c8 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80bbe8:	eb 42                	jmp    80bc2c <do_delconn+0xa4>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80bbea:	8b 13                	mov    (%ebx),%edx
  80bbec:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bbef:	85 c0                	test   %eax,%eax
  80bbf1:	74 23                	je     80bc16 <do_delconn+0x8e>
  80bbf3:	83 ec 04             	sub    $0x4,%esp
  80bbf6:	6a 00                	push   $0x0
  80bbf8:	6a 00                	push   $0x0
  80bbfa:	52                   	push   %edx
  80bbfb:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80bbfd:	8b 13                	mov    (%ebx),%edx
  80bbff:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bc02:	83 c4 10             	add    $0x10,%esp
  80bc05:	85 c0                	test   %eax,%eax
  80bc07:	74 0d                	je     80bc16 <do_delconn+0x8e>
  80bc09:	83 ec 04             	sub    $0x4,%esp
  80bc0c:	6a 00                	push   $0x0
  80bc0e:	6a 02                	push   $0x2
  80bc10:	52                   	push   %edx
  80bc11:	ff d0                	call   *%eax
  80bc13:	83 c4 10             	add    $0x10,%esp

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80bc16:	8b 03                	mov    (%ebx),%eax
  80bc18:	8b 40 10             	mov    0x10(%eax),%eax
  80bc1b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bc1e:	74 0c                	je     80bc2c <do_delconn+0xa4>
    sys_sem_signal(msg->conn->op_completed);
  80bc20:	83 ec 0c             	sub    $0xc,%esp
  80bc23:	50                   	push   %eax
  80bc24:	e8 ae e2 ff ff       	call   809ed7 <sys_sem_signal>
  80bc29:	83 c4 10             	add    $0x10,%esp
  }
}
  80bc2c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bc2f:	c9                   	leave  
  80bc30:	c3                   	ret    

0080bc31 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80bc31:	55                   	push   %ebp
  80bc32:	89 e5                	mov    %esp,%ebp
  80bc34:	56                   	push   %esi
  80bc35:	53                   	push   %ebx
  80bc36:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bc39:	8b 33                	mov    (%ebx),%esi
  80bc3b:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80bc3f:	7c 69                	jl     80bcaa <do_bind+0x79>
    if (msg->conn->pcb.tcp != NULL) {
  80bc41:	8b 56 08             	mov    0x8(%esi),%edx
  80bc44:	85 d2                	test   %edx,%edx
  80bc46:	74 5e                	je     80bca6 <do_bind+0x75>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bc48:	8b 06                	mov    (%esi),%eax
  80bc4a:	25 f0 00 00 00       	and    $0xf0,%eax
  80bc4f:	83 f8 20             	cmp    $0x20,%eax
  80bc52:	74 20                	je     80bc74 <do_bind+0x43>
  80bc54:	83 f8 40             	cmp    $0x40,%eax
  80bc57:	74 07                	je     80bc60 <do_bind+0x2f>
  80bc59:	83 f8 10             	cmp    $0x10,%eax
  80bc5c:	75 4c                	jne    80bcaa <do_bind+0x79>
  80bc5e:	eb 2d                	jmp    80bc8d <do_bind+0x5c>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bc60:	83 ec 08             	sub    $0x8,%esp
  80bc63:	ff 73 04             	pushl  0x4(%ebx)
  80bc66:	52                   	push   %edx
  80bc67:	e8 a6 1f 00 00       	call   80dc12 <raw_bind>
  80bc6c:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bc6f:	83 c4 10             	add    $0x10,%esp
  80bc72:	eb 36                	jmp    80bcaa <do_bind+0x79>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bc74:	83 ec 04             	sub    $0x4,%esp
  80bc77:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bc7b:	50                   	push   %eax
  80bc7c:	ff 73 04             	pushl  0x4(%ebx)
  80bc7f:	52                   	push   %edx
  80bc80:	e8 62 ce ff ff       	call   808ae7 <udp_bind>
  80bc85:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bc88:	83 c4 10             	add    $0x10,%esp
  80bc8b:	eb 1d                	jmp    80bcaa <do_bind+0x79>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bc8d:	83 ec 04             	sub    $0x4,%esp
  80bc90:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bc94:	50                   	push   %eax
  80bc95:	ff 73 04             	pushl  0x4(%ebx)
  80bc98:	52                   	push   %edx
  80bc99:	e8 18 96 ff ff       	call   8052b6 <tcp_bind>
  80bc9e:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bca1:	83 c4 10             	add    $0x10,%esp
  80bca4:	eb 04                	jmp    80bcaa <do_bind+0x79>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80bca6:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80bcaa:	83 ec 0c             	sub    $0xc,%esp
  80bcad:	8b 03                	mov    (%ebx),%eax
  80bcaf:	ff 70 10             	pushl  0x10(%eax)
  80bcb2:	e8 20 e2 ff ff       	call   809ed7 <sys_sem_signal>
}
  80bcb7:	83 c4 10             	add    $0x10,%esp
  80bcba:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bcbd:	5b                   	pop    %ebx
  80bcbe:	5e                   	pop    %esi
  80bcbf:	5d                   	pop    %ebp
  80bcc0:	c3                   	ret    

0080bcc1 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80bcc1:	55                   	push   %ebp
  80bcc2:	89 e5                	mov    %esp,%ebp
  80bcc4:	56                   	push   %esi
  80bcc5:	53                   	push   %ebx
  80bcc6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80bcc9:	8b 33                	mov    (%ebx),%esi
  80bccb:	8b 56 08             	mov    0x8(%esi),%edx
  80bcce:	85 d2                	test   %edx,%edx
  80bcd0:	75 13                	jne    80bce5 <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80bcd2:	83 ec 0c             	sub    $0xc,%esp
  80bcd5:	ff 76 10             	pushl  0x10(%esi)
  80bcd8:	e8 fa e1 ff ff       	call   809ed7 <sys_sem_signal>
    return;
  80bcdd:	83 c4 10             	add    $0x10,%esp
  80bce0:	e9 8a 00 00 00       	jmp    80bd6f <do_connect+0xae>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bce5:	8b 06                	mov    (%esi),%eax
  80bce7:	25 f0 00 00 00       	and    $0xf0,%eax
  80bcec:	83 f8 20             	cmp    $0x20,%eax
  80bcef:	74 2d                	je     80bd1e <do_connect+0x5d>
  80bcf1:	83 f8 40             	cmp    $0x40,%eax
  80bcf4:	74 07                	je     80bcfd <do_connect+0x3c>
  80bcf6:	83 f8 10             	cmp    $0x10,%eax
  80bcf9:	75 74                	jne    80bd6f <do_connect+0xae>
  80bcfb:	eb 47                	jmp    80bd44 <do_connect+0x83>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bcfd:	83 ec 08             	sub    $0x8,%esp
  80bd00:	ff 73 04             	pushl  0x4(%ebx)
  80bd03:	52                   	push   %edx
  80bd04:	e8 28 1f 00 00       	call   80dc31 <raw_connect>
  80bd09:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80bd0c:	83 c4 04             	add    $0x4,%esp
  80bd0f:	8b 03                	mov    (%ebx),%eax
  80bd11:	ff 70 10             	pushl  0x10(%eax)
  80bd14:	e8 be e1 ff ff       	call   809ed7 <sys_sem_signal>
    break;
  80bd19:	83 c4 10             	add    $0x10,%esp
  80bd1c:	eb 51                	jmp    80bd6f <do_connect+0xae>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bd1e:	83 ec 04             	sub    $0x4,%esp
  80bd21:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bd25:	50                   	push   %eax
  80bd26:	ff 73 04             	pushl  0x4(%ebx)
  80bd29:	52                   	push   %edx
  80bd2a:	e8 5a d0 ff ff       	call   808d89 <udp_connect>
  80bd2f:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80bd32:	83 c4 04             	add    $0x4,%esp
  80bd35:	8b 03                	mov    (%ebx),%eax
  80bd37:	ff 70 10             	pushl  0x10(%eax)
  80bd3a:	e8 98 e1 ff ff       	call   809ed7 <sys_sem_signal>
    break;
  80bd3f:	83 c4 10             	add    $0x10,%esp
  80bd42:	eb 2b                	jmp    80bd6f <do_connect+0xae>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80bd44:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80bd4b:	8b 03                	mov    (%ebx),%eax
  80bd4d:	e8 c2 f5 ff ff       	call   80b314 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80bd52:	8b 33                	mov    (%ebx),%esi
  80bd54:	68 67 b3 80 00       	push   $0x80b367
  80bd59:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bd5d:	50                   	push   %eax
  80bd5e:	ff 73 04             	pushl  0x4(%ebx)
  80bd61:	ff 76 08             	pushl  0x8(%esi)
  80bd64:	e8 d4 a4 ff ff       	call   80623d <tcp_connect>
  80bd69:	88 46 0c             	mov    %al,0xc(%esi)
                                 do_connected);
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
  80bd6c:	83 c4 10             	add    $0x10,%esp
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80bd6f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bd72:	5b                   	pop    %ebx
  80bd73:	5e                   	pop    %esi
  80bd74:	5d                   	pop    %ebp
  80bd75:	c3                   	ret    

0080bd76 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80bd76:	55                   	push   %ebp
  80bd77:	89 e5                	mov    %esp,%ebp
  80bd79:	53                   	push   %ebx
  80bd7a:	83 ec 04             	sub    $0x4,%esp
  80bd7d:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80bd80:	8b 13                	mov    (%ebx),%edx
  80bd82:	8b 02                	mov    (%edx),%eax
  80bd84:	25 f0 00 00 00       	and    $0xf0,%eax
  80bd89:	83 f8 20             	cmp    $0x20,%eax
  80bd8c:	75 0e                	jne    80bd9c <do_disconnect+0x26>
    udp_disconnect(msg->conn->pcb.udp);
  80bd8e:	83 ec 0c             	sub    $0xc,%esp
  80bd91:	ff 72 08             	pushl  0x8(%edx)
  80bd94:	e8 61 d0 ff ff       	call   808dfa <udp_disconnect>
  80bd99:	83 c4 10             	add    $0x10,%esp
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80bd9c:	83 ec 0c             	sub    $0xc,%esp
  80bd9f:	8b 03                	mov    (%ebx),%eax
  80bda1:	ff 70 10             	pushl  0x10(%eax)
  80bda4:	e8 2e e1 ff ff       	call   809ed7 <sys_sem_signal>
}
  80bda9:	83 c4 10             	add    $0x10,%esp
  80bdac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bdaf:	c9                   	leave  
  80bdb0:	c3                   	ret    

0080bdb1 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80bdb1:	55                   	push   %ebp
  80bdb2:	89 e5                	mov    %esp,%ebp
  80bdb4:	57                   	push   %edi
  80bdb5:	56                   	push   %esi
  80bdb6:	53                   	push   %ebx
  80bdb7:	83 ec 0c             	sub    $0xc,%esp
  80bdba:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bdbd:	8b 03                	mov    (%ebx),%eax
  80bdbf:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80bdc3:	0f 8c bc 00 00 00    	jl     80be85 <do_listen+0xd4>
    if (msg->conn->pcb.tcp != NULL) {
  80bdc9:	8b 50 08             	mov    0x8(%eax),%edx
  80bdcc:	85 d2                	test   %edx,%edx
  80bdce:	0f 84 b1 00 00 00    	je     80be85 <do_listen+0xd4>
      if (msg->conn->type == NETCONN_TCP) {
  80bdd4:	83 38 10             	cmpl   $0x10,(%eax)
  80bdd7:	0f 85 a8 00 00 00    	jne    80be85 <do_listen+0xd4>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80bddd:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80bde1:	0f 85 9a 00 00 00    	jne    80be81 <do_listen+0xd0>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80bde7:	83 ec 08             	sub    $0x8,%esp
  80bdea:	68 ff 00 00 00       	push   $0xff
  80bdef:	52                   	push   %edx
  80bdf0:	e8 51 96 ff ff       	call   805446 <tcp_listen_with_backlog>
  80bdf5:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80bdf7:	83 c4 10             	add    $0x10,%esp
  80bdfa:	85 c0                	test   %eax,%eax
  80bdfc:	75 08                	jne    80be06 <do_listen+0x55>
            msg->conn->err = ERR_MEM;
  80bdfe:	8b 03                	mov    (%ebx),%eax
  80be00:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80be04:	eb 7f                	jmp    80be85 <do_listen+0xd4>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80be06:	8b 03                	mov    (%ebx),%eax
  80be08:	8b 40 14             	mov    0x14(%eax),%eax
  80be0b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80be0e:	74 15                	je     80be25 <do_listen+0x74>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80be10:	83 ec 0c             	sub    $0xc,%esp
  80be13:	50                   	push   %eax
  80be14:	e8 1c df ff ff       	call   809d35 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80be19:	8b 03                	mov    (%ebx),%eax
  80be1b:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80be22:	83 c4 10             	add    $0x10,%esp
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80be25:	8b 3b                	mov    (%ebx),%edi
  80be27:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80be2b:	75 1b                	jne    80be48 <do_listen+0x97>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80be2d:	83 ec 0c             	sub    $0xc,%esp
  80be30:	6a 00                	push   $0x0
  80be32:	e8 9d df ff ff       	call   809dd4 <sys_mbox_new>
  80be37:	89 47 18             	mov    %eax,0x18(%edi)
  80be3a:	83 c4 10             	add    $0x10,%esp
  80be3d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80be40:	75 06                	jne    80be48 <do_listen+0x97>
                msg->conn->err = ERR_MEM;
  80be42:	8b 03                	mov    (%ebx),%eax
  80be44:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80be48:	8b 03                	mov    (%ebx),%eax
  80be4a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80be4e:	75 35                	jne    80be85 <do_listen+0xd4>
              msg->conn->state = NETCONN_LISTEN;
  80be50:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80be57:	8b 03                	mov    (%ebx),%eax
  80be59:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80be5c:	8b 03                	mov    (%ebx),%eax
  80be5e:	83 ec 08             	sub    $0x8,%esp
  80be61:	50                   	push   %eax
  80be62:	ff 70 08             	pushl  0x8(%eax)
  80be65:	e8 ba 98 ff ff       	call   805724 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80be6a:	83 c4 08             	add    $0x8,%esp
  80be6d:	68 e6 ba 80 00       	push   $0x80bae6
  80be72:	8b 03                	mov    (%ebx),%eax
  80be74:	ff 70 08             	pushl  0x8(%eax)
  80be77:	e8 e9 98 ff ff       	call   805765 <tcp_accept>
  80be7c:	83 c4 10             	add    $0x10,%esp
  80be7f:	eb 04                	jmp    80be85 <do_listen+0xd4>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80be81:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80be85:	83 ec 0c             	sub    $0xc,%esp
  80be88:	8b 03                	mov    (%ebx),%eax
  80be8a:	ff 70 10             	pushl  0x10(%eax)
  80be8d:	e8 45 e0 ff ff       	call   809ed7 <sys_sem_signal>
}
  80be92:	83 c4 10             	add    $0x10,%esp
  80be95:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80be98:	5b                   	pop    %ebx
  80be99:	5e                   	pop    %esi
  80be9a:	5f                   	pop    %edi
  80be9b:	5d                   	pop    %ebp
  80be9c:	c3                   	ret    

0080be9d <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80be9d:	55                   	push   %ebp
  80be9e:	89 e5                	mov    %esp,%ebp
  80bea0:	57                   	push   %edi
  80bea1:	56                   	push   %esi
  80bea2:	53                   	push   %ebx
  80bea3:	83 ec 0c             	sub    $0xc,%esp
  80bea6:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bea9:	8b 1e                	mov    (%esi),%ebx
  80beab:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80beaf:	7c 7a                	jl     80bf2b <do_send+0x8e>
    if (msg->conn->pcb.tcp != NULL) {
  80beb1:	8b 53 08             	mov    0x8(%ebx),%edx
  80beb4:	85 d2                	test   %edx,%edx
  80beb6:	74 73                	je     80bf2b <do_send+0x8e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80beb8:	8b 03                	mov    (%ebx),%eax
  80beba:	25 f0 00 00 00       	and    $0xf0,%eax
  80bebf:	83 f8 20             	cmp    $0x20,%eax
  80bec2:	74 36                	je     80befa <do_send+0x5d>
  80bec4:	83 f8 40             	cmp    $0x40,%eax
  80bec7:	75 62                	jne    80bf2b <do_send+0x8e>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80bec9:	8b 46 04             	mov    0x4(%esi),%eax
  80becc:	8b 48 08             	mov    0x8(%eax),%ecx
  80becf:	85 c9                	test   %ecx,%ecx
  80bed1:	75 13                	jne    80bee6 <do_send+0x49>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80bed3:	83 ec 08             	sub    $0x8,%esp
  80bed6:	ff 30                	pushl  (%eax)
  80bed8:	52                   	push   %edx
  80bed9:	e8 99 1e 00 00       	call   80dd77 <raw_send>
  80bede:	88 43 0c             	mov    %al,0xc(%ebx)
  80bee1:	83 c4 10             	add    $0x10,%esp
  80bee4:	eb 45                	jmp    80bf2b <do_send+0x8e>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80bee6:	83 ec 04             	sub    $0x4,%esp
  80bee9:	51                   	push   %ecx
  80beea:	ff 30                	pushl  (%eax)
  80beec:	52                   	push   %edx
  80beed:	e8 73 1d 00 00       	call   80dc65 <raw_sendto>
  80bef2:	88 43 0c             	mov    %al,0xc(%ebx)
  80bef5:	83 c4 10             	add    $0x10,%esp
  80bef8:	eb 31                	jmp    80bf2b <do_send+0x8e>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80befa:	8b 46 04             	mov    0x4(%esi),%eax
  80befd:	8b 48 08             	mov    0x8(%eax),%ecx
  80bf00:	85 c9                	test   %ecx,%ecx
  80bf02:	75 13                	jne    80bf17 <do_send+0x7a>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80bf04:	83 ec 08             	sub    $0x8,%esp
  80bf07:	ff 30                	pushl  (%eax)
  80bf09:	52                   	push   %edx
  80bf0a:	e8 5d ce ff ff       	call   808d6c <udp_send>
  80bf0f:	88 43 0c             	mov    %al,0xc(%ebx)
  80bf12:	83 c4 10             	add    $0x10,%esp
  80bf15:	eb 14                	jmp    80bf2b <do_send+0x8e>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80bf17:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80bf1b:	57                   	push   %edi
  80bf1c:	51                   	push   %ecx
  80bf1d:	ff 30                	pushl  (%eax)
  80bf1f:	52                   	push   %edx
  80bf20:	e8 07 ce ff ff       	call   808d2c <udp_sendto>
  80bf25:	88 43 0c             	mov    %al,0xc(%ebx)
  80bf28:	83 c4 10             	add    $0x10,%esp
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80bf2b:	83 ec 0c             	sub    $0xc,%esp
  80bf2e:	8b 06                	mov    (%esi),%eax
  80bf30:	ff 70 10             	pushl  0x10(%eax)
  80bf33:	e8 9f df ff ff       	call   809ed7 <sys_sem_signal>
}
  80bf38:	83 c4 10             	add    $0x10,%esp
  80bf3b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bf3e:	5b                   	pop    %ebx
  80bf3f:	5e                   	pop    %esi
  80bf40:	5f                   	pop    %edi
  80bf41:	5d                   	pop    %ebp
  80bf42:	c3                   	ret    

0080bf43 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80bf43:	55                   	push   %ebp
  80bf44:	89 e5                	mov    %esp,%ebp
  80bf46:	53                   	push   %ebx
  80bf47:	83 ec 04             	sub    $0x4,%esp
  80bf4a:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bf4d:	8b 03                	mov    (%ebx),%eax
  80bf4f:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80bf53:	7c 1d                	jl     80bf72 <do_recv+0x2f>
    if (msg->conn->pcb.tcp != NULL) {
  80bf55:	8b 50 08             	mov    0x8(%eax),%edx
  80bf58:	85 d2                	test   %edx,%edx
  80bf5a:	74 16                	je     80bf72 <do_recv+0x2f>
      if (msg->conn->type == NETCONN_TCP) {
  80bf5c:	83 38 10             	cmpl   $0x10,(%eax)
  80bf5f:	75 11                	jne    80bf72 <do_recv+0x2f>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80bf61:	83 ec 08             	sub    $0x8,%esp
  80bf64:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80bf68:	50                   	push   %eax
  80bf69:	52                   	push   %edx
  80bf6a:	e8 f6 95 ff ff       	call   805565 <tcp_recved>
  80bf6f:	83 c4 10             	add    $0x10,%esp
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80bf72:	83 ec 0c             	sub    $0xc,%esp
  80bf75:	8b 03                	mov    (%ebx),%eax
  80bf77:	ff 70 10             	pushl  0x10(%eax)
  80bf7a:	e8 58 df ff ff       	call   809ed7 <sys_sem_signal>
}
  80bf7f:	83 c4 10             	add    $0x10,%esp
  80bf82:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bf85:	c9                   	leave  
  80bf86:	c3                   	ret    

0080bf87 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80bf87:	55                   	push   %ebp
  80bf88:	89 e5                	mov    %esp,%ebp
  80bf8a:	83 ec 08             	sub    $0x8,%esp
  80bf8d:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bf90:	8b 02                	mov    (%edx),%eax
  80bf92:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80bf96:	7c 2d                	jl     80bfc5 <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80bf98:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bf9c:	74 23                	je     80bfc1 <do_write+0x3a>
  80bf9e:	83 38 10             	cmpl   $0x10,(%eax)
  80bfa1:	75 1e                	jne    80bfc1 <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80bfa3:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80bfaa:	8b 02                	mov    (%edx),%eax
  80bfac:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80bfaf:	8b 02                	mov    (%edx),%eax
  80bfb1:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80bfb8:	8b 02                	mov    (%edx),%eax
  80bfba:	e8 c0 f4 ff ff       	call   80b47f <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80bfbf:	eb 14                	jmp    80bfd5 <do_write+0x4e>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80bfc1:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80bfc5:	83 ec 0c             	sub    $0xc,%esp
  80bfc8:	8b 02                	mov    (%edx),%eax
  80bfca:	ff 70 10             	pushl  0x10(%eax)
  80bfcd:	e8 05 df ff ff       	call   809ed7 <sys_sem_signal>
  80bfd2:	83 c4 10             	add    $0x10,%esp
}
  80bfd5:	c9                   	leave  
  80bfd6:	c3                   	ret    

0080bfd7 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80bfd7:	55                   	push   %ebp
  80bfd8:	89 e5                	mov    %esp,%ebp
  80bfda:	83 ec 08             	sub    $0x8,%esp
  80bfdd:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80bfe0:	8b 08                	mov    (%eax),%ecx
  80bfe2:	8b 51 08             	mov    0x8(%ecx),%edx
  80bfe5:	85 d2                	test   %edx,%edx
  80bfe7:	0f 84 98 00 00 00    	je     80c085 <do_getaddr+0xae>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80bfed:	8b 48 04             	mov    0x4(%eax),%ecx
  80bff0:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80bff4:	74 06                	je     80bffc <do_getaddr+0x25>
  80bff6:	8b 12                	mov    (%edx),%edx
  80bff8:	89 11                	mov    %edx,(%ecx)
  80bffa:	eb 05                	jmp    80c001 <do_getaddr+0x2a>
  80bffc:	8b 52 04             	mov    0x4(%edx),%edx
  80bfff:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c001:	8b 08                	mov    (%eax),%ecx
  80c003:	8b 11                	mov    (%ecx),%edx
  80c005:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c00b:	83 fa 20             	cmp    $0x20,%edx
  80c00e:	74 27                	je     80c037 <do_getaddr+0x60>
  80c010:	83 fa 40             	cmp    $0x40,%edx
  80c013:	74 07                	je     80c01c <do_getaddr+0x45>
  80c015:	83 fa 10             	cmp    $0x10,%edx
  80c018:	75 6f                	jne    80c089 <do_getaddr+0xb2>
  80c01a:	eb 4b                	jmp    80c067 <do_getaddr+0x90>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80c01c:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c020:	74 0f                	je     80c031 <do_getaddr+0x5a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c022:	8b 50 08             	mov    0x8(%eax),%edx
  80c025:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c028:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c02c:	66 89 0a             	mov    %cx,(%edx)
  80c02f:	eb 58                	jmp    80c089 <do_getaddr+0xb2>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80c031:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c035:	eb 52                	jmp    80c089 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80c037:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c03b:	74 0f                	je     80c04c <do_getaddr+0x75>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c03d:	8b 50 08             	mov    0x8(%eax),%edx
  80c040:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c043:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c047:	66 89 0a             	mov    %cx,(%edx)
  80c04a:	eb 3d                	jmp    80c089 <do_getaddr+0xb2>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c04c:	8b 51 08             	mov    0x8(%ecx),%edx
  80c04f:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c053:	75 06                	jne    80c05b <do_getaddr+0x84>
          msg->conn->err = ERR_CONN;
  80c055:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c059:	eb 2e                	jmp    80c089 <do_getaddr+0xb2>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c05b:	8b 48 08             	mov    0x8(%eax),%ecx
  80c05e:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c062:	66 89 11             	mov    %dx,(%ecx)
  80c065:	eb 22                	jmp    80c089 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c067:	8b 50 08             	mov    0x8(%eax),%edx
  80c06a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c06e:	74 09                	je     80c079 <do_getaddr+0xa2>
  80c070:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c073:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80c077:	eb 07                	jmp    80c080 <do_getaddr+0xa9>
  80c079:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c07c:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80c080:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c083:	eb 04                	jmp    80c089 <do_getaddr+0xb2>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80c085:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80c089:	83 ec 0c             	sub    $0xc,%esp
  80c08c:	8b 00                	mov    (%eax),%eax
  80c08e:	ff 70 10             	pushl  0x10(%eax)
  80c091:	e8 41 de ff ff       	call   809ed7 <sys_sem_signal>
}
  80c096:	83 c4 10             	add    $0x10,%esp
  80c099:	c9                   	leave  
  80c09a:	c3                   	ret    

0080c09b <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c09b:	55                   	push   %ebp
  80c09c:	89 e5                	mov    %esp,%ebp
  80c09e:	83 ec 08             	sub    $0x8,%esp
  80c0a1:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c0a4:	8b 02                	mov    (%edx),%eax
  80c0a6:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c0aa:	74 15                	je     80c0c1 <do_close+0x26>
  80c0ac:	83 38 10             	cmpl   $0x10,(%eax)
  80c0af:	75 10                	jne    80c0c1 <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80c0b1:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c0b8:	8b 02                	mov    (%edx),%eax
  80c0ba:	e8 09 f5 ff ff       	call   80b5c8 <do_close_internal>
  80c0bf:	eb 14                	jmp    80c0d5 <do_close+0x3a>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c0c1:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c0c5:	83 ec 0c             	sub    $0xc,%esp
  80c0c8:	8b 02                	mov    (%edx),%eax
  80c0ca:	ff 70 10             	pushl  0x10(%eax)
  80c0cd:	e8 05 de ff ff       	call   809ed7 <sys_sem_signal>
  80c0d2:	83 c4 10             	add    $0x10,%esp
  }
}
  80c0d5:	c9                   	leave  
  80c0d6:	c3                   	ret    

0080c0d7 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c0d7:	55                   	push   %ebp
  80c0d8:	89 e5                	mov    %esp,%ebp
  80c0da:	57                   	push   %edi
  80c0db:	56                   	push   %esi
  80c0dc:	53                   	push   %ebx
  80c0dd:	83 ec 18             	sub    $0x18,%esp
  80c0e0:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c0e2:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c0e8:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c0ec:	50                   	push   %eax
  80c0ed:	e8 f0 b4 ff ff       	call   8075e2 <ntohs>
  80c0f2:	83 c4 10             	add    $0x10,%esp
  80c0f5:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c0f9:	0f 86 83 00 00 00    	jbe    80c182 <tcp_parseopt+0xab>
{
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c0ff:	83 c6 14             	add    $0x14,%esi
  80c102:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c107:	eb 4f                	jmp    80c158 <tcp_parseopt+0x81>

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80c109:	0f b6 d3             	movzbl %bl,%edx
  80c10c:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c110:	84 c0                	test   %al,%al
  80c112:	74 6e                	je     80c182 <tcp_parseopt+0xab>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80c114:	3c 01                	cmp    $0x1,%al
  80c116:	75 05                	jne    80c11d <tcp_parseopt+0x46>
        ++c;
  80c118:	83 c3 01             	add    $0x1,%ebx
  80c11b:	eb 3b                	jmp    80c158 <tcp_parseopt+0x81>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80c11d:	3c 02                	cmp    $0x2,%al
  80c11f:	75 2c                	jne    80c14d <tcp_parseopt+0x76>
  80c121:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c126:	75 25                	jne    80c14d <tcp_parseopt+0x76>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c128:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80c12d:	c1 e0 08             	shl    $0x8,%eax
  80c130:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c135:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c137:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c13a:	66 81 fa b3 05       	cmp    $0x5b3,%dx
  80c13f:	ba b4 05 00 00       	mov    $0x5b4,%edx
  80c144:	0f 47 c2             	cmova  %edx,%eax
  80c147:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80c14b:	eb 35                	jmp    80c182 <tcp_parseopt+0xab>
      } else {
        if (opts[c + 1] == 0) {
  80c14d:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c152:	84 c0                	test   %al,%al
  80c154:	74 2c                	je     80c182 <tcp_parseopt+0xab>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c156:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c158:	83 ec 0c             	sub    $0xc,%esp
  80c15b:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80c160:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c164:	50                   	push   %eax
  80c165:	e8 78 b4 ff ff       	call   8075e2 <ntohs>
  80c16a:	0f b6 d3             	movzbl %bl,%edx
  80c16d:	66 c1 e8 0c          	shr    $0xc,%ax
  80c171:	0f b7 c0             	movzwl %ax,%eax
  80c174:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c17b:	83 c4 10             	add    $0x10,%esp
  80c17e:	39 c2                	cmp    %eax,%edx
  80c180:	7c 87                	jl     80c109 <tcp_parseopt+0x32>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80c182:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c185:	5b                   	pop    %ebx
  80c186:	5e                   	pop    %esi
  80c187:	5f                   	pop    %edi
  80c188:	5d                   	pop    %ebp
  80c189:	c3                   	ret    

0080c18a <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80c18a:	55                   	push   %ebp
  80c18b:	89 e5                	mov    %esp,%ebp
  80c18d:	57                   	push   %edi
  80c18e:	56                   	push   %esi
  80c18f:	53                   	push   %ebx
  80c190:	83 ec 1c             	sub    $0x1c,%esp
  80c193:	89 c7                	mov    %eax,%edi
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80c195:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80c19c:	0f 84 46 04 00 00    	je     80c5e8 <tcp_receive+0x45e>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c1a2:	0f b7 58 5c          	movzwl 0x5c(%eax),%ebx
  80c1a6:	8b 40 60             	mov    0x60(%eax),%eax

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c1a9:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c1af:	39 d0                	cmp    %edx,%eax
  80c1b1:	78 26                	js     80c1d9 <tcp_receive+0x4f>
  80c1b3:	39 d0                	cmp    %edx,%eax
  80c1b5:	75 0b                	jne    80c1c2 <tcp_receive+0x38>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c1b7:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c1bd:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80c1c0:	78 17                	js     80c1d9 <tcp_receive+0x4f>
  80c1c2:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c1c8:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80c1cb:	75 3b                	jne    80c208 <tcp_receive+0x7e>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c1cd:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
  80c1d3:	66 3b 59 0e          	cmp    0xe(%ecx),%bx
  80c1d7:	73 2f                	jae    80c208 <tcp_receive+0x7e>
      pcb->snd_wnd = tcphdr->wnd;
  80c1d9:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
  80c1df:	0f b7 49 0e          	movzwl 0xe(%ecx),%ecx
  80c1e3:	66 89 4f 5c          	mov    %cx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c1e7:	89 57 60             	mov    %edx,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c1ea:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80c1f0:	89 57 64             	mov    %edx,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c1f3:	66 85 c9             	test   %cx,%cx
  80c1f6:	74 10                	je     80c208 <tcp_receive+0x7e>
  80c1f8:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c1ff:	74 07                	je     80c208 <tcp_receive+0x7e>
          pcb->persist_backoff = 0;
  80c201:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80c208:	8b 4f 48             	mov    0x48(%edi),%ecx
  80c20b:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80c211:	39 d1                	cmp    %edx,%ecx
  80c213:	0f 85 ad 00 00 00    	jne    80c2c6 <tcp_receive+0x13c>
      pcb->acked = 0;
  80c219:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c21f:	0f b7 db             	movzwl %bx,%ebx
  80c222:	01 d8                	add    %ebx,%eax
  80c224:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80c228:	03 57 60             	add    0x60(%edi),%edx
  80c22b:	39 d0                	cmp    %edx,%eax
  80c22d:	0f 85 e2 02 00 00    	jne    80c515 <tcp_receive+0x38b>
        ++pcb->dupacks;
  80c233:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c237:	83 c0 01             	add    $0x1,%eax
  80c23a:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c23d:	3c 02                	cmp    $0x2,%al
  80c23f:	0f 86 d0 02 00 00    	jbe    80c515 <tcp_receive+0x38b>
  80c245:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c249:	0f 84 c6 02 00 00    	je     80c515 <tcp_receive+0x38b>
          if (!(pcb->flags & TF_INFR)) {
  80c24f:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c253:	75 55                	jne    80c2aa <tcp_receive+0x120>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80c255:	83 ec 0c             	sub    $0xc,%esp
  80c258:	57                   	push   %edi
  80c259:	e8 90 c2 ff ff       	call   8084ee <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80c25e:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  80c262:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80c266:	83 c4 10             	add    $0x10,%esp
  80c269:	66 39 d0             	cmp    %dx,%ax
  80c26c:	76 09                	jbe    80c277 <tcp_receive+0xed>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c26e:	66 d1 ea             	shr    %dx
  80c271:	66 89 57 50          	mov    %dx,0x50(%edi)
  80c275:	eb 07                	jmp    80c27e <tcp_receive+0xf4>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80c277:	66 d1 e8             	shr    %ax
  80c27a:	66 89 47 50          	mov    %ax,0x50(%edi)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80c27e:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c282:	0f b7 4f 50          	movzwl 0x50(%edi),%ecx
  80c286:	0f b7 d0             	movzwl %ax,%edx
  80c289:	01 d2                	add    %edx,%edx
  80c28b:	39 d1                	cmp    %edx,%ecx
  80c28d:	7d 07                	jge    80c296 <tcp_receive+0x10c>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80c28f:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c292:	66 89 57 50          	mov    %dx,0x50(%edi)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c296:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c299:	66 03 47 50          	add    0x50(%edi),%ax
  80c29d:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c2a1:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c2a5:	e9 6b 02 00 00       	jmp    80c515 <tcp_receive+0x38b>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c2aa:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c2ae:	89 d0                	mov    %edx,%eax
  80c2b0:	66 03 47 34          	add    0x34(%edi),%ax
  80c2b4:	66 39 c2             	cmp    %ax,%dx
  80c2b7:	0f 83 58 02 00 00    	jae    80c515 <tcp_receive+0x38b>
              pcb->cwnd += pcb->mss;
  80c2bd:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c2c1:	e9 4f 02 00 00       	jmp    80c515 <tcp_receive+0x38b>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c2c6:	8d 42 ff             	lea    -0x1(%edx),%eax
  80c2c9:	39 c8                	cmp    %ecx,%eax
  80c2cb:	0f 88 9d 01 00 00    	js     80c46e <tcp_receive+0x2e4>
  80c2d1:	89 d0                	mov    %edx,%eax
  80c2d3:	2b 47 58             	sub    0x58(%edi),%eax
  80c2d6:	85 c0                	test   %eax,%eax
  80c2d8:	0f 8f 90 01 00 00    	jg     80c46e <tcp_receive+0x2e4>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80c2de:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80c2e2:	a8 04                	test   $0x4,%al
  80c2e4:	74 0e                	je     80c2f4 <tcp_receive+0x16a>
        pcb->flags &= ~TF_INFR;
  80c2e6:	83 e0 fb             	and    $0xfffffffb,%eax
  80c2e9:	88 47 20             	mov    %al,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c2ec:	0f b7 47 50          	movzwl 0x50(%edi),%eax
  80c2f0:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80c2f4:	c6 47 46 00          	movb   $0x0,0x46(%edi)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c2f8:	0f b7 47 40          	movzwl 0x40(%edi),%eax
  80c2fc:	66 c1 f8 03          	sar    $0x3,%ax
  80c300:	66 03 47 42          	add    0x42(%edi),%ax
  80c304:	66 89 47 44          	mov    %ax,0x44(%edi)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c308:	89 d0                	mov    %edx,%eax
  80c30a:	29 c8                	sub    %ecx,%eax
  80c30c:	66 89 47 6c          	mov    %ax,0x6c(%edi)

      pcb->snd_buf += pcb->acked;
  80c310:	66 01 47 6e          	add    %ax,0x6e(%edi)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80c314:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c318:	89 57 48             	mov    %edx,0x48(%edi)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80c31b:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c31f:	0f 86 c3 00 00 00    	jbe    80c3e8 <tcp_receive+0x25e>
        if (pcb->cwnd < pcb->ssthresh) {
  80c325:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c329:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c32d:	73 18                	jae    80c347 <tcp_receive+0x1bd>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c32f:	89 c8                	mov    %ecx,%eax
  80c331:	66 03 47 34          	add    0x34(%edi),%ax
  80c335:	66 39 c1             	cmp    %ax,%cx
  80c338:	0f 83 aa 00 00 00    	jae    80c3e8 <tcp_receive+0x25e>
            pcb->cwnd += pcb->mss;
  80c33e:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c342:	e9 a1 00 00 00       	jmp    80c3e8 <tcp_receive+0x25e>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c347:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c34b:	0f af c0             	imul   %eax,%eax
  80c34e:	0f b7 d9             	movzwl %cx,%ebx
  80c351:	99                   	cltd   
  80c352:	f7 fb                	idiv   %ebx
  80c354:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c356:	66 39 c1             	cmp    %ax,%cx
  80c359:	0f 83 89 00 00 00    	jae    80c3e8 <tcp_receive+0x25e>
            pcb->cwnd = new_cwnd;
  80c35f:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c363:	e9 80 00 00 00       	jmp    80c3e8 <tcp_receive+0x25e>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80c368:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c36b:	8b 03                	mov    (%ebx),%eax
  80c36d:	89 47 78             	mov    %eax,0x78(%edi)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c370:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c374:	83 ec 0c             	sub    $0xc,%esp
  80c377:	ff 73 04             	pushl  0x4(%ebx)
  80c37a:	e8 04 88 ff ff       	call   804b83 <pbuf_clen>
  80c37f:	0f b6 c0             	movzbl %al,%eax
  80c382:	83 c4 10             	add    $0x10,%esp
  80c385:	66 39 c6             	cmp    %ax,%si
  80c388:	73 17                	jae    80c3a1 <tcp_receive+0x217>
  80c38a:	83 ec 04             	sub    $0x4,%esp
  80c38d:	68 84 2d 81 00       	push   $0x812d84
  80c392:	68 55 03 00 00       	push   $0x355
  80c397:	68 f0 2e 81 00       	push   $0x812ef0
  80c39c:	e8 b7 1f 00 00       	call   80e358 <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c3a1:	83 ec 0c             	sub    $0xc,%esp
  80c3a4:	ff 73 04             	pushl  0x4(%ebx)
  80c3a7:	e8 d7 87 ff ff       	call   804b83 <pbuf_clen>
  80c3ac:	0f b6 c0             	movzbl %al,%eax
  80c3af:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c3b3:	89 1c 24             	mov    %ebx,(%esp)
  80c3b6:	e8 af 92 ff ff       	call   80566a <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80c3bb:	83 c4 10             	add    $0x10,%esp
  80c3be:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c3c3:	74 23                	je     80c3e8 <tcp_receive+0x25e>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c3c5:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c3c9:	75 1d                	jne    80c3e8 <tcp_receive+0x25e>
  80c3cb:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c3cf:	75 17                	jne    80c3e8 <tcp_receive+0x25e>
  80c3d1:	83 ec 04             	sub    $0x4,%esp
  80c3d4:	68 ac 2d 81 00       	push   $0x812dac
  80c3d9:	68 5c 03 00 00       	push   $0x35c
  80c3de:	68 f0 2e 81 00       	push   $0x812ef0
  80c3e3:	e8 70 1f 00 00       	call   80e358 <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80c3e8:	8b 47 78             	mov    0x78(%edi),%eax
  80c3eb:	85 c0                	test   %eax,%eax
  80c3ed:	74 68                	je     80c457 <tcp_receive+0x2cd>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c3ef:	83 ec 0c             	sub    $0xc,%esp
  80c3f2:	8b 40 10             	mov    0x10(%eax),%eax
  80c3f5:	ff 70 04             	pushl  0x4(%eax)
  80c3f8:	e8 13 b4 ff ff       	call   807810 <ntohl>
  80c3fd:	89 c6                	mov    %eax,%esi
  80c3ff:	8b 47 78             	mov    0x78(%edi),%eax
  80c402:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80c406:	8b 40 10             	mov    0x10(%eax),%eax
  80c409:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c40d:	89 04 24             	mov    %eax,(%esp)
  80c410:	e8 cd b1 ff ff       	call   8075e2 <ntohs>
  80c415:	83 c4 10             	add    $0x10,%esp
  80c418:	ba 01 00 00 00       	mov    $0x1,%edx
  80c41d:	a8 01                	test   $0x1,%al
  80c41f:	75 1e                	jne    80c43f <tcp_receive+0x2b5>
  80c421:	83 ec 0c             	sub    $0xc,%esp
  80c424:	8b 47 78             	mov    0x78(%edi),%eax
  80c427:	8b 40 10             	mov    0x10(%eax),%eax
  80c42a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c42e:	50                   	push   %eax
  80c42f:	e8 ae b1 ff ff       	call   8075e2 <ntohs>
  80c434:	66 d1 e8             	shr    %ax
  80c437:	89 c2                	mov    %eax,%edx
  80c439:	83 e2 01             	and    $0x1,%edx
  80c43c:	83 c4 10             	add    $0x10,%esp
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80c43f:	2b 35 a4 b1 b3 00    	sub    0xb3b1a4,%esi
  80c445:	01 d3                	add    %edx,%ebx
  80c447:	01 f3                	add    %esi,%ebx
  80c449:	85 db                	test   %ebx,%ebx
  80c44b:	0f 8e 17 ff ff ff    	jle    80c368 <tcp_receive+0x1de>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80c451:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c455:	75 08                	jne    80c45f <tcp_receive+0x2d5>
        pcb->rtime = -1;
  80c457:	66 c7 47 32 ff ff    	movw   $0xffff,0x32(%edi)
  80c45d:	eb 06                	jmp    80c465 <tcp_receive+0x2db>
      else
        pcb->rtime = 0;
  80c45f:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

      pcb->polltmr = 0;
  80c465:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80c469:	e9 a7 00 00 00       	jmp    80c515 <tcp_receive+0x38b>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80c46e:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c474:	e9 9c 00 00 00       	jmp    80c515 <tcp_receive+0x38b>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80c479:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80c47c:	8b 03                	mov    (%ebx),%eax
  80c47e:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c481:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c485:	83 ec 0c             	sub    $0xc,%esp
  80c488:	ff 73 04             	pushl  0x4(%ebx)
  80c48b:	e8 f3 86 ff ff       	call   804b83 <pbuf_clen>
  80c490:	0f b6 c0             	movzbl %al,%eax
  80c493:	83 c4 10             	add    $0x10,%esp
  80c496:	66 39 c6             	cmp    %ax,%si
  80c499:	73 17                	jae    80c4b2 <tcp_receive+0x328>
  80c49b:	83 ec 04             	sub    $0x4,%esp
  80c49e:	68 84 2d 81 00       	push   $0x812d84
  80c4a3:	68 7f 03 00 00       	push   $0x37f
  80c4a8:	68 f0 2e 81 00       	push   $0x812ef0
  80c4ad:	e8 a6 1e 00 00       	call   80e358 <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80c4b2:	83 ec 0c             	sub    $0xc,%esp
  80c4b5:	ff 73 04             	pushl  0x4(%ebx)
  80c4b8:	e8 c6 86 ff ff       	call   804b83 <pbuf_clen>
  80c4bd:	0f b6 c0             	movzbl %al,%eax
  80c4c0:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80c4c4:	89 1c 24             	mov    %ebx,(%esp)
  80c4c7:	e8 9e 91 ff ff       	call   80566a <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80c4cc:	83 c4 10             	add    $0x10,%esp
  80c4cf:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c4d4:	74 24                	je     80c4fa <tcp_receive+0x370>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c4d6:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c4da:	75 1e                	jne    80c4fa <tcp_receive+0x370>
  80c4dc:	8b 47 74             	mov    0x74(%edi),%eax
  80c4df:	85 c0                	test   %eax,%eax
  80c4e1:	75 1e                	jne    80c501 <tcp_receive+0x377>
  80c4e3:	83 ec 04             	sub    $0x4,%esp
  80c4e6:	68 ac 2d 81 00       	push   $0x812dac
  80c4eb:	68 85 03 00 00       	push   $0x385
  80c4f0:	68 f0 2e 81 00       	push   $0x812ef0
  80c4f5:	e8 5e 1e 00 00       	call   80e358 <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80c4fa:	8b 47 74             	mov    0x74(%edi),%eax
  80c4fd:	85 c0                	test   %eax,%eax
  80c4ff:	74 14                	je     80c515 <tcp_receive+0x38b>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80c501:	83 ec 0c             	sub    $0xc,%esp
  80c504:	8b 40 10             	mov    0x10(%eax),%eax
  80c507:	ff 70 04             	pushl  0x4(%eax)
  80c50a:	e8 e0 b0 ff ff       	call   8075ef <htonl>
  80c50f:	89 47 54             	mov    %eax,0x54(%edi)
  80c512:	83 c4 10             	add    $0x10,%esp
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80c515:	8b 47 74             	mov    0x74(%edi),%eax
  80c518:	85 c0                	test   %eax,%eax
  80c51a:	74 70                	je     80c58c <tcp_receive+0x402>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c51c:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c522:	83 ec 0c             	sub    $0xc,%esp
  80c525:	8b 40 10             	mov    0x10(%eax),%eax
  80c528:	ff 70 04             	pushl  0x4(%eax)
  80c52b:	e8 e0 b2 ff ff       	call   807810 <ntohl>
  80c530:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c533:	8b 47 74             	mov    0x74(%edi),%eax
  80c536:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80c53a:	8b 40 10             	mov    0x10(%eax),%eax
  80c53d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c541:	89 04 24             	mov    %eax,(%esp)
  80c544:	e8 99 b0 ff ff       	call   8075e2 <ntohs>
  80c549:	83 c4 10             	add    $0x10,%esp
  80c54c:	ba 01 00 00 00       	mov    $0x1,%edx
  80c551:	a8 01                	test   $0x1,%al
  80c553:	75 1e                	jne    80c573 <tcp_receive+0x3e9>
  80c555:	83 ec 0c             	sub    $0xc,%esp
  80c558:	8b 47 74             	mov    0x74(%edi),%eax
  80c55b:	8b 40 10             	mov    0x10(%eax),%eax
  80c55e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c562:	50                   	push   %eax
  80c563:	e8 7a b0 ff ff       	call   8075e2 <ntohs>
  80c568:	66 d1 e8             	shr    %ax
  80c56b:	89 c2                	mov    %eax,%edx
  80c56d:	83 e2 01             	and    $0x1,%edx
  80c570:	83 c4 10             	add    $0x10,%esp
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80c573:	2b 75 e4             	sub    -0x1c(%ebp),%esi
  80c576:	01 d3                	add    %edx,%ebx
  80c578:	39 de                	cmp    %ebx,%esi
  80c57a:	78 10                	js     80c58c <tcp_receive+0x402>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c57c:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c581:	2b 47 58             	sub    0x58(%edi),%eax
  80c584:	85 c0                	test   %eax,%eax
  80c586:	0f 8e ed fe ff ff    	jle    80c479 <tcp_receive+0x2ef>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80c58c:	8b 47 38             	mov    0x38(%edi),%eax
  80c58f:	85 c0                	test   %eax,%eax
  80c591:	74 55                	je     80c5e8 <tcp_receive+0x45e>
  80c593:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c599:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80c59c:	79 4a                	jns    80c5e8 <tcp_receive+0x45e>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80c59e:	0f b7 5f 40          	movzwl 0x40(%edi),%ebx
  80c5a2:	0f b7 15 40 b2 b3 00 	movzwl 0xb3b240,%edx
  80c5a9:	29 c2                	sub    %eax,%edx
  80c5ab:	89 d8                	mov    %ebx,%eax
  80c5ad:	66 c1 f8 03          	sar    $0x3,%ax
  80c5b1:	89 d1                	mov    %edx,%ecx
  80c5b3:	29 c1                	sub    %eax,%ecx
      pcb->sa += m;
  80c5b5:	01 cb                	add    %ecx,%ebx
  80c5b7:	66 89 5f 40          	mov    %bx,0x40(%edi)
      if (m < 0) {
        m = -m;
  80c5bb:	89 ca                	mov    %ecx,%edx
  80c5bd:	f7 da                	neg    %edx
  80c5bf:	66 85 c9             	test   %cx,%cx
  80c5c2:	0f 49 d1             	cmovns %ecx,%edx
      }
      m = m - (pcb->sv >> 2);
  80c5c5:	0f b7 47 42          	movzwl 0x42(%edi),%eax
      pcb->sv += m;
  80c5c9:	89 c1                	mov    %eax,%ecx
  80c5cb:	66 c1 f9 02          	sar    $0x2,%cx
  80c5cf:	29 c8                	sub    %ecx,%eax
  80c5d1:	01 d0                	add    %edx,%eax
  80c5d3:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c5d7:	66 c1 fb 03          	sar    $0x3,%bx
  80c5db:	01 d8                	add    %ebx,%eax
  80c5dd:	66 89 47 44          	mov    %ax,0x44(%edi)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80c5e1:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80c5e8:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80c5ef:	66 85 c0             	test   %ax,%ax
  80c5f2:	0f 84 8e 07 00 00    	je     80cd86 <tcp_receive+0xbfc>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80c5f8:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c5fb:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c601:	89 d9                	mov    %ebx,%ecx
  80c603:	29 d1                	sub    %edx,%ecx
  80c605:	89 ce                	mov    %ecx,%esi
  80c607:	83 ee 01             	sub    $0x1,%esi
  80c60a:	0f 88 27 01 00 00    	js     80c737 <tcp_receive+0x5ad>
  80c610:	8d 73 01             	lea    0x1(%ebx),%esi
  80c613:	29 d6                	sub    %edx,%esi
  80c615:	0f b7 c0             	movzwl %ax,%eax
  80c618:	29 c6                	sub    %eax,%esi
  80c61a:	85 f6                	test   %esi,%esi
  80c61c:	0f 8f 15 01 00 00    	jg     80c737 <tcp_receive+0x5ad>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80c622:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80c624:	8b 1d b8 b1 b3 00    	mov    0xb3b1b8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c62a:	85 db                	test   %ebx,%ebx
  80c62c:	75 17                	jne    80c645 <tcp_receive+0x4bb>
  80c62e:	83 ec 04             	sub    $0x4,%esp
  80c631:	68 07 2f 81 00       	push   $0x812f07
  80c636:	68 e5 03 00 00       	push   $0x3e5
  80c63b:	68 f0 2e 81 00       	push   $0x812ef0
  80c640:	e8 13 1d 00 00       	call   80e358 <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c645:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80c64b:	7e 17                	jle    80c664 <tcp_receive+0x4da>
  80c64d:	83 ec 04             	sub    $0x4,%esp
  80c650:	68 17 2f 81 00       	push   $0x812f17
  80c655:	68 e6 03 00 00       	push   $0x3e6
  80c65a:	68 f0 2e 81 00       	push   $0x812ef0
  80c65f:	e8 f4 1c 00 00       	call   80e358 <_panic>
      if (inseg.p->len < off) {
  80c664:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c668:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80c66b:	39 d1                	cmp    %edx,%ecx
  80c66d:	7e 6a                	jle    80c6d9 <tcp_receive+0x54f>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c66f:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80c673:	0f b7 d6             	movzwl %si,%edx
  80c676:	39 d1                	cmp    %edx,%ecx
  80c678:	7e 17                	jle    80c691 <tcp_receive+0x507>
  80c67a:	83 ec 04             	sub    $0x4,%esp
  80c67d:	68 26 2f 81 00       	push   $0x812f26
  80c682:	68 e8 03 00 00       	push   $0x3e8
  80c687:	68 f0 2e 81 00       	push   $0x812ef0
  80c68c:	e8 c7 1c 00 00       	call   80e358 <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80c691:	29 ce                	sub    %ecx,%esi
  80c693:	89 f1                	mov    %esi,%ecx
  80c695:	8b 55 e4             	mov    -0x1c(%ebp),%edx
        while (p->len < off) {
          off -= p->len;
  80c698:	29 d0                	sub    %edx,%eax
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  80c69a:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80c69e:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80c6a4:	8b 1b                	mov    (%ebx),%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  80c6a6:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c6aa:	39 c2                	cmp    %eax,%edx
  80c6ac:	7c ea                	jl     80c698 <tcp_receive+0x50e>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  80c6ae:	83 ec 08             	sub    $0x8,%esp
  80c6b1:	f7 d8                	neg    %eax
  80c6b3:	98                   	cwtl   
  80c6b4:	50                   	push   %eax
  80c6b5:	53                   	push   %ebx
  80c6b6:	e8 97 7f ff ff       	call   804652 <pbuf_header>
  80c6bb:	83 c4 10             	add    $0x10,%esp
  80c6be:	84 c0                	test   %al,%al
  80c6c0:	74 44                	je     80c706 <tcp_receive+0x57c>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80c6c2:	83 ec 04             	sub    $0x4,%esp
  80c6c5:	68 36 2f 81 00       	push   $0x812f36
  80c6ca:	68 f5 03 00 00       	push   $0x3f5
  80c6cf:	68 f0 2e 81 00       	push   $0x812ef0
  80c6d4:	e8 7f 1c 00 00       	call   80e358 <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80c6d9:	83 ec 08             	sub    $0x8,%esp
  80c6dc:	f7 d9                	neg    %ecx
  80c6de:	0f bf c1             	movswl %cx,%eax
  80c6e1:	50                   	push   %eax
  80c6e2:	53                   	push   %ebx
  80c6e3:	e8 6a 7f ff ff       	call   804652 <pbuf_header>
  80c6e8:	83 c4 10             	add    $0x10,%esp
  80c6eb:	84 c0                	test   %al,%al
  80c6ed:	74 17                	je     80c706 <tcp_receive+0x57c>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80c6ef:	83 ec 04             	sub    $0x4,%esp
  80c6f2:	68 36 2f 81 00       	push   $0x812f36
  80c6f7:	68 fa 03 00 00       	push   $0x3fa
  80c6fc:	68 f0 2e 81 00       	push   $0x812ef0
  80c701:	e8 52 1c 00 00       	call   80e358 <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  80c706:	8b 43 04             	mov    0x4(%ebx),%eax
  80c709:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80c70e:	8b 57 24             	mov    0x24(%edi),%edx
  80c711:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80c718:	66 03 05 a8 b1 b3 00 	add    0xb3b1a8,%ax
  80c71f:	29 d0                	sub    %edx,%eax
  80c721:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80c727:	89 15 a8 b1 b3 00    	mov    %edx,0xb3b1a8
  80c72d:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c732:	89 50 04             	mov    %edx,0x4(%eax)
  80c735:	eb 14                	jmp    80c74b <tcp_receive+0x5c1>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80c737:	39 da                	cmp    %ebx,%edx
  80c739:	79 21                	jns    80c75c <tcp_receive+0x5d2>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  80c73b:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c73f:	83 ec 0c             	sub    $0xc,%esp
  80c742:	57                   	push   %edi
  80c743:	e8 b1 b7 ff ff       	call   807ef9 <tcp_output>
  80c748:	83 c4 10             	add    $0x10,%esp
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c74b:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c751:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c754:	39 da                	cmp    %ebx,%edx
  80c756:	0f 88 13 06 00 00    	js     80cd6f <tcp_receive+0xbe5>
  80c75c:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c760:	89 d1                	mov    %edx,%ecx
  80c762:	29 c1                	sub    %eax,%ecx
  80c764:	8d 41 01             	lea    0x1(%ecx),%eax
  80c767:	29 d8                	sub    %ebx,%eax
  80c769:	85 c0                	test   %eax,%eax
  80c76b:	0f 8f fe 05 00 00    	jg     80cd6f <tcp_receive+0xbe5>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  80c771:	39 da                	cmp    %ebx,%edx
  80c773:	0f 85 77 03 00 00    	jne    80caf0 <tcp_receive+0x966>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80c779:	8b 4f 7c             	mov    0x7c(%edi),%ecx
  80c77c:	85 c9                	test   %ecx,%ecx
  80c77e:	0f 84 85 00 00 00    	je     80c809 <tcp_receive+0x67f>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80c784:	8b 41 10             	mov    0x10(%ecx),%eax
  80c787:	8b 58 04             	mov    0x4(%eax),%ebx
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80c78a:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80c791:	89 de                	mov    %ebx,%esi
  80c793:	29 c6                	sub    %eax,%esi
  80c795:	89 f0                	mov    %esi,%eax
  80c797:	29 d0                	sub    %edx,%eax
  80c799:	85 c0                	test   %eax,%eax
  80c79b:	7f 6c                	jg     80c809 <tcp_receive+0x67f>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  80c79d:	66 83 79 0c 00       	cmpw   $0x0,0xc(%ecx)
  80c7a2:	74 20                	je     80c7c4 <tcp_receive+0x63a>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80c7a4:	29 d3                	sub    %edx,%ebx
  80c7a6:	66 89 1d c0 b1 b3 00 	mov    %bx,0xb3b1c0
            pbuf_realloc(inseg.p, inseg.len);
  80c7ad:	83 ec 08             	sub    $0x8,%esp
  80c7b0:	0f b7 db             	movzwl %bx,%ebx
  80c7b3:	53                   	push   %ebx
  80c7b4:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80c7ba:	e8 ae 82 ff ff       	call   804a6d <pbuf_realloc>
  80c7bf:	83 c4 10             	add    $0x10,%esp
  80c7c2:	eb 45                	jmp    80c809 <tcp_receive+0x67f>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80c7c4:	83 ec 0c             	sub    $0xc,%esp
  80c7c7:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c7cc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c7d0:	50                   	push   %eax
  80c7d1:	e8 0c ae ff ff       	call   8075e2 <ntohs>
  80c7d6:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80c7d8:	8b 47 7c             	mov    0x7c(%edi),%eax
  80c7db:	8b 40 10             	mov    0x10(%eax),%eax
  80c7de:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c7e2:	89 04 24             	mov    %eax,(%esp)
  80c7e5:	e8 f8 ad ff ff       	call   8075e2 <ntohs>
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80c7ea:	31 d8                	xor    %ebx,%eax
  80c7ec:	83 c4 10             	add    $0x10,%esp
  80c7ef:	a8 03                	test   $0x3,%al
  80c7f1:	75 16                	jne    80c809 <tcp_receive+0x67f>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80c7f3:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80c7f6:	8b 10                	mov    (%eax),%edx
  80c7f8:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80c7fb:	83 ec 08             	sub    $0x8,%esp
  80c7fe:	50                   	push   %eax
  80c7ff:	6a 04                	push   $0x4
  80c801:	e8 ab 7b ff ff       	call   8043b1 <memp_free>
  80c806:	83 c4 10             	add    $0x10,%esp
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  80c809:	0f b7 1d c0 b1 b3 00 	movzwl 0xb3b1c0,%ebx
  80c810:	83 ec 0c             	sub    $0xc,%esp
  80c813:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c818:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c81c:	50                   	push   %eax
  80c81d:	e8 c0 ad ff ff       	call   8075e2 <ntohs>
  80c822:	83 c4 10             	add    $0x10,%esp
  80c825:	ba 01 00 00 00       	mov    $0x1,%edx
  80c82a:	a8 01                	test   $0x1,%al
  80c82c:	75 1d                	jne    80c84b <tcp_receive+0x6c1>
  80c82e:	83 ec 0c             	sub    $0xc,%esp
  80c831:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c836:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c83a:	50                   	push   %eax
  80c83b:	e8 a2 ad ff ff       	call   8075e2 <ntohs>
  80c840:	66 d1 e8             	shr    %ax
  80c843:	89 c2                	mov    %eax,%edx
  80c845:	83 e2 01             	and    $0x1,%edx
  80c848:	83 c4 10             	add    $0x10,%esp
  80c84b:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80c84e:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  80c854:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80c858:	74 06                	je     80c860 <tcp_receive+0x6d6>
          pcb->rcv_nxt += tcplen;
  80c85a:	0f b7 d0             	movzwl %ax,%edx
  80c85d:	01 57 24             	add    %edx,0x24(%edi)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  80c860:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80c864:	66 39 d0             	cmp    %dx,%ax
  80c867:	76 08                	jbe    80c871 <tcp_receive+0x6e7>
          pcb->rcv_wnd = 0;
  80c869:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80c86f:	eb 06                	jmp    80c877 <tcp_receive+0x6ed>
        } else {
          pcb->rcv_wnd -= tcplen;
  80c871:	29 c2                	sub    %eax,%edx
  80c873:	66 89 57 28          	mov    %dx,0x28(%edi)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  80c877:	0f b7 57 2a          	movzwl 0x2a(%edi),%edx
  80c87b:	66 39 d0             	cmp    %dx,%ax
  80c87e:	76 08                	jbe    80c888 <tcp_receive+0x6fe>
          pcb->rcv_ann_wnd = 0;
  80c880:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80c886:	eb 06                	jmp    80c88e <tcp_receive+0x704>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  80c888:	29 c2                	sub    %eax,%edx
  80c88a:	66 89 57 2a          	mov    %dx,0x2a(%edi)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  80c88e:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80c893:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80c898:	74 0f                	je     80c8a9 <tcp_receive+0x71f>
          recv_data = inseg.p;
  80c89a:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  80c89f:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80c8a6:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80c8a9:	83 ec 0c             	sub    $0xc,%esp
  80c8ac:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c8b1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c8b5:	50                   	push   %eax
  80c8b6:	e8 27 ad ff ff       	call   8075e2 <ntohs>
  80c8bb:	83 c4 10             	add    $0x10,%esp
  80c8be:	a8 01                	test   $0x1,%al
  80c8c0:	0f 84 dd 01 00 00    	je     80caa3 <tcp_receive+0x919>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  80c8c6:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
  80c8cd:	e9 d1 01 00 00       	jmp    80caa3 <tcp_receive+0x919>
           is now in sequence. */
        while (pcb->ooseq != NULL &&
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  80c8d2:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80c8d7:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80c8db:	83 ec 0c             	sub    $0xc,%esp
  80c8de:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80c8e2:	50                   	push   %eax
  80c8e3:	e8 fa ac ff ff       	call   8075e2 <ntohs>
  80c8e8:	83 c4 10             	add    $0x10,%esp
  80c8eb:	ba 01 00 00 00       	mov    $0x1,%edx
  80c8f0:	a8 01                	test   $0x1,%al
  80c8f2:	75 1b                	jne    80c90f <tcp_receive+0x785>
  80c8f4:	83 ec 0c             	sub    $0xc,%esp
  80c8f7:	8b 43 10             	mov    0x10(%ebx),%eax
  80c8fa:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c8fe:	50                   	push   %eax
  80c8ff:	e8 de ac ff ff       	call   8075e2 <ntohs>
  80c904:	66 d1 e8             	shr    %ax
  80c907:	89 c2                	mov    %eax,%edx
  80c909:	83 e2 01             	and    $0x1,%edx
  80c90c:	83 c4 10             	add    $0x10,%esp
  80c90f:	01 d6                	add    %edx,%esi
  80c911:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80c914:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c918:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c91b:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80c91f:	83 ec 0c             	sub    $0xc,%esp
  80c922:	8b 43 10             	mov    0x10(%ebx),%eax
  80c925:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c929:	50                   	push   %eax
  80c92a:	e8 b3 ac ff ff       	call   8075e2 <ntohs>
  80c92f:	83 c4 10             	add    $0x10,%esp
  80c932:	ba 01 00 00 00       	mov    $0x1,%edx
  80c937:	a8 01                	test   $0x1,%al
  80c939:	75 1b                	jne    80c956 <tcp_receive+0x7cc>
  80c93b:	83 ec 0c             	sub    $0xc,%esp
  80c93e:	8b 43 10             	mov    0x10(%ebx),%eax
  80c941:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c945:	50                   	push   %eax
  80c946:	e8 97 ac ff ff       	call   8075e2 <ntohs>
  80c94b:	66 d1 e8             	shr    %ax
  80c94e:	89 c2                	mov    %eax,%edx
  80c950:	83 e2 01             	and    $0x1,%edx
  80c953:	83 c4 10             	add    $0x10,%esp
  80c956:	01 d6                	add    %edx,%esi
  80c958:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80c95b:	7d 08                	jge    80c965 <tcp_receive+0x7db>
            pcb->rcv_wnd = 0;
  80c95d:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80c963:	eb 41                	jmp    80c9a6 <tcp_receive+0x81c>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80c965:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80c969:	83 ec 0c             	sub    $0xc,%esp
  80c96c:	8b 43 10             	mov    0x10(%ebx),%eax
  80c96f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c973:	50                   	push   %eax
  80c974:	e8 69 ac ff ff       	call   8075e2 <ntohs>
  80c979:	83 c4 10             	add    $0x10,%esp
  80c97c:	ba 01 00 00 00       	mov    $0x1,%edx
  80c981:	a8 01                	test   $0x1,%al
  80c983:	75 1b                	jne    80c9a0 <tcp_receive+0x816>
  80c985:	83 ec 0c             	sub    $0xc,%esp
  80c988:	8b 43 10             	mov    0x10(%ebx),%eax
  80c98b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c98f:	50                   	push   %eax
  80c990:	e8 4d ac ff ff       	call   8075e2 <ntohs>
  80c995:	66 d1 e8             	shr    %ax
  80c998:	89 c2                	mov    %eax,%edx
  80c99a:	83 e2 01             	and    $0x1,%edx
  80c99d:	83 c4 10             	add    $0x10,%esp
  80c9a0:	01 d6                	add    %edx,%esi
  80c9a2:	66 29 77 28          	sub    %si,0x28(%edi)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80c9a6:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80c9aa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c9ad:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80c9b1:	83 ec 0c             	sub    $0xc,%esp
  80c9b4:	8b 43 10             	mov    0x10(%ebx),%eax
  80c9b7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9bb:	50                   	push   %eax
  80c9bc:	e8 21 ac ff ff       	call   8075e2 <ntohs>
  80c9c1:	83 c4 10             	add    $0x10,%esp
  80c9c4:	ba 01 00 00 00       	mov    $0x1,%edx
  80c9c9:	a8 01                	test   $0x1,%al
  80c9cb:	75 1b                	jne    80c9e8 <tcp_receive+0x85e>
  80c9cd:	83 ec 0c             	sub    $0xc,%esp
  80c9d0:	8b 43 10             	mov    0x10(%ebx),%eax
  80c9d3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9d7:	50                   	push   %eax
  80c9d8:	e8 05 ac ff ff       	call   8075e2 <ntohs>
  80c9dd:	66 d1 e8             	shr    %ax
  80c9e0:	89 c2                	mov    %eax,%edx
  80c9e2:	83 e2 01             	and    $0x1,%edx
  80c9e5:	83 c4 10             	add    $0x10,%esp
  80c9e8:	01 d6                	add    %edx,%esi
  80c9ea:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80c9ed:	7d 08                	jge    80c9f7 <tcp_receive+0x86d>
            pcb->rcv_ann_wnd = 0;
  80c9ef:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80c9f5:	eb 41                	jmp    80ca38 <tcp_receive+0x8ae>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80c9f7:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80c9fb:	83 ec 0c             	sub    $0xc,%esp
  80c9fe:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca01:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca05:	50                   	push   %eax
  80ca06:	e8 d7 ab ff ff       	call   8075e2 <ntohs>
  80ca0b:	83 c4 10             	add    $0x10,%esp
  80ca0e:	ba 01 00 00 00       	mov    $0x1,%edx
  80ca13:	a8 01                	test   $0x1,%al
  80ca15:	75 1b                	jne    80ca32 <tcp_receive+0x8a8>
  80ca17:	83 ec 0c             	sub    $0xc,%esp
  80ca1a:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca1d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca21:	50                   	push   %eax
  80ca22:	e8 bb ab ff ff       	call   8075e2 <ntohs>
  80ca27:	66 d1 e8             	shr    %ax
  80ca2a:	89 c2                	mov    %eax,%edx
  80ca2c:	83 e2 01             	and    $0x1,%edx
  80ca2f:	83 c4 10             	add    $0x10,%esp
  80ca32:	01 d6                	add    %edx,%esi
  80ca34:	66 29 77 2a          	sub    %si,0x2a(%edi)
          }

          if (cseg->p->tot_len > 0) {
  80ca38:	8b 43 04             	mov    0x4(%ebx),%eax
  80ca3b:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80ca40:	74 25                	je     80ca67 <tcp_receive+0x8dd>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  80ca42:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80ca48:	85 d2                	test   %edx,%edx
  80ca4a:	74 0f                	je     80ca5b <tcp_receive+0x8d1>
              pbuf_cat(recv_data, cseg->p);
  80ca4c:	83 ec 08             	sub    $0x8,%esp
  80ca4f:	50                   	push   %eax
  80ca50:	52                   	push   %edx
  80ca51:	e8 56 81 ff ff       	call   804bac <pbuf_cat>
  80ca56:	83 c4 10             	add    $0x10,%esp
  80ca59:	eb 05                	jmp    80ca60 <tcp_receive+0x8d6>
            } else {
              recv_data = cseg->p;
  80ca5b:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
            }
            cseg->p = NULL;
  80ca60:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80ca67:	83 ec 0c             	sub    $0xc,%esp
  80ca6a:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca6d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca71:	50                   	push   %eax
  80ca72:	e8 6b ab ff ff       	call   8075e2 <ntohs>
  80ca77:	83 c4 10             	add    $0x10,%esp
  80ca7a:	a8 01                	test   $0x1,%al
  80ca7c:	74 14                	je     80ca92 <tcp_receive+0x908>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  80ca7e:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80ca85:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80ca89:	75 07                	jne    80ca92 <tcp_receive+0x908>
              pcb->state = CLOSE_WAIT;
  80ca8b:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
            } 
          }


          pcb->ooseq = cseg->next;
  80ca92:	8b 03                	mov    (%ebx),%eax
  80ca94:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80ca97:	83 ec 0c             	sub    $0xc,%esp
  80ca9a:	53                   	push   %ebx
  80ca9b:	e8 ca 8b ff ff       	call   80566a <tcp_seg_free>
  80caa0:	83 c4 10             	add    $0x10,%esp
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80caa3:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80caa6:	85 db                	test   %ebx,%ebx
  80caa8:	74 0f                	je     80cab9 <tcp_receive+0x92f>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80caaa:	8b 53 10             	mov    0x10(%ebx),%edx
  80caad:	8b 42 04             	mov    0x4(%edx),%eax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80cab0:	3b 47 24             	cmp    0x24(%edi),%eax
  80cab3:	0f 84 19 fe ff ff    	je     80c8d2 <tcp_receive+0x748>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80cab9:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80cabd:	a8 01                	test   $0x1,%al
  80cabf:	74 1f                	je     80cae0 <tcp_receive+0x956>
  80cac1:	83 e0 fe             	and    $0xfffffffe,%eax
  80cac4:	83 c8 02             	or     $0x2,%eax
  80cac7:	88 47 20             	mov    %al,0x20(%edi)
  80caca:	83 ec 0c             	sub    $0xc,%esp
  80cacd:	57                   	push   %edi
  80cace:	e8 26 b4 ff ff       	call   807ef9 <tcp_output>
  80cad3:	83 c4 10             	add    $0x10,%esp
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80cad6:	b8 01 00 00 00       	mov    $0x1,%eax
  80cadb:	e9 07 03 00 00       	jmp    80cde7 <tcp_receive+0xc5d>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80cae0:	83 c8 01             	or     $0x1,%eax
  80cae3:	88 47 20             	mov    %al,0x20(%edi)
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80cae6:	b8 01 00 00 00       	mov    $0x1,%eax
  80caeb:	e9 f7 02 00 00       	jmp    80cde7 <tcp_receive+0xc5d>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  80caf0:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80caf4:	83 ec 0c             	sub    $0xc,%esp
  80caf7:	57                   	push   %edi
  80caf8:	e8 fc b3 ff ff       	call   807ef9 <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  80cafd:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cb00:	83 c4 10             	add    $0x10,%esp
  80cb03:	85 db                	test   %ebx,%ebx
  80cb05:	75 1d                	jne    80cb24 <tcp_receive+0x99a>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80cb07:	83 ec 0c             	sub    $0xc,%esp
  80cb0a:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cb0f:	e8 d6 8b ff ff       	call   8056ea <tcp_seg_copy>
  80cb14:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cb17:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cb1a:	b8 00 00 00 00       	mov    $0x0,%eax
  80cb1f:	e9 c3 02 00 00       	jmp    80cde7 <tcp_receive+0xc5d>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80cb24:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80cb2a:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80cb2d:	8d 51 01             	lea    0x1(%ecx),%edx
  80cb30:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80cb33:	be 00 00 00 00       	mov    $0x0,%esi
  80cb38:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80cb3b:	89 c7                	mov    %eax,%edi
  80cb3d:	eb 02                	jmp    80cb41 <tcp_receive+0x9b7>
  80cb3f:	89 d3                	mov    %edx,%ebx
  80cb41:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb44:	8b 40 04             	mov    0x4(%eax),%eax
  80cb47:	39 c8                	cmp    %ecx,%eax
  80cb49:	0f 85 a6 00 00 00    	jne    80cbf5 <tcp_receive+0xa6b>
  80cb4f:	8b 7d e0             	mov    -0x20(%ebp),%edi
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cb52:	b8 00 00 00 00       	mov    $0x0,%eax
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  80cb57:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80cb5b:	66 39 0d c0 b1 b3 00 	cmp    %cx,0xb3b1c0
  80cb62:	0f 86 7f 02 00 00    	jbe    80cde7 <tcp_receive+0xc5d>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  80cb68:	83 ec 0c             	sub    $0xc,%esp
  80cb6b:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cb70:	e8 75 8b ff ff       	call   8056ea <tcp_seg_copy>
  80cb75:	89 c1                	mov    %eax,%ecx
  80cb77:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  80cb7a:	83 c4 10             	add    $0x10,%esp
  80cb7d:	85 c0                	test   %eax,%eax
  80cb7f:	0f 84 33 02 00 00    	je     80cdb8 <tcp_receive+0xc2e>
                  cseg->next = next->next;
  80cb85:	8b 03                	mov    (%ebx),%eax
  80cb87:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80cb89:	85 f6                	test   %esi,%esi
  80cb8b:	74 04                	je     80cb91 <tcp_receive+0xa07>
                    prev->next = cseg;
  80cb8d:	89 0e                	mov    %ecx,(%esi)
  80cb8f:	eb 06                	jmp    80cb97 <tcp_receive+0xa0d>
                  } else {
                    pcb->ooseq = cseg;
  80cb91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80cb94:	89 47 7c             	mov    %eax,0x7c(%edi)
                  }
                  tcp_seg_free(next);
  80cb97:	83 ec 0c             	sub    $0xc,%esp
  80cb9a:	53                   	push   %ebx
  80cb9b:	e8 ca 8a ff ff       	call   80566a <tcp_seg_free>
                  if (cseg->next != NULL) {
  80cba0:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80cba3:	8b 06                	mov    (%esi),%eax
  80cba5:	83 c4 10             	add    $0x10,%esp
  80cba8:	85 c0                	test   %eax,%eax
  80cbaa:	0f 84 0f 02 00 00    	je     80cdbf <tcp_receive+0xc35>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80cbb0:	8b 1d a8 b1 b3 00    	mov    0xb3b1a8,%ebx
  80cbb6:	8b 40 10             	mov    0x10(%eax),%eax
  80cbb9:	8b 50 04             	mov    0x4(%eax),%edx
  80cbbc:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80cbc0:	29 d1                	sub    %edx,%ecx
  80cbc2:	01 d9                	add    %ebx,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cbc4:	b8 00 00 00 00       	mov    $0x0,%eax
                    pcb->ooseq = cseg;
                  }
                  tcp_seg_free(next);
                  if (cseg->next != NULL) {
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80cbc9:	85 c9                	test   %ecx,%ecx
  80cbcb:	0f 8e 16 02 00 00    	jle    80cde7 <tcp_receive+0xc5d>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80cbd1:	89 d0                	mov    %edx,%eax
  80cbd3:	29 d8                	sub    %ebx,%eax
  80cbd5:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80cbd9:	83 ec 08             	sub    $0x8,%esp
  80cbdc:	0f b7 c0             	movzwl %ax,%eax
  80cbdf:	50                   	push   %eax
  80cbe0:	ff 76 04             	pushl  0x4(%esi)
  80cbe3:	e8 85 7e ff ff       	call   804a6d <pbuf_realloc>
  80cbe8:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cbeb:	b8 00 00 00 00       	mov    $0x0,%eax
  80cbf0:	e9 f2 01 00 00       	jmp    80cde7 <tcp_receive+0xc5d>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  80cbf5:	85 f6                	test   %esi,%esi
  80cbf7:	75 5e                	jne    80cc57 <tcp_receive+0xacd>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80cbf9:	39 c1                	cmp    %eax,%ecx
  80cbfb:	0f 89 fc 00 00 00    	jns    80ccfd <tcp_receive+0xb73>
  80cc01:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cc04:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80cc0b:	01 ca                	add    %ecx,%edx
  80cc0d:	29 c2                	sub    %eax,%edx
  80cc0f:	85 d2                	test   %edx,%edx
  80cc11:	7e 1d                	jle    80cc30 <tcp_receive+0xaa6>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cc13:	29 c8                	sub    %ecx,%eax
  80cc15:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                    pbuf_realloc(inseg.p, inseg.len);
  80cc1b:	83 ec 08             	sub    $0x8,%esp
  80cc1e:	0f b7 c0             	movzwl %ax,%eax
  80cc21:	50                   	push   %eax
  80cc22:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cc28:	e8 40 7e ff ff       	call   804a6d <pbuf_realloc>
  80cc2d:	83 c4 10             	add    $0x10,%esp
                  }
                  cseg = tcp_seg_copy(&inseg);
  80cc30:	83 ec 0c             	sub    $0xc,%esp
  80cc33:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cc38:	e8 ad 8a ff ff       	call   8056ea <tcp_seg_copy>
                  if (cseg != NULL) {
  80cc3d:	83 c4 10             	add    $0x10,%esp
  80cc40:	85 c0                	test   %eax,%eax
  80cc42:	0f 84 7e 01 00 00    	je     80cdc6 <tcp_receive+0xc3c>
                    cseg->next = next;
  80cc48:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80cc4a:	89 47 7c             	mov    %eax,0x7c(%edi)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cc4d:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc52:	e9 90 01 00 00       	jmp    80cde7 <tcp_receive+0xc5d>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80cc57:	8b 56 10             	mov    0x10(%esi),%edx
  80cc5a:	3b 7a 04             	cmp    0x4(%edx),%edi
  80cc5d:	0f 88 9a 00 00 00    	js     80ccfd <tcp_receive+0xb73>
  80cc63:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80cc66:	29 c2                	sub    %eax,%edx
  80cc68:	85 d2                	test   %edx,%edx
  80cc6a:	0f 8f 8d 00 00 00    	jg     80ccfd <tcp_receive+0xb73>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cc70:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80cc77:	01 ca                	add    %ecx,%edx
  80cc79:	29 c2                	sub    %eax,%edx
  80cc7b:	85 d2                	test   %edx,%edx
  80cc7d:	7e 1d                	jle    80cc9c <tcp_receive+0xb12>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cc7f:	29 c8                	sub    %ecx,%eax
  80cc81:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                  pbuf_realloc(inseg.p, inseg.len);
  80cc87:	83 ec 08             	sub    $0x8,%esp
  80cc8a:	0f b7 c0             	movzwl %ax,%eax
  80cc8d:	50                   	push   %eax
  80cc8e:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cc94:	e8 d4 7d ff ff       	call   804a6d <pbuf_realloc>
  80cc99:	83 c4 10             	add    $0x10,%esp
                }

                cseg = tcp_seg_copy(&inseg);
  80cc9c:	83 ec 0c             	sub    $0xc,%esp
  80cc9f:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cca4:	e8 41 8a ff ff       	call   8056ea <tcp_seg_copy>
                if (cseg != NULL) {
  80cca9:	83 c4 10             	add    $0x10,%esp
  80ccac:	85 c0                	test   %eax,%eax
  80ccae:	0f 84 19 01 00 00    	je     80cdcd <tcp_receive+0xc43>
                  cseg->next = next;
  80ccb4:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80ccb6:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80ccb8:	8b 46 10             	mov    0x10(%esi),%eax
  80ccbb:	8b 58 04             	mov    0x4(%eax),%ebx
  80ccbe:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80ccc4:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  80ccc8:	29 d1                	sub    %edx,%ecx
  80ccca:	01 d9                	add    %ebx,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cccc:	b8 00 00 00 00       	mov    $0x0,%eax

                cseg = tcp_seg_copy(&inseg);
                if (cseg != NULL) {
                  cseg->next = next;
                  prev->next = cseg;
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80ccd1:	85 c9                	test   %ecx,%ecx
  80ccd3:	0f 8e 0e 01 00 00    	jle    80cde7 <tcp_receive+0xc5d>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80ccd9:	89 d0                	mov    %edx,%eax
  80ccdb:	29 d8                	sub    %ebx,%eax
  80ccdd:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80cce1:	83 ec 08             	sub    $0x8,%esp
  80cce4:	0f b7 c0             	movzwl %ax,%eax
  80cce7:	50                   	push   %eax
  80cce8:	ff 76 04             	pushl  0x4(%esi)
  80cceb:	e8 7d 7d ff ff       	call   804a6d <pbuf_realloc>
  80ccf0:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80ccf3:	b8 00 00 00 00       	mov    $0x0,%eax
  80ccf8:	e9 ea 00 00 00       	jmp    80cde7 <tcp_receive+0xc5d>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80ccfd:	8b 13                	mov    (%ebx),%edx
  80ccff:	89 de                	mov    %ebx,%esi
  80cd01:	85 d2                	test   %edx,%edx
  80cd03:	0f 85 36 fe ff ff    	jne    80cb3f <tcp_receive+0x9b5>
  80cd09:	29 c1                	sub    %eax,%ecx
  80cd0b:	85 c9                	test   %ecx,%ecx
  80cd0d:	0f 8e c1 00 00 00    	jle    80cdd4 <tcp_receive+0xc4a>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  80cd13:	83 ec 0c             	sub    $0xc,%esp
  80cd16:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cd1b:	e8 ca 89 ff ff       	call   8056ea <tcp_seg_copy>
  80cd20:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80cd22:	83 c4 10             	add    $0x10,%esp
  80cd25:	85 c0                	test   %eax,%eax
  80cd27:	0f 84 ae 00 00 00    	je     80cddb <tcp_receive+0xc51>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80cd2d:	8b 43 10             	mov    0x10(%ebx),%eax
  80cd30:	8b 70 04             	mov    0x4(%eax),%esi
  80cd33:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80cd39:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80cd3d:	29 d1                	sub    %edx,%ecx
  80cd3f:	01 f1                	add    %esi,%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cd41:	b8 00 00 00 00       	mov    $0x0,%eax
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
                if (next->next != NULL) {
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80cd46:	85 c9                	test   %ecx,%ecx
  80cd48:	0f 8e 99 00 00 00    	jle    80cde7 <tcp_receive+0xc5d>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80cd4e:	89 d0                	mov    %edx,%eax
  80cd50:	29 f0                	sub    %esi,%eax
  80cd52:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80cd56:	83 ec 08             	sub    $0x8,%esp
  80cd59:	0f b7 c0             	movzwl %ax,%eax
  80cd5c:	50                   	push   %eax
  80cd5d:	ff 73 04             	pushl  0x4(%ebx)
  80cd60:	e8 08 7d ff ff       	call   804a6d <pbuf_realloc>
  80cd65:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cd68:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd6d:	eb 78                	jmp    80cde7 <tcp_receive+0xc5d>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  80cd6f:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cd73:	83 ec 0c             	sub    $0xc,%esp
  80cd76:	57                   	push   %edi
  80cd77:	e8 7d b1 ff ff       	call   807ef9 <tcp_output>
  80cd7c:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cd7f:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd84:	eb 61                	jmp    80cde7 <tcp_receive+0xc5d>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80cd86:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80cd8b:	8b 57 24             	mov    0x24(%edi),%edx
  80cd8e:	39 d0                	cmp    %edx,%eax
  80cd90:	78 0f                	js     80cda1 <tcp_receive+0xc17>
  80cd92:	83 c0 01             	add    $0x1,%eax
  80cd95:	29 d0                	sub    %edx,%eax
  80cd97:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80cd9b:	29 d0                	sub    %edx,%eax
  80cd9d:	85 c0                	test   %eax,%eax
  80cd9f:	7e 41                	jle    80cde2 <tcp_receive+0xc58>
      tcp_ack_now(pcb);
  80cda1:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cda5:	83 ec 0c             	sub    $0xc,%esp
  80cda8:	57                   	push   %edi
  80cda9:	e8 4b b1 ff ff       	call   807ef9 <tcp_output>
  80cdae:	83 c4 10             	add    $0x10,%esp
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80cdb1:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdb6:	eb 2f                	jmp    80cde7 <tcp_receive+0xc5d>
  80cdb8:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdbd:	eb 28                	jmp    80cde7 <tcp_receive+0xc5d>
  80cdbf:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdc4:	eb 21                	jmp    80cde7 <tcp_receive+0xc5d>
  80cdc6:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdcb:	eb 1a                	jmp    80cde7 <tcp_receive+0xc5d>
  80cdcd:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdd2:	eb 13                	jmp    80cde7 <tcp_receive+0xc5d>
  80cdd4:	b8 00 00 00 00       	mov    $0x0,%eax
  80cdd9:	eb 0c                	jmp    80cde7 <tcp_receive+0xc5d>
  80cddb:	b8 00 00 00 00       	mov    $0x0,%eax
  80cde0:	eb 05                	jmp    80cde7 <tcp_receive+0xc5d>
  80cde2:	b8 00 00 00 00       	mov    $0x0,%eax
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
  return accepted_inseq;
}
  80cde7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80cdea:	5b                   	pop    %ebx
  80cdeb:	5e                   	pop    %esi
  80cdec:	5f                   	pop    %edi
  80cded:	5d                   	pop    %ebp
  80cdee:	c3                   	ret    

0080cdef <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  80cdef:	55                   	push   %ebp
  80cdf0:	89 e5                	mov    %esp,%ebp
  80cdf2:	57                   	push   %edi
  80cdf3:	56                   	push   %esi
  80cdf4:	53                   	push   %ebx
  80cdf5:	83 ec 38             	sub    $0x38,%esp
  80cdf8:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  80cdfb:	8b 5e 04             	mov    0x4(%esi),%ebx
  80cdfe:	89 1d ac b1 b3 00    	mov    %ebx,0xb3b1ac
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80ce04:	0f b7 03             	movzwl (%ebx),%eax
  80ce07:	50                   	push   %eax
  80ce08:	e8 d5 a7 ff ff       	call   8075e2 <ntohs>
  80ce0d:	66 c1 e8 08          	shr    $0x8,%ax
  80ce11:	83 e0 0f             	and    $0xf,%eax
  80ce14:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80ce17:	a3 b0 b1 b3 00       	mov    %eax,0xb3b1b0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80ce1c:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80ce21:	0f b7 00             	movzwl (%eax),%eax
  80ce24:	89 04 24             	mov    %eax,(%esp)
  80ce27:	e8 b6 a7 ff ff       	call   8075e2 <ntohs>
  80ce2c:	83 c4 08             	add    $0x8,%esp
  80ce2f:	66 c1 e8 06          	shr    $0x6,%ax
  80ce33:	83 e0 3c             	and    $0x3c,%eax
  80ce36:	f7 d8                	neg    %eax
  80ce38:	98                   	cwtl   
  80ce39:	50                   	push   %eax
  80ce3a:	56                   	push   %esi
  80ce3b:	e8 12 78 ff ff       	call   804652 <pbuf_header>
  80ce40:	83 c4 10             	add    $0x10,%esp
  80ce43:	84 c0                	test   %al,%al
  80ce45:	75 07                	jne    80ce4e <tcp_input+0x5f>
  80ce47:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80ce4c:	77 11                	ja     80ce5f <tcp_input+0x70>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80ce4e:	83 ec 0c             	sub    $0xc,%esp
  80ce51:	56                   	push   %esi
  80ce52:	e8 cd 78 ff ff       	call   804724 <pbuf_free>
    return;
  80ce57:	83 c4 10             	add    $0x10,%esp
  80ce5a:	e9 fb 0c 00 00       	jmp    80db5a <tcp_input+0xd6b>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80ce5f:	83 ec 08             	sub    $0x8,%esp
  80ce62:	ff 75 0c             	pushl  0xc(%ebp)
  80ce65:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80ce6a:	83 c0 10             	add    $0x10,%eax
  80ce6d:	50                   	push   %eax
  80ce6e:	e8 5a 95 ff ff       	call   8063cd <ip_addr_isbroadcast>
  80ce73:	83 c4 10             	add    $0x10,%esp
  80ce76:	84 c0                	test   %al,%al
  80ce78:	75 2a                	jne    80cea4 <tcp_input+0xb5>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80ce7a:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80ce7f:	8b 58 10             	mov    0x10(%eax),%ebx
  80ce82:	83 ec 0c             	sub    $0xc,%esp
  80ce85:	68 00 00 00 f0       	push   $0xf0000000
  80ce8a:	e8 81 a9 ff ff       	call   807810 <ntohl>
  80ce8f:	21 c3                	and    %eax,%ebx
  80ce91:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80ce98:	e8 73 a9 ff ff       	call   807810 <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80ce9d:	83 c4 10             	add    $0x10,%esp
  80cea0:	39 c3                	cmp    %eax,%ebx
  80cea2:	75 11                	jne    80ceb5 <tcp_input+0xc6>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cea4:	83 ec 0c             	sub    $0xc,%esp
  80cea7:	56                   	push   %esi
  80cea8:	e8 77 78 ff ff       	call   804724 <pbuf_free>
    return;
  80cead:	83 c4 10             	add    $0x10,%esp
  80ceb0:	e9 a5 0c 00 00       	jmp    80db5a <tcp_input+0xd6b>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  80ceb5:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80ceba:	83 ec 0c             	sub    $0xc,%esp
  80cebd:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80cec1:	52                   	push   %edx
  80cec2:	6a 06                	push   $0x6
  80cec4:	8d 50 10             	lea    0x10(%eax),%edx
  80cec7:	52                   	push   %edx
  80cec8:	83 c0 0c             	add    $0xc,%eax
  80cecb:	50                   	push   %eax
  80cecc:	56                   	push   %esi
  80cecd:	e8 ea a3 ff ff       	call   8072bc <inet_chksum_pseudo>
  80ced2:	83 c4 20             	add    $0x20,%esp
  80ced5:	66 85 c0             	test   %ax,%ax
  80ced8:	74 11                	je     80ceeb <tcp_input+0xfc>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80ceda:	83 ec 0c             	sub    $0xc,%esp
  80cedd:	56                   	push   %esi
  80cede:	e8 41 78 ff ff       	call   804724 <pbuf_free>
    return;
  80cee3:	83 c4 10             	add    $0x10,%esp
  80cee6:	e9 6f 0c 00 00       	jmp    80db5a <tcp_input+0xd6b>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  80ceeb:	83 ec 0c             	sub    $0xc,%esp
  80ceee:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80cef3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cef7:	50                   	push   %eax
  80cef8:	e8 e5 a6 ff ff       	call   8075e2 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80cefd:	83 c4 08             	add    $0x8,%esp
  80cf00:	66 c1 e8 0c          	shr    $0xc,%ax
  80cf04:	f7 d8                	neg    %eax
  80cf06:	c1 e0 02             	shl    $0x2,%eax
  80cf09:	98                   	cwtl   
  80cf0a:	50                   	push   %eax
  80cf0b:	56                   	push   %esi
  80cf0c:	e8 41 77 ff ff       	call   804652 <pbuf_header>
  80cf11:	83 c4 10             	add    $0x10,%esp
  80cf14:	84 c0                	test   %al,%al
  80cf16:	74 11                	je     80cf29 <tcp_input+0x13a>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80cf18:	83 ec 0c             	sub    $0xc,%esp
  80cf1b:	56                   	push   %esi
  80cf1c:	e8 03 78 ff ff       	call   804724 <pbuf_free>
    return;
  80cf21:	83 c4 10             	add    $0x10,%esp
  80cf24:	e9 31 0c 00 00       	jmp    80db5a <tcp_input+0xd6b>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  80cf29:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80cf2f:	83 ec 0c             	sub    $0xc,%esp
  80cf32:	0f b7 03             	movzwl (%ebx),%eax
  80cf35:	50                   	push   %eax
  80cf36:	e8 a7 a6 ff ff       	call   8075e2 <ntohs>
  80cf3b:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80cf3e:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80cf44:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80cf48:	89 04 24             	mov    %eax,(%esp)
  80cf4b:	e8 92 a6 ff ff       	call   8075e2 <ntohs>
  80cf50:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80cf54:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80cf5a:	83 c4 04             	add    $0x4,%esp
  80cf5d:	ff 73 04             	pushl  0x4(%ebx)
  80cf60:	e8 ab a8 ff ff       	call   807810 <ntohl>
  80cf65:	89 43 04             	mov    %eax,0x4(%ebx)
  80cf68:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80cf6d:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80cf73:	83 c4 04             	add    $0x4,%esp
  80cf76:	ff 73 08             	pushl  0x8(%ebx)
  80cf79:	e8 92 a8 ff ff       	call   807810 <ntohl>
  80cf7e:	89 43 08             	mov    %eax,0x8(%ebx)
  80cf81:	a3 a4 b1 b3 00       	mov    %eax,0xb3b1a4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80cf86:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80cf8c:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80cf90:	89 04 24             	mov    %eax,(%esp)
  80cf93:	e8 4a a6 ff ff       	call   8075e2 <ntohs>
  80cf98:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80cf9c:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80cfa1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cfa5:	89 04 24             	mov    %eax,(%esp)
  80cfa8:	e8 35 a6 ff ff       	call   8075e2 <ntohs>
  80cfad:	89 c1                	mov    %eax,%ecx
  80cfaf:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80cfb3:	83 e0 3f             	and    $0x3f,%eax
  80cfb6:	a2 a0 b1 b3 00       	mov    %al,0xb3b1a0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80cfbb:	83 c4 10             	add    $0x10,%esp
  80cfbe:	89 c8                	mov    %ecx,%eax
  80cfc0:	a8 03                	test   $0x3,%al
  80cfc2:	0f 95 c0             	setne  %al
  80cfc5:	0f b6 c0             	movzbl %al,%eax
  80cfc8:	66 03 46 08          	add    0x8(%esi),%ax
  80cfcc:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80cfd0:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80cfd6:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80cfdb:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  80cfde:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80cfe4:	8b 0d ac b1 b3 00    	mov    0xb3b1ac,%ecx
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80cfea:	89 c3                	mov    %eax,%ebx
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  80cfec:	bf 00 00 00 00       	mov    $0x0,%edi

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80cff1:	e9 d1 00 00 00       	jmp    80d0c7 <tcp_input+0x2d8>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80cff6:	8b 43 10             	mov    0x10(%ebx),%eax
  80cff9:	85 c0                	test   %eax,%eax
  80cffb:	75 17                	jne    80d014 <tcp_input+0x225>
  80cffd:	83 ec 04             	sub    $0x4,%esp
  80d000:	68 cc 2d 81 00       	push   $0x812dcc
  80d005:	68 b5 00 00 00       	push   $0xb5
  80d00a:	68 f0 2e 81 00       	push   $0x812ef0
  80d00f:	e8 44 13 00 00       	call   80e358 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d014:	83 f8 0a             	cmp    $0xa,%eax
  80d017:	75 17                	jne    80d030 <tcp_input+0x241>
  80d019:	83 ec 04             	sub    $0x4,%esp
  80d01c:	68 f4 2d 81 00       	push   $0x812df4
  80d021:	68 b6 00 00 00       	push   $0xb6
  80d026:	68 f0 2e 81 00       	push   $0x812ef0
  80d02b:	e8 28 13 00 00       	call   80e358 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d030:	83 f8 01             	cmp    $0x1,%eax
  80d033:	75 17                	jne    80d04c <tcp_input+0x25d>
  80d035:	83 ec 04             	sub    $0x4,%esp
  80d038:	68 20 2e 81 00       	push   $0x812e20
  80d03d:	68 b7 00 00 00       	push   $0xb7
  80d042:	68 f0 2e 81 00       	push   $0x812ef0
  80d047:	e8 0c 13 00 00       	call   80e358 <_panic>
    if (pcb->remote_port == tcphdr->src &&
  80d04c:	0f b7 02             	movzwl (%edx),%eax
  80d04f:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d053:	75 6d                	jne    80d0c2 <tcp_input+0x2d3>
  80d055:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d059:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d05d:	75 63                	jne    80d0c2 <tcp_input+0x2d3>
       pcb->local_port == tcphdr->dest &&
  80d05f:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d062:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d065:	75 5b                	jne    80d0c2 <tcp_input+0x2d3>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d067:	8b 41 10             	mov    0x10(%ecx),%eax
  80d06a:	39 03                	cmp    %eax,(%ebx)
  80d06c:	75 54                	jne    80d0c2 <tcp_input+0x2d3>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d06e:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d071:	39 c3                	cmp    %eax,%ebx
  80d073:	75 17                	jne    80d08c <tcp_input+0x29d>
  80d075:	83 ec 04             	sub    $0x4,%esp
  80d078:	68 48 2e 81 00       	push   $0x812e48
  80d07d:	68 c0 00 00 00       	push   $0xc0
  80d082:	68 f0 2e 81 00       	push   $0x812ef0
  80d087:	e8 cc 12 00 00       	call   80e358 <_panic>
      if (prev != NULL) {
  80d08c:	85 ff                	test   %edi,%edi
  80d08e:	0f 84 80 02 00 00    	je     80d314 <tcp_input+0x525>
        prev->next = pcb->next;
  80d094:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d097:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d09a:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d09d:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d0a3:	39 c3                	cmp    %eax,%ebx
  80d0a5:	0f 85 69 02 00 00    	jne    80d314 <tcp_input+0x525>
  80d0ab:	83 ec 04             	sub    $0x4,%esp
  80d0ae:	68 74 2e 81 00       	push   $0x812e74
  80d0b3:	68 c6 00 00 00       	push   $0xc6
  80d0b8:	68 f0 2e 81 00       	push   $0x812ef0
  80d0bd:	e8 96 12 00 00       	call   80e358 <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d0c2:	89 df                	mov    %ebx,%edi
  80d0c4:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d0c7:	85 db                	test   %ebx,%ebx
  80d0c9:	0f 85 27 ff ff ff    	jne    80cff6 <tcp_input+0x207>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d0cf:	8b 1d 50 b2 b3 00    	mov    0xb3b250,%ebx
  80d0d5:	e9 88 00 00 00       	jmp    80d162 <tcp_input+0x373>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d0da:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d0de:	74 17                	je     80d0f7 <tcp_input+0x308>
  80d0e0:	83 ec 04             	sub    $0x4,%esp
  80d0e3:	68 a0 2e 81 00       	push   $0x812ea0
  80d0e8:	68 d0 00 00 00       	push   $0xd0
  80d0ed:	68 f0 2e 81 00       	push   $0x812ef0
  80d0f2:	e8 61 12 00 00       	call   80e358 <_panic>
      if (pcb->remote_port == tcphdr->src &&
  80d0f7:	0f b7 02             	movzwl (%edx),%eax
  80d0fa:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d0fe:	75 5f                	jne    80d15f <tcp_input+0x370>
  80d100:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d104:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d108:	75 55                	jne    80d15f <tcp_input+0x370>
         pcb->local_port == tcphdr->dest &&
  80d10a:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d10d:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d110:	75 4d                	jne    80d15f <tcp_input+0x370>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d112:	8b 41 10             	mov    0x10(%ecx),%eax
  80d115:	39 03                	cmp    %eax,(%ebx)
  80d117:	75 46                	jne    80d15f <tcp_input+0x370>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d119:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80d11d:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d123:	89 c2                	mov    %eax,%edx
  80d125:	2b 53 24             	sub    0x24(%ebx),%edx
  80d128:	85 d2                	test   %edx,%edx
  80d12a:	7e 03                	jle    80d12f <tcp_input+0x340>
    pcb->rcv_nxt = seqno + tcplen;
  80d12c:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  80d12f:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
  80d134:	74 10                	je     80d146 <tcp_input+0x357>
    tcp_ack_now(pcb);
  80d136:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d13a:	83 ec 0c             	sub    $0xc,%esp
  80d13d:	53                   	push   %ebx
  80d13e:	e8 b6 ad ff ff       	call   807ef9 <tcp_output>
  80d143:	83 c4 10             	add    $0x10,%esp
  }
  return tcp_output(pcb);
  80d146:	83 ec 0c             	sub    $0xc,%esp
  80d149:	53                   	push   %ebx
  80d14a:	e8 aa ad ff ff       	call   807ef9 <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  80d14f:	89 34 24             	mov    %esi,(%esp)
  80d152:	e8 cd 75 ff ff       	call   804724 <pbuf_free>
        return;
  80d157:	83 c4 10             	add    $0x10,%esp
  80d15a:	e9 fb 09 00 00       	jmp    80db5a <tcp_input+0xd6b>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d15f:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d162:	85 db                	test   %ebx,%ebx
  80d164:	0f 85 70 ff ff ff    	jne    80d0da <tcp_input+0x2eb>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d16a:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80d16f:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d172:	89 c3                	mov    %eax,%ebx
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  80d174:	bf 00 00 00 00       	mov    $0x0,%edi
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d179:	e9 89 01 00 00       	jmp    80d307 <tcp_input+0x518>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d17e:	85 db                	test   %ebx,%ebx
  80d180:	74 0f                	je     80d191 <tcp_input+0x3a2>
  80d182:	8b 03                	mov    (%ebx),%eax
  80d184:	85 c0                	test   %eax,%eax
  80d186:	74 09                	je     80d191 <tcp_input+0x3a2>
  80d188:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d18b:	0f 85 71 01 00 00    	jne    80d302 <tcp_input+0x513>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d191:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d195:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d199:	0f 85 63 01 00 00    	jne    80d302 <tcp_input+0x513>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  80d19f:	85 ff                	test   %edi,%edi
  80d1a1:	74 12                	je     80d1b5 <tcp_input+0x3c6>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d1a3:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d1a6:	89 47 0c             	mov    %eax,0xc(%edi)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d1a9:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d1ac:	89 43 0c             	mov    %eax,0xc(%ebx)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d1af:	89 1d 44 b2 b3 00    	mov    %ebx,0xb3b244
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  80d1b5:	f6 45 d4 10          	testb  $0x10,-0x2c(%ebp)
  80d1b9:	74 35                	je     80d1f0 <tcp_input+0x401>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  80d1bb:	83 ec 08             	sub    $0x8,%esp
  80d1be:	0f b7 02             	movzwl (%edx),%eax
  80d1c1:	50                   	push   %eax
  80d1c2:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d1c6:	50                   	push   %eax
  80d1c7:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d1ca:	50                   	push   %eax
  80d1cb:	83 c1 10             	add    $0x10,%ecx
  80d1ce:	51                   	push   %ecx
  80d1cf:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80d1d3:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d1d9:	50                   	push   %eax
  80d1da:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d1df:	83 c0 01             	add    $0x1,%eax
  80d1e2:	50                   	push   %eax
  80d1e3:	e8 88 b1 ff ff       	call   808370 <tcp_rst>
  80d1e8:	83 c4 20             	add    $0x20,%esp
  80d1eb:	e9 01 01 00 00       	jmp    80d2f1 <tcp_input+0x502>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  80d1f0:	f6 45 d4 02          	testb  $0x2,-0x2c(%ebp)
  80d1f4:	0f 84 f7 00 00 00    	je     80d2f1 <tcp_input+0x502>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  80d1fa:	83 ec 0c             	sub    $0xc,%esp
  80d1fd:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  80d201:	50                   	push   %eax
  80d202:	e8 70 8e ff ff       	call   806077 <tcp_alloc>
  80d207:	89 c7                	mov    %eax,%edi
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  80d209:	83 c4 10             	add    $0x10,%esp
  80d20c:	85 c0                	test   %eax,%eax
  80d20e:	0f 84 dd 00 00 00    	je     80d2f1 <tcp_input+0x502>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d214:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d219:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80d21c:	74 05                	je     80d223 <tcp_input+0x434>
  80d21e:	8b 50 10             	mov    0x10(%eax),%edx
  80d221:	eb 05                	jmp    80d228 <tcp_input+0x439>
  80d223:	ba 00 00 00 00       	mov    $0x0,%edx
  80d228:	89 17                	mov    %edx,(%edi)
    npcb->local_port = pcb->local_port;
  80d22a:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  80d22e:	66 89 57 1c          	mov    %dx,0x1c(%edi)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d232:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80d235:	74 05                	je     80d23c <tcp_input+0x44d>
  80d237:	8b 40 0c             	mov    0xc(%eax),%eax
  80d23a:	eb 05                	jmp    80d241 <tcp_input+0x452>
  80d23c:	b8 00 00 00 00       	mov    $0x0,%eax
  80d241:	89 47 04             	mov    %eax,0x4(%edi)
    npcb->remote_port = tcphdr->src;
  80d244:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d24a:	0f b7 02             	movzwl (%edx),%eax
  80d24d:	66 89 47 1e          	mov    %ax,0x1e(%edi)
    npcb->state = SYN_RCVD;
  80d251:	c7 47 10 03 00 00 00 	movl   $0x3,0x10(%edi)
    npcb->rcv_nxt = seqno + 1;
  80d258:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d25d:	8d 48 01             	lea    0x1(%eax),%ecx
  80d260:	89 4f 24             	mov    %ecx,0x24(%edi)
    npcb->snd_wnd = tcphdr->wnd;
  80d263:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d267:	66 89 57 5c          	mov    %dx,0x5c(%edi)
    npcb->ssthresh = npcb->snd_wnd;
  80d26b:	66 89 57 50          	mov    %dx,0x50(%edi)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d26f:	83 e8 01             	sub    $0x1,%eax
  80d272:	89 47 60             	mov    %eax,0x60(%edi)
    npcb->callback_arg = pcb->callback_arg;
  80d275:	8b 43 18             	mov    0x18(%ebx),%eax
  80d278:	89 47 18             	mov    %eax,0x18(%edi)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  80d27b:	8b 43 20             	mov    0x20(%ebx),%eax
  80d27e:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d284:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80d288:	66 25 99 01          	and    $0x199,%ax
  80d28c:	66 89 47 08          	mov    %ax,0x8(%edi)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  80d290:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d295:	89 47 0c             	mov    %eax,0xc(%edi)
  80d298:	89 3d 3c b2 b3 00    	mov    %edi,0xb3b23c
  80d29e:	e8 c0 4e ff ff       	call   802163 <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  80d2a3:	89 f8                	mov    %edi,%eax
  80d2a5:	e8 2d ee ff ff       	call   80c0d7 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d2aa:	83 ec 08             	sub    $0x8,%esp
  80d2ad:	8d 47 04             	lea    0x4(%edi),%eax
  80d2b0:	50                   	push   %eax
  80d2b1:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80d2b5:	50                   	push   %eax
  80d2b6:	e8 49 8f ff ff       	call   806204 <tcp_eff_send_mss>
  80d2bb:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  80d2bf:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80d2c6:	e8 24 a3 ff ff       	call   8075ef <htonl>
  80d2cb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80d2ce:	83 c4 0c             	add    $0xc,%esp
  80d2d1:	6a 04                	push   $0x4
  80d2d3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d2d6:	50                   	push   %eax
  80d2d7:	6a 00                	push   $0x0
  80d2d9:	6a 12                	push   $0x12
  80d2db:	6a 00                	push   $0x0
  80d2dd:	6a 00                	push   $0x0
  80d2df:	57                   	push   %edi
  80d2e0:	e8 3b a5 ff ff       	call   807820 <tcp_enqueue>
    return tcp_output(npcb);
  80d2e5:	83 c4 14             	add    $0x14,%esp
  80d2e8:	57                   	push   %edi
  80d2e9:	e8 0b ac ff ff       	call   807ef9 <tcp_output>
  80d2ee:	83 c4 10             	add    $0x10,%esp
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  80d2f1:	83 ec 0c             	sub    $0xc,%esp
  80d2f4:	56                   	push   %esi
  80d2f5:	e8 2a 74 ff ff       	call   804724 <pbuf_free>
        return;
  80d2fa:	83 c4 10             	add    $0x10,%esp
  80d2fd:	e9 58 08 00 00       	jmp    80db5a <tcp_input+0xd6b>
  80d302:	89 df                	mov    %ebx,%edi
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d304:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d307:	85 db                	test   %ebx,%ebx
  80d309:	0f 85 6f fe ff ff    	jne    80d17e <tcp_input+0x38f>
  80d30f:	e9 b5 07 00 00       	jmp    80dac9 <tcp_input+0xcda>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  80d314:	c7 05 b4 b1 b3 00 00 	movl   $0x0,0xb3b1b4
  80d31b:	00 00 00 
    inseg.len = p->tot_len;
  80d31e:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d322:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
    inseg.dataptr = p->payload;
  80d328:	8b 46 04             	mov    0x4(%esi),%eax
  80d32b:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
    inseg.p = p;
  80d330:	89 35 b8 b1 b3 00    	mov    %esi,0xb3b1b8
    inseg.tcphdr = tcphdr;
  80d336:	89 15 c4 b1 b3 00    	mov    %edx,0xb3b1c4

    recv_data = NULL;
  80d33c:	c7 05 98 b1 b3 00 00 	movl   $0x0,0xb3b198
  80d343:	00 00 00 
    recv_flags = 0;
  80d346:	c6 05 9c b1 b3 00 00 	movb   $0x0,0xb3b19c

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80d34d:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d353:	85 c0                	test   %eax,%eax
  80d355:	74 45                	je     80d39c <tcp_input+0x5ad>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d357:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d35d:	85 d2                	test   %edx,%edx
  80d35f:	74 12                	je     80d373 <tcp_input+0x584>
  80d361:	6a 00                	push   $0x0
  80d363:	50                   	push   %eax
  80d364:	53                   	push   %ebx
  80d365:	ff 73 18             	pushl  0x18(%ebx)
  80d368:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d36a:	83 c4 10             	add    $0x10,%esp
  80d36d:	84 c0                	test   %al,%al
  80d36f:	74 0e                	je     80d37f <tcp_input+0x590>
  80d371:	eb 18                	jmp    80d38b <tcp_input+0x59c>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d373:	83 ec 0c             	sub    $0xc,%esp
  80d376:	50                   	push   %eax
  80d377:	e8 a8 73 ff ff       	call   804724 <pbuf_free>
  80d37c:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80d37f:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d386:	00 00 00 
  80d389:	eb 11                	jmp    80d39c <tcp_input+0x5ad>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  80d38b:	83 ec 0c             	sub    $0xc,%esp
  80d38e:	56                   	push   %esi
  80d38f:	e8 90 73 ff ff       	call   804724 <pbuf_free>
        return;
  80d394:	83 c4 10             	add    $0x10,%esp
  80d397:	e9 be 07 00 00       	jmp    80db5a <tcp_input+0xd6b>
      }
    }

    tcp_input_pcb = pcb;
  80d39c:	89 1d 58 b2 b3 00    	mov    %ebx,0xb3b258
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  80d3a2:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d3a9:	a8 04                	test   $0x4,%al
  80d3ab:	74 5e                	je     80d40b <tcp_input+0x61c>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  80d3ad:	8b 53 10             	mov    0x10(%ebx),%edx
  80d3b0:	83 fa 02             	cmp    $0x2,%edx
  80d3b3:	75 0f                	jne    80d3c4 <tcp_input+0x5d5>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80d3b5:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d3ba:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d3bd:	74 3c                	je     80d3fb <tcp_input+0x60c>
  80d3bf:	e9 b1 05 00 00       	jmp    80d975 <tcp_input+0xb86>
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d3c4:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d3c9:	2b 43 24             	sub    0x24(%ebx),%eax
  80d3cc:	0f 88 a3 05 00 00    	js     80d975 <tcp_input+0xb86>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80d3d2:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d3d6:	29 c8                	sub    %ecx,%eax
  80d3d8:	85 c0                	test   %eax,%eax
  80d3da:	0f 8f 46 07 00 00    	jg     80db26 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d3e0:	85 d2                	test   %edx,%edx
  80d3e2:	75 17                	jne    80d3fb <tcp_input+0x60c>
  80d3e4:	83 ec 04             	sub    $0x4,%esp
  80d3e7:	68 d0 2e 81 00       	push   $0x812ed0
  80d3ec:	68 09 02 00 00       	push   $0x209
  80d3f1:	68 f0 2e 81 00       	push   $0x812ef0
  80d3f6:	e8 5d 0f 00 00       	call   80e358 <_panic>
      recv_flags = TF_RESET;
  80d3fb:	c6 05 9c b1 b3 00 08 	movb   $0x8,0xb3b19c
      pcb->flags &= ~TF_ACK_DELAY;
  80d402:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  80d406:	e9 1b 07 00 00       	jmp    80db26 <tcp_input+0xd37>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  80d40b:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  80d411:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80d414:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  80d41b:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80d41f:	0f 87 50 05 00 00    	ja     80d975 <tcp_input+0xb86>
  80d425:	8b 53 10             	mov    0x10(%ebx),%edx
  80d428:	ff 24 95 74 2f 81 00 	jmp    *0x812f74(,%edx,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80d42f:	83 e0 12             	and    $0x12,%eax
  80d432:	3c 12                	cmp    $0x12,%al
  80d434:	0f 85 04 01 00 00    	jne    80d53e <tcp_input+0x74f>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80d43a:	83 ec 0c             	sub    $0xc,%esp
  80d43d:	8b 43 78             	mov    0x78(%ebx),%eax
  80d440:	8b 40 10             	mov    0x10(%eax),%eax
  80d443:	ff 70 04             	pushl  0x4(%eax)
  80d446:	e8 c5 a3 ff ff       	call   807810 <ntohl>
  80d44b:	8d 50 01             	lea    0x1(%eax),%edx
  80d44e:	83 c4 10             	add    $0x10,%esp
  80d451:	3b 15 a4 b1 b3 00    	cmp    0xb3b1a4,%edx
  80d457:	0f 85 e1 00 00 00    	jne    80d53e <tcp_input+0x74f>
      pcb->snd_buf++;
  80d45d:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80d462:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d467:	8d 48 01             	lea    0x1(%eax),%ecx
  80d46a:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80d46d:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80d470:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d476:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d47a:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80d47e:	83 e8 01             	sub    $0x1,%eax
  80d481:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80d484:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  80d48b:	89 d8                	mov    %ebx,%eax
  80d48d:	e8 45 ec ff ff       	call   80c0d7 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80d492:	83 ec 08             	sub    $0x8,%esp
  80d495:	8d 43 04             	lea    0x4(%ebx),%eax
  80d498:	50                   	push   %eax
  80d499:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d49d:	50                   	push   %eax
  80d49e:	e8 61 8d ff ff       	call   806204 <tcp_eff_send_mss>
  80d4a3:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  80d4a7:	6b d0 0a             	imul   $0xa,%eax,%edx
  80d4aa:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d4ae:	83 c4 10             	add    $0x10,%esp
  80d4b1:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80d4b4:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80d4b9:	0f 44 c2             	cmove  %edx,%eax
  80d4bc:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d4c0:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80d4c4:	66 85 c0             	test   %ax,%ax
  80d4c7:	75 17                	jne    80d4e0 <tcp_input+0x6f1>
  80d4c9:	83 ec 04             	sub    $0x4,%esp
  80d4cc:	68 49 2f 81 00       	push   $0x812f49
  80d4d1:	68 35 02 00 00       	push   $0x235
  80d4d6:	68 f0 2e 81 00       	push   $0x812ef0
  80d4db:	e8 78 0e 00 00       	call   80e358 <_panic>
      --pcb->snd_queuelen;
  80d4e0:	83 e8 01             	sub    $0x1,%eax
  80d4e3:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  80d4e7:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80d4ea:	8b 10                	mov    (%eax),%edx
  80d4ec:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80d4ef:	85 d2                	test   %edx,%edx
  80d4f1:	75 08                	jne    80d4fb <tcp_input+0x70c>
        pcb->rtime = -1;
  80d4f3:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80d4f9:	eb 0a                	jmp    80d505 <tcp_input+0x716>
      else {
        pcb->rtime = 0;
  80d4fb:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80d501:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  80d505:	83 ec 0c             	sub    $0xc,%esp
  80d508:	50                   	push   %eax
  80d509:	e8 5c 81 ff ff       	call   80566a <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80d50e:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80d514:	83 c4 10             	add    $0x10,%esp
  80d517:	85 c0                	test   %eax,%eax
  80d519:	74 0e                	je     80d529 <tcp_input+0x73a>
  80d51b:	83 ec 04             	sub    $0x4,%esp
  80d51e:	6a 00                	push   $0x0
  80d520:	53                   	push   %ebx
  80d521:	ff 73 18             	pushl  0x18(%ebx)
  80d524:	ff d0                	call   *%eax
  80d526:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80d529:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d52d:	83 ec 0c             	sub    $0xc,%esp
  80d530:	53                   	push   %ebx
  80d531:	e8 c3 a9 ff ff       	call   807ef9 <tcp_output>
  80d536:	83 c4 10             	add    $0x10,%esp
  80d539:	e9 e8 05 00 00       	jmp    80db26 <tcp_input+0xd37>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  80d53e:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d545:	0f 84 db 05 00 00    	je     80db26 <tcp_input+0xd37>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80d54b:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d551:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d556:	83 ec 08             	sub    $0x8,%esp
  80d559:	0f b7 0a             	movzwl (%edx),%ecx
  80d55c:	51                   	push   %ecx
  80d55d:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d561:	52                   	push   %edx
  80d562:	8d 50 0c             	lea    0xc(%eax),%edx
  80d565:	52                   	push   %edx
  80d566:	83 c0 10             	add    $0x10,%eax
  80d569:	50                   	push   %eax
  80d56a:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d571:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d577:	50                   	push   %eax
  80d578:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80d57e:	e8 ed ad ff ff       	call   808370 <tcp_rst>
  80d583:	83 c4 20             	add    $0x20,%esp
  80d586:	e9 9b 05 00 00       	jmp    80db26 <tcp_input+0xd37>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  80d58b:	83 e0 14             	and    $0x14,%eax
  80d58e:	3c 10                	cmp    $0x10,%al
  80d590:	0f 85 90 05 00 00    	jne    80db26 <tcp_input+0xd37>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80d596:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80d59c:	8d 42 ff             	lea    -0x1(%edx),%eax
  80d59f:	3b 43 48             	cmp    0x48(%ebx),%eax
  80d5a2:	0f 88 b5 00 00 00    	js     80d65d <tcp_input+0x86e>
  80d5a8:	89 d0                	mov    %edx,%eax
  80d5aa:	2b 43 54             	sub    0x54(%ebx),%eax
  80d5ad:	85 c0                	test   %eax,%eax
  80d5af:	0f 8f a8 00 00 00    	jg     80d65d <tcp_input+0x86e>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  80d5b5:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d5bc:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80d5c2:	85 c0                	test   %eax,%eax
  80d5c4:	75 17                	jne    80d5dd <tcp_input+0x7ee>
  80d5c6:	83 ec 04             	sub    $0x4,%esp
  80d5c9:	68 5f 2f 81 00       	push   $0x812f5f
  80d5ce:	68 5b 02 00 00       	push   $0x25b
  80d5d3:	68 f0 2e 81 00       	push   $0x812ef0
  80d5d8:	e8 7b 0d 00 00       	call   80e358 <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80d5dd:	83 ec 04             	sub    $0x4,%esp
  80d5e0:	6a 00                	push   $0x0
  80d5e2:	53                   	push   %ebx
  80d5e3:	ff 73 18             	pushl  0x18(%ebx)
  80d5e6:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80d5e8:	83 c4 10             	add    $0x10,%esp
  80d5eb:	84 c0                	test   %al,%al
  80d5ed:	74 1b                	je     80d60a <tcp_input+0x81b>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  80d5ef:	83 ec 0c             	sub    $0xc,%esp
  80d5f2:	53                   	push   %ebx
  80d5f3:	e8 eb 84 ff ff       	call   805ae3 <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80d5f8:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d5ff:	00 00 00 
  80d602:	83 c4 10             	add    $0x10,%esp
  80d605:	e9 97 04 00 00       	jmp    80daa1 <tcp_input+0xcb2>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  80d60a:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  80d60e:	89 d8                	mov    %ebx,%eax
  80d610:	e8 75 eb ff ff       	call   80c18a <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d615:	66 83 fe 01          	cmp    $0x1,%si
  80d619:	75 09                	jne    80d624 <tcp_input+0x835>
  80d61b:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  80d61f:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80d622:	eb 04                	jmp    80d628 <tcp_input+0x839>
  80d624:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80d628:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  80d62c:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d633:	0f 84 ed 04 00 00    	je     80db26 <tcp_input+0xd37>
  80d639:	84 c0                	test   %al,%al
  80d63b:	0f 84 e5 04 00 00    	je     80db26 <tcp_input+0xd37>
          tcp_ack_now(pcb);
  80d641:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d645:	83 ec 0c             	sub    $0xc,%esp
  80d648:	53                   	push   %ebx
  80d649:	e8 ab a8 ff ff       	call   807ef9 <tcp_output>
          pcb->state = CLOSE_WAIT;
  80d64e:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d655:	83 c4 10             	add    $0x10,%esp
  80d658:	e9 c9 04 00 00       	jmp    80db26 <tcp_input+0xd37>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  80d65d:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d663:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d668:	83 ec 08             	sub    $0x8,%esp
  80d66b:	0f b7 31             	movzwl (%ecx),%esi
  80d66e:	56                   	push   %esi
  80d66f:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80d673:	51                   	push   %ecx
  80d674:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d677:	51                   	push   %ecx
  80d678:	83 c0 10             	add    $0x10,%eax
  80d67b:	50                   	push   %eax
  80d67c:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d683:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d689:	50                   	push   %eax
  80d68a:	52                   	push   %edx
  80d68b:	e8 e0 ac ff ff       	call   808370 <tcp_rst>
  80d690:	83 c4 20             	add    $0x20,%esp
  80d693:	e9 8e 04 00 00       	jmp    80db26 <tcp_input+0xd37>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  80d698:	89 d8                	mov    %ebx,%eax
  80d69a:	e8 eb ea ff ff       	call   80c18a <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80d69f:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d6a6:	0f 84 7a 04 00 00    	je     80db26 <tcp_input+0xd37>
  80d6ac:	84 c0                	test   %al,%al
  80d6ae:	0f 84 72 04 00 00    	je     80db26 <tcp_input+0xd37>
      tcp_ack_now(pcb);
  80d6b4:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d6b8:	83 ec 0c             	sub    $0xc,%esp
  80d6bb:	53                   	push   %ebx
  80d6bc:	e8 38 a8 ff ff       	call   807ef9 <tcp_output>
      pcb->state = CLOSE_WAIT;
  80d6c1:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d6c8:	83 c4 10             	add    $0x10,%esp
  80d6cb:	e9 56 04 00 00       	jmp    80db26 <tcp_input+0xd37>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  80d6d0:	89 d8                	mov    %ebx,%eax
  80d6d2:	e8 b3 ea ff ff       	call   80c18a <tcp_receive>
    if (flags & TCP_FIN) {
  80d6d7:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d6de:	a8 01                	test   $0x1,%al
  80d6e0:	0f 84 cf 00 00 00    	je     80d7b5 <tcp_input+0x9c6>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d6e6:	a8 10                	test   $0x10,%al
  80d6e8:	0f 84 ab 00 00 00    	je     80d799 <tcp_input+0x9aa>
  80d6ee:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d6f3:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d6f6:	0f 85 9d 00 00 00    	jne    80d799 <tcp_input+0x9aa>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  80d6fc:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d700:	83 ec 0c             	sub    $0xc,%esp
  80d703:	53                   	push   %ebx
  80d704:	e8 f0 a7 ff ff       	call   807ef9 <tcp_output>
        tcp_pcb_purge(pcb);
  80d709:	89 1c 24             	mov    %ebx,(%esp)
  80d70c:	e8 79 80 ff ff       	call   80578a <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80d711:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d716:	83 c4 10             	add    $0x10,%esp
  80d719:	39 c3                	cmp    %eax,%ebx
  80d71b:	75 0a                	jne    80d727 <tcp_input+0x938>
  80d71d:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d720:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80d725:	eb 53                	jmp    80d77a <tcp_input+0x98b>
  80d727:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d72c:	ba 00 00 00 00       	mov    $0x0,%edx
  80d731:	89 de                	mov    %ebx,%esi
  80d733:	89 d7                	mov    %edx,%edi
  80d735:	eb 2d                	jmp    80d764 <tcp_input+0x975>
  80d737:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d73a:	39 ce                	cmp    %ecx,%esi
  80d73c:	0f 94 c3             	sete   %bl
  80d73f:	85 c9                	test   %ecx,%ecx
  80d741:	0f 95 c2             	setne  %dl
  80d744:	84 d3                	test   %dl,%bl
  80d746:	74 15                	je     80d75d <tcp_input+0x96e>
  80d748:	89 f3                	mov    %esi,%ebx
  80d74a:	89 fa                	mov    %edi,%edx
  80d74c:	84 d2                	test   %dl,%dl
  80d74e:	74 05                	je     80d755 <tcp_input+0x966>
  80d750:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d755:	8b 53 0c             	mov    0xc(%ebx),%edx
  80d758:	89 50 0c             	mov    %edx,0xc(%eax)
  80d75b:	eb 1d                	jmp    80d77a <tcp_input+0x98b>
  80d75d:	bf 01 00 00 00       	mov    $0x1,%edi
  80d762:	89 c8                	mov    %ecx,%eax
  80d764:	85 c0                	test   %eax,%eax
  80d766:	75 cf                	jne    80d737 <tcp_input+0x948>
  80d768:	89 f3                	mov    %esi,%ebx
  80d76a:	89 fa                	mov    %edi,%edx
  80d76c:	84 d2                	test   %dl,%dl
  80d76e:	74 0a                	je     80d77a <tcp_input+0x98b>
  80d770:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80d777:	00 00 00 
        pcb->state = TIME_WAIT;
  80d77a:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80d781:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80d786:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d789:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80d78f:	e8 cf 49 ff ff       	call   802163 <tcp_timer_needed>
  80d794:	e9 8d 03 00 00       	jmp    80db26 <tcp_input+0xd37>
      } else {
        tcp_ack_now(pcb);
  80d799:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d79d:	83 ec 0c             	sub    $0xc,%esp
  80d7a0:	53                   	push   %ebx
  80d7a1:	e8 53 a7 ff ff       	call   807ef9 <tcp_output>
        pcb->state = CLOSING;
  80d7a6:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80d7ad:	83 c4 10             	add    $0x10,%esp
  80d7b0:	e9 71 03 00 00       	jmp    80db26 <tcp_input+0xd37>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d7b5:	a8 10                	test   $0x10,%al
  80d7b7:	0f 84 69 03 00 00    	je     80db26 <tcp_input+0xd37>
  80d7bd:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d7c2:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d7c5:	0f 85 5b 03 00 00    	jne    80db26 <tcp_input+0xd37>
      pcb->state = FIN_WAIT_2;
  80d7cb:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80d7d2:	e9 4f 03 00 00       	jmp    80db26 <tcp_input+0xd37>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  80d7d7:	89 d8                	mov    %ebx,%eax
  80d7d9:	e8 ac e9 ff ff       	call   80c18a <tcp_receive>
    if (flags & TCP_FIN) {
  80d7de:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d7e5:	0f 84 3b 03 00 00    	je     80db26 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80d7eb:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d7ef:	83 ec 0c             	sub    $0xc,%esp
  80d7f2:	53                   	push   %ebx
  80d7f3:	e8 01 a7 ff ff       	call   807ef9 <tcp_output>
      tcp_pcb_purge(pcb);
  80d7f8:	89 1c 24             	mov    %ebx,(%esp)
  80d7fb:	e8 8a 7f ff ff       	call   80578a <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80d800:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d805:	83 c4 10             	add    $0x10,%esp
  80d808:	39 c3                	cmp    %eax,%ebx
  80d80a:	75 0a                	jne    80d816 <tcp_input+0xa27>
  80d80c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d80f:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80d814:	eb 53                	jmp    80d869 <tcp_input+0xa7a>
  80d816:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d81b:	b9 00 00 00 00       	mov    $0x0,%ecx
  80d820:	89 de                	mov    %ebx,%esi
  80d822:	89 cf                	mov    %ecx,%edi
  80d824:	eb 2d                	jmp    80d853 <tcp_input+0xa64>
  80d826:	8b 50 0c             	mov    0xc(%eax),%edx
  80d829:	85 d2                	test   %edx,%edx
  80d82b:	0f 95 c3             	setne  %bl
  80d82e:	39 d6                	cmp    %edx,%esi
  80d830:	0f 94 c1             	sete   %cl
  80d833:	84 cb                	test   %cl,%bl
  80d835:	74 15                	je     80d84c <tcp_input+0xa5d>
  80d837:	89 f3                	mov    %esi,%ebx
  80d839:	89 f9                	mov    %edi,%ecx
  80d83b:	84 c9                	test   %cl,%cl
  80d83d:	74 05                	je     80d844 <tcp_input+0xa55>
  80d83f:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d844:	8b 53 0c             	mov    0xc(%ebx),%edx
  80d847:	89 50 0c             	mov    %edx,0xc(%eax)
  80d84a:	eb 1d                	jmp    80d869 <tcp_input+0xa7a>
  80d84c:	bf 01 00 00 00       	mov    $0x1,%edi
  80d851:	89 d0                	mov    %edx,%eax
  80d853:	85 c0                	test   %eax,%eax
  80d855:	75 cf                	jne    80d826 <tcp_input+0xa37>
  80d857:	89 f3                	mov    %esi,%ebx
  80d859:	89 f9                	mov    %edi,%ecx
  80d85b:	84 c9                	test   %cl,%cl
  80d85d:	74 0a                	je     80d869 <tcp_input+0xa7a>
  80d85f:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80d866:	00 00 00 
      pcb->state = TIME_WAIT;
  80d869:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80d870:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80d875:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d878:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80d87e:	e8 e0 48 ff ff       	call   802163 <tcp_timer_needed>
  80d883:	e9 9e 02 00 00       	jmp    80db26 <tcp_input+0xd37>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  80d888:	89 d8                	mov    %ebx,%eax
  80d88a:	e8 fb e8 ff ff       	call   80c18a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d88f:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d896:	0f 84 8a 02 00 00    	je     80db26 <tcp_input+0xd37>
  80d89c:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d8a1:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d8a4:	0f 85 7c 02 00 00    	jne    80db26 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80d8aa:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d8ae:	83 ec 0c             	sub    $0xc,%esp
  80d8b1:	53                   	push   %ebx
  80d8b2:	e8 42 a6 ff ff       	call   807ef9 <tcp_output>
      tcp_pcb_purge(pcb);
  80d8b7:	89 1c 24             	mov    %ebx,(%esp)
  80d8ba:	e8 cb 7e ff ff       	call   80578a <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80d8bf:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d8c4:	83 c4 10             	add    $0x10,%esp
  80d8c7:	39 c3                	cmp    %eax,%ebx
  80d8c9:	75 0a                	jne    80d8d5 <tcp_input+0xae6>
  80d8cb:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d8ce:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80d8d3:	eb 53                	jmp    80d928 <tcp_input+0xb39>
  80d8d5:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d8da:	ba 00 00 00 00       	mov    $0x0,%edx
  80d8df:	89 de                	mov    %ebx,%esi
  80d8e1:	89 d7                	mov    %edx,%edi
  80d8e3:	eb 2d                	jmp    80d912 <tcp_input+0xb23>
  80d8e5:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d8e8:	39 ce                	cmp    %ecx,%esi
  80d8ea:	0f 94 c3             	sete   %bl
  80d8ed:	85 c9                	test   %ecx,%ecx
  80d8ef:	0f 95 c2             	setne  %dl
  80d8f2:	84 d3                	test   %dl,%bl
  80d8f4:	74 15                	je     80d90b <tcp_input+0xb1c>
  80d8f6:	89 f3                	mov    %esi,%ebx
  80d8f8:	89 fa                	mov    %edi,%edx
  80d8fa:	84 d2                	test   %dl,%dl
  80d8fc:	74 05                	je     80d903 <tcp_input+0xb14>
  80d8fe:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d903:	8b 53 0c             	mov    0xc(%ebx),%edx
  80d906:	89 50 0c             	mov    %edx,0xc(%eax)
  80d909:	eb 1d                	jmp    80d928 <tcp_input+0xb39>
  80d90b:	bf 01 00 00 00       	mov    $0x1,%edi
  80d910:	89 c8                	mov    %ecx,%eax
  80d912:	85 c0                	test   %eax,%eax
  80d914:	75 cf                	jne    80d8e5 <tcp_input+0xaf6>
  80d916:	89 f3                	mov    %esi,%ebx
  80d918:	89 fa                	mov    %edi,%edx
  80d91a:	84 d2                	test   %dl,%dl
  80d91c:	74 0a                	je     80d928 <tcp_input+0xb39>
  80d91e:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80d925:	00 00 00 
      pcb->state = TIME_WAIT;
  80d928:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80d92f:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80d934:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d937:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80d93d:	e8 21 48 ff ff       	call   802163 <tcp_timer_needed>
  80d942:	e9 df 01 00 00       	jmp    80db26 <tcp_input+0xd37>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  80d947:	89 d8                	mov    %ebx,%eax
  80d949:	e8 3c e8 ff ff       	call   80c18a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d94e:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d955:	0f 84 cb 01 00 00    	je     80db26 <tcp_input+0xd37>
  80d95b:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d960:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d963:	0f 85 bd 01 00 00    	jne    80db26 <tcp_input+0xd37>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  80d969:	c6 05 9c b1 b3 00 10 	movb   $0x10,0xb3b19c
  80d970:	e9 b1 01 00 00       	jmp    80db26 <tcp_input+0xd37>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80d975:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d97c:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  80d97f:	0f b6 05 9c b1 b3 00 	movzbl 0xb3b19c,%eax
  80d986:	a8 08                	test   $0x8,%al
  80d988:	74 38                	je     80d9c2 <tcp_input+0xbd3>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80d98a:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d990:	85 c0                	test   %eax,%eax
  80d992:	74 0d                	je     80d9a1 <tcp_input+0xbb2>
  80d994:	83 ec 08             	sub    $0x8,%esp
  80d997:	6a fa                	push   $0xfffffffa
  80d999:	ff 73 18             	pushl  0x18(%ebx)
  80d99c:	ff d0                	call   *%eax
  80d99e:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80d9a1:	83 ec 08             	sub    $0x8,%esp
  80d9a4:	53                   	push   %ebx
  80d9a5:	68 3c b2 b3 00       	push   $0xb3b23c
  80d9aa:	e8 56 7e ff ff       	call   805805 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80d9af:	83 c4 08             	add    $0x8,%esp
  80d9b2:	53                   	push   %ebx
  80d9b3:	6a 02                	push   $0x2
  80d9b5:	e8 f7 69 ff ff       	call   8043b1 <memp_free>
  80d9ba:	83 c4 10             	add    $0x10,%esp
  80d9bd:	e9 df 00 00 00       	jmp    80daa1 <tcp_input+0xcb2>
      } else if (recv_flags & TF_CLOSED) {
  80d9c2:	a8 10                	test   $0x10,%al
  80d9c4:	74 21                	je     80d9e7 <tcp_input+0xbf8>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80d9c6:	83 ec 08             	sub    $0x8,%esp
  80d9c9:	53                   	push   %ebx
  80d9ca:	68 3c b2 b3 00       	push   $0xb3b23c
  80d9cf:	e8 31 7e ff ff       	call   805805 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80d9d4:	83 c4 08             	add    $0x8,%esp
  80d9d7:	53                   	push   %ebx
  80d9d8:	6a 02                	push   $0x2
  80d9da:	e8 d2 69 ff ff       	call   8043b1 <memp_free>
  80d9df:	83 c4 10             	add    $0x10,%esp
  80d9e2:	e9 ba 00 00 00       	jmp    80daa1 <tcp_input+0xcb2>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80d9e7:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else {
        err = ERR_OK;
  80d9eb:	b8 00 00 00 00       	mov    $0x0,%eax
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80d9f0:	66 85 d2             	test   %dx,%dx
  80d9f3:	74 1a                	je     80da0f <tcp_input+0xc20>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80d9f5:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80d9fb:	85 c9                	test   %ecx,%ecx
  80d9fd:	74 10                	je     80da0f <tcp_input+0xc20>
  80d9ff:	83 ec 04             	sub    $0x4,%esp
  80da02:	0f b7 d2             	movzwl %dx,%edx
  80da05:	52                   	push   %edx
  80da06:	53                   	push   %ebx
  80da07:	ff 73 18             	pushl  0x18(%ebx)
  80da0a:	ff d1                	call   *%ecx
  80da0c:	83 c4 10             	add    $0x10,%esp
        }
      
        if (recv_data != NULL) {
  80da0f:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80da15:	85 d2                	test   %edx,%edx
  80da17:	74 58                	je     80da71 <tcp_input+0xc82>
          if(flags & TCP_PSH) {
  80da19:	f6 05 a0 b1 b3 00 08 	testb  $0x8,0xb3b1a0
  80da20:	0f 84 0f 01 00 00    	je     80db35 <tcp_input+0xd46>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80da26:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
  80da2a:	e9 06 01 00 00       	jmp    80db35 <tcp_input+0xd46>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80da2f:	6a 00                	push   $0x0
  80da31:	52                   	push   %edx
  80da32:	53                   	push   %ebx
  80da33:	ff 73 18             	pushl  0x18(%ebx)
  80da36:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  80da38:	83 c4 10             	add    $0x10,%esp
  80da3b:	84 c0                	test   %al,%al
  80da3d:	75 1c                	jne    80da5b <tcp_input+0xc6c>
  80da3f:	e9 04 01 00 00       	jmp    80db48 <tcp_input+0xd59>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80da44:	83 ec 0c             	sub    $0xc,%esp
  80da47:	52                   	push   %edx
  80da48:	e8 d7 6c ff ff       	call   804724 <pbuf_free>
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80da4d:	83 c4 10             	add    $0x10,%esp
  80da50:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80da57:	75 21                	jne    80da7a <tcp_input+0xc8b>
  80da59:	eb 3a                	jmp    80da95 <tcp_input+0xca6>
          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  80da5b:	a1 98 b1 b3 00       	mov    0xb3b198,%eax
  80da60:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80da66:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80da6d:	74 32                	je     80daa1 <tcp_input+0xcb2>
  80da6f:	eb 09                	jmp    80da7a <tcp_input+0xc8b>
  80da71:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80da78:	74 17                	je     80da91 <tcp_input+0xca2>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80da7a:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80da80:	85 c0                	test   %eax,%eax
  80da82:	74 11                	je     80da95 <tcp_input+0xca6>
  80da84:	6a 00                	push   $0x0
  80da86:	6a 00                	push   $0x0
  80da88:	53                   	push   %ebx
  80da89:	ff 73 18             	pushl  0x18(%ebx)
  80da8c:	ff d0                	call   *%eax
  80da8e:	83 c4 10             	add    $0x10,%esp
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  80da91:	84 c0                	test   %al,%al
  80da93:	75 0c                	jne    80daa1 <tcp_input+0xcb2>
          tcp_output(pcb);
  80da95:	83 ec 0c             	sub    $0xc,%esp
  80da98:	53                   	push   %ebx
  80da99:	e8 5b a4 ff ff       	call   807ef9 <tcp_output>
  80da9e:	83 c4 10             	add    $0x10,%esp
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  80daa1:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80daa6:	85 c0                	test   %eax,%eax
  80daa8:	0f 84 ac 00 00 00    	je     80db5a <tcp_input+0xd6b>
    {
      pbuf_free(inseg.p);
  80daae:	83 ec 0c             	sub    $0xc,%esp
  80dab1:	50                   	push   %eax
  80dab2:	e8 6d 6c ff ff       	call   804724 <pbuf_free>
      inseg.p = NULL;
  80dab7:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80dabe:	00 00 00 
  80dac1:	83 c4 10             	add    $0x10,%esp
  80dac4:	e9 91 00 00 00       	jmp    80db5a <tcp_input+0xd6b>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80dac9:	83 ec 0c             	sub    $0xc,%esp
  80dacc:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80dad0:	50                   	push   %eax
  80dad1:	e8 0c 9b ff ff       	call   8075e2 <ntohs>
  80dad6:	83 c4 10             	add    $0x10,%esp
  80dad9:	a8 04                	test   $0x4,%al
  80dadb:	75 3b                	jne    80db18 <tcp_input+0xd29>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80dadd:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  80dae3:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  80dae8:	83 ec 08             	sub    $0x8,%esp
  80daeb:	0f b7 0a             	movzwl (%edx),%ecx
  80daee:	51                   	push   %ecx
  80daef:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80daf3:	52                   	push   %edx
  80daf4:	8d 50 0c             	lea    0xc(%eax),%edx
  80daf7:	52                   	push   %edx
  80daf8:	83 c0 10             	add    $0x10,%eax
  80dafb:	50                   	push   %eax
  80dafc:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80db03:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80db09:	50                   	push   %eax
  80db0a:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80db10:	e8 5b a8 ff ff       	call   808370 <tcp_rst>
  80db15:	83 c4 20             	add    $0x20,%esp
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  80db18:	83 ec 0c             	sub    $0xc,%esp
  80db1b:	56                   	push   %esi
  80db1c:	e8 03 6c ff ff       	call   804724 <pbuf_free>
  80db21:	83 c4 10             	add    $0x10,%esp
  80db24:	eb 34                	jmp    80db5a <tcp_input+0xd6b>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80db26:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80db2d:	00 00 00 
  80db30:	e9 4a fe ff ff       	jmp    80d97f <tcp_input+0xb90>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80db35:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80db3b:	85 c0                	test   %eax,%eax
  80db3d:	0f 85 ec fe ff ff    	jne    80da2f <tcp_input+0xc40>
  80db43:	e9 fc fe ff ff       	jmp    80da44 <tcp_input+0xc55>
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80db48:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80db4f:	0f 85 25 ff ff ff    	jne    80da7a <tcp_input+0xc8b>
  80db55:	e9 3b ff ff ff       	jmp    80da95 <tcp_input+0xca6>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  80db5a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80db5d:	5b                   	pop    %ebx
  80db5e:	5e                   	pop    %esi
  80db5f:	5f                   	pop    %edi
  80db60:	5d                   	pop    %ebp
  80db61:	c3                   	ret    

0080db62 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80db62:	55                   	push   %ebp
  80db63:	89 e5                	mov    %esp,%ebp
  80db65:	57                   	push   %edi
  80db66:	56                   	push   %esi
  80db67:	53                   	push   %ebx
  80db68:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80db6b:	8b 45 08             	mov    0x8(%ebp),%eax
  80db6e:	8b 40 04             	mov    0x4(%eax),%eax
  proto = IPH_PROTO(iphdr);
  80db71:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80db74:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80db78:	50                   	push   %eax
  80db79:	e8 64 9a ff ff       	call   8075e2 <ntohs>

  prev = NULL;
  pcb = raw_pcbs;
  80db7e:	8b 1d c8 b1 b3 00    	mov    0xb3b1c8,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80db84:	83 c4 10             	add    $0x10,%esp
raw_input(struct pbuf *p, struct netif *inp)
{
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  80db87:	be 00 00 00 00       	mov    $0x0,%esi
  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  80db8c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  80db93:	0f b6 f8             	movzbl %al,%edi
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80db96:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80db99:	83 c0 0c             	add    $0xc,%eax
  80db9c:	89 45 e0             	mov    %eax,-0x20(%ebp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80db9f:	eb 5d                	jmp    80dbfe <raw_input+0x9c>
    if (pcb->protocol == proto) {
  80dba1:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80dba5:	39 f8                	cmp    %edi,%eax
  80dba7:	75 4f                	jne    80dbf8 <raw_input+0x96>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  80dba9:	8b 43 14             	mov    0x14(%ebx),%eax
  80dbac:	85 c0                	test   %eax,%eax
  80dbae:	74 48                	je     80dbf8 <raw_input+0x96>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80dbb0:	ff 75 e0             	pushl  -0x20(%ebp)
  80dbb3:	ff 75 08             	pushl  0x8(%ebp)
  80dbb6:	53                   	push   %ebx
  80dbb7:	ff 73 18             	pushl  0x18(%ebx)
  80dbba:	ff d0                	call   *%eax
  80dbbc:	83 c4 10             	add    $0x10,%esp
  80dbbf:	84 c0                	test   %al,%al
  80dbc1:	74 35                	je     80dbf8 <raw_input+0x96>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  80dbc3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80dbc6:	85 d2                	test   %edx,%edx
  80dbc8:	74 22                	je     80dbec <raw_input+0x8a>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  80dbca:	8b 43 0c             	mov    0xc(%ebx),%eax
  80dbcd:	89 42 0c             	mov    %eax,0xc(%edx)
            pcb->next = raw_pcbs;
  80dbd0:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80dbd5:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80dbd8:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
  80dbde:	be 01 00 00 00       	mov    $0x1,%esi
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80dbe3:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80dbea:	eb 0c                	jmp    80dbf8 <raw_input+0x96>
          eaten = 1;
  80dbec:	be 01 00 00 00       	mov    $0x1,%esi
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80dbf1:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80dbf8:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80dbfb:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dbfe:	89 f0                	mov    %esi,%eax
  80dc00:	84 c0                	test   %al,%al
  80dc02:	75 04                	jne    80dc08 <raw_input+0xa6>
  80dc04:	85 db                	test   %ebx,%ebx
  80dc06:	75 99                	jne    80dba1 <raw_input+0x3f>
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  80dc08:	89 f0                	mov    %esi,%eax
  80dc0a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80dc0d:	5b                   	pop    %ebx
  80dc0e:	5e                   	pop    %esi
  80dc0f:	5f                   	pop    %edi
  80dc10:	5d                   	pop    %ebp
  80dc11:	c3                   	ret    

0080dc12 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80dc12:	55                   	push   %ebp
  80dc13:	89 e5                	mov    %esp,%ebp
  80dc15:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->local_ip, ipaddr);
  80dc18:	85 c0                	test   %eax,%eax
  80dc1a:	74 04                	je     80dc20 <raw_bind+0xe>
  80dc1c:	8b 10                	mov    (%eax),%edx
  80dc1e:	eb 05                	jmp    80dc25 <raw_bind+0x13>
  80dc20:	ba 00 00 00 00       	mov    $0x0,%edx
  80dc25:	8b 45 08             	mov    0x8(%ebp),%eax
  80dc28:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
}
  80dc2a:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc2f:	5d                   	pop    %ebp
  80dc30:	c3                   	ret    

0080dc31 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80dc31:	55                   	push   %ebp
  80dc32:	89 e5                	mov    %esp,%ebp
  80dc34:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80dc37:	85 c0                	test   %eax,%eax
  80dc39:	74 04                	je     80dc3f <raw_connect+0xe>
  80dc3b:	8b 10                	mov    (%eax),%edx
  80dc3d:	eb 05                	jmp    80dc44 <raw_connect+0x13>
  80dc3f:	ba 00 00 00 00       	mov    $0x0,%edx
  80dc44:	8b 45 08             	mov    0x8(%ebp),%eax
  80dc47:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
}
  80dc4a:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc4f:	5d                   	pop    %ebp
  80dc50:	c3                   	ret    

0080dc51 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80dc51:	55                   	push   %ebp
  80dc52:	89 e5                	mov    %esp,%ebp
  80dc54:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80dc57:	8b 55 0c             	mov    0xc(%ebp),%edx
  80dc5a:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80dc5d:	8b 55 10             	mov    0x10(%ebp),%edx
  80dc60:	89 50 18             	mov    %edx,0x18(%eax)
}
  80dc63:	5d                   	pop    %ebp
  80dc64:	c3                   	ret    

0080dc65 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80dc65:	55                   	push   %ebp
  80dc66:	89 e5                	mov    %esp,%ebp
  80dc68:	57                   	push   %edi
  80dc69:	56                   	push   %esi
  80dc6a:	53                   	push   %ebx
  80dc6b:	83 ec 14             	sub    $0x14,%esp
  80dc6e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dc71:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80dc74:	6a 14                	push   $0x14
  80dc76:	57                   	push   %edi
  80dc77:	e8 d6 69 ff ff       	call   804652 <pbuf_header>
  80dc7c:	83 c4 10             	add    $0x10,%esp
  80dc7f:	84 c0                	test   %al,%al
  80dc81:	74 39                	je     80dcbc <raw_sendto+0x57>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80dc83:	83 ec 04             	sub    $0x4,%esp
  80dc86:	6a 00                	push   $0x0
  80dc88:	6a 00                	push   $0x0
  80dc8a:	6a 01                	push   $0x1
  80dc8c:	e8 59 6b ff ff       	call   8047ea <pbuf_alloc>
  80dc91:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80dc93:	83 c4 10             	add    $0x10,%esp
  80dc96:	85 c0                	test   %eax,%eax
  80dc98:	0f 84 a6 00 00 00    	je     80dd44 <raw_sendto+0xdf>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80dc9e:	83 ec 08             	sub    $0x8,%esp
  80dca1:	57                   	push   %edi
  80dca2:	50                   	push   %eax
  80dca3:	e8 70 6f ff ff       	call   804c18 <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80dca8:	83 c4 04             	add    $0x4,%esp
  80dcab:	ff 75 10             	pushl  0x10(%ebp)
  80dcae:	e8 66 87 ff ff       	call   806419 <ip_route>
  80dcb3:	83 c4 10             	add    $0x10,%esp
  80dcb6:	85 c0                	test   %eax,%eax
  80dcb8:	75 46                	jne    80dd00 <raw_sendto+0x9b>
  80dcba:	eb 2d                	jmp    80dce9 <raw_sendto+0x84>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  80dcbc:	83 ec 08             	sub    $0x8,%esp
  80dcbf:	6a ec                	push   $0xffffffec
  80dcc1:	57                   	push   %edi
  80dcc2:	e8 8b 69 ff ff       	call   804652 <pbuf_header>
  80dcc7:	83 c4 10             	add    $0x10,%esp
  80dcca:	84 c0                	test   %al,%al
  80dccc:	0f 84 87 00 00 00    	je     80dd59 <raw_sendto+0xf4>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80dcd2:	83 ec 04             	sub    $0x4,%esp
  80dcd5:	68 9c 2f 81 00       	push   $0x812f9c
  80dcda:	68 e3 00 00 00       	push   $0xe3
  80dcdf:	68 c2 2f 81 00       	push   $0x812fc2
  80dce4:	e8 6f 06 00 00       	call   80e358 <_panic>
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80dce9:	39 f7                	cmp    %esi,%edi
  80dceb:	74 5e                	je     80dd4b <raw_sendto+0xe6>
      pbuf_free(q);
  80dced:	83 ec 0c             	sub    $0xc,%esp
  80dcf0:	56                   	push   %esi
  80dcf1:	e8 2e 6a ff ff       	call   804724 <pbuf_free>
  80dcf6:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80dcf9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80dcfe:	eb 6f                	jmp    80dd6f <raw_sendto+0x10a>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80dd00:	89 da                	mov    %ebx,%edx
  80dd02:	85 db                	test   %ebx,%ebx
  80dd04:	74 05                	je     80dd0b <raw_sendto+0xa6>
  80dd06:	83 3b 00             	cmpl   $0x0,(%ebx)
  80dd09:	75 03                	jne    80dd0e <raw_sendto+0xa9>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80dd0b:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80dd0e:	83 ec 04             	sub    $0x4,%esp
  80dd11:	50                   	push   %eax
  80dd12:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80dd16:	50                   	push   %eax
  80dd17:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80dd1b:	50                   	push   %eax
  80dd1c:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80dd20:	50                   	push   %eax
  80dd21:	ff 75 10             	pushl  0x10(%ebp)
  80dd24:	52                   	push   %edx
  80dd25:	56                   	push   %esi
  80dd26:	e8 50 8a ff ff       	call   80677b <ip_output_if>
  80dd2b:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80dd2d:	83 c4 20             	add    $0x20,%esp
  80dd30:	39 f7                	cmp    %esi,%edi
  80dd32:	74 3b                	je     80dd6f <raw_sendto+0x10a>
    /* free the header */
    pbuf_free(q);
  80dd34:	83 ec 0c             	sub    $0xc,%esp
  80dd37:	56                   	push   %esi
  80dd38:	e8 e7 69 ff ff       	call   804724 <pbuf_free>
  80dd3d:	83 c4 10             	add    $0x10,%esp
  }
  return err;
  80dd40:	89 d8                	mov    %ebx,%eax
  80dd42:	eb 2b                	jmp    80dd6f <raw_sendto+0x10a>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  80dd44:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80dd49:	eb 24                	jmp    80dd6f <raw_sendto+0x10a>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80dd4b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80dd50:	eb 1d                	jmp    80dd6f <raw_sendto+0x10a>
  80dd52:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80dd57:	eb 16                	jmp    80dd6f <raw_sendto+0x10a>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80dd59:	83 ec 0c             	sub    $0xc,%esp
  80dd5c:	ff 75 10             	pushl  0x10(%ebp)
  80dd5f:	e8 b5 86 ff ff       	call   806419 <ip_route>
  80dd64:	83 c4 10             	add    $0x10,%esp
  80dd67:	85 c0                	test   %eax,%eax
  80dd69:	74 e7                	je     80dd52 <raw_sendto+0xed>
    pbuf_chain(q, p);
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  80dd6b:	89 fe                	mov    %edi,%esi
  80dd6d:	eb 91                	jmp    80dd00 <raw_sendto+0x9b>
  if (q != p) {
    /* free the header */
    pbuf_free(q);
  }
  return err;
}
  80dd6f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80dd72:	5b                   	pop    %ebx
  80dd73:	5e                   	pop    %esi
  80dd74:	5f                   	pop    %edi
  80dd75:	5d                   	pop    %ebp
  80dd76:	c3                   	ret    

0080dd77 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80dd77:	55                   	push   %ebp
  80dd78:	89 e5                	mov    %esp,%ebp
  80dd7a:	83 ec 0c             	sub    $0xc,%esp
  80dd7d:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80dd80:	8d 50 04             	lea    0x4(%eax),%edx
  80dd83:	52                   	push   %edx
  80dd84:	ff 75 0c             	pushl  0xc(%ebp)
  80dd87:	50                   	push   %eax
  80dd88:	e8 d8 fe ff ff       	call   80dc65 <raw_sendto>
}
  80dd8d:	c9                   	leave  
  80dd8e:	c3                   	ret    

0080dd8f <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80dd8f:	55                   	push   %ebp
  80dd90:	89 e5                	mov    %esp,%ebp
  80dd92:	83 ec 08             	sub    $0x8,%esp
  80dd95:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80dd98:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80dd9d:	39 c8                	cmp    %ecx,%eax
  80dd9f:	75 1e                	jne    80ddbf <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80dda1:	8b 40 0c             	mov    0xc(%eax),%eax
  80dda4:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
  80dda9:	eb 18                	jmp    80ddc3 <raw_remove+0x34>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80ddab:	8b 50 0c             	mov    0xc(%eax),%edx
  80ddae:	39 d1                	cmp    %edx,%ecx
  80ddb0:	75 0a                	jne    80ddbc <raw_remove+0x2d>
  80ddb2:	85 d2                	test   %edx,%edx
  80ddb4:	74 06                	je     80ddbc <raw_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80ddb6:	8b 51 0c             	mov    0xc(%ecx),%edx
  80ddb9:	89 50 0c             	mov    %edx,0xc(%eax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80ddbc:	8b 40 0c             	mov    0xc(%eax),%eax
  80ddbf:	85 c0                	test   %eax,%eax
  80ddc1:	75 e8                	jne    80ddab <raw_remove+0x1c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80ddc3:	83 ec 08             	sub    $0x8,%esp
  80ddc6:	51                   	push   %ecx
  80ddc7:	6a 00                	push   $0x0
  80ddc9:	e8 e3 65 ff ff       	call   8043b1 <memp_free>
}
  80ddce:	83 c4 10             	add    $0x10,%esp
  80ddd1:	c9                   	leave  
  80ddd2:	c3                   	ret    

0080ddd3 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80ddd3:	55                   	push   %ebp
  80ddd4:	89 e5                	mov    %esp,%ebp
  80ddd6:	56                   	push   %esi
  80ddd7:	53                   	push   %ebx
  80ddd8:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80dddb:	83 ec 0c             	sub    $0xc,%esp
  80ddde:	6a 00                	push   $0x0
  80dde0:	e8 76 65 ff ff       	call   80435b <memp_malloc>
  80dde5:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80dde7:	83 c4 10             	add    $0x10,%esp
  80ddea:	85 c0                	test   %eax,%eax
  80ddec:	74 27                	je     80de15 <raw_new+0x42>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80ddee:	83 ec 04             	sub    $0x4,%esp
  80ddf1:	6a 1c                	push   $0x1c
  80ddf3:	6a 00                	push   $0x0
  80ddf5:	50                   	push   %eax
  80ddf6:	e8 00 0d 00 00       	call   80eafb <memset>
    pcb->protocol = proto;
  80ddfb:	89 f0                	mov    %esi,%eax
  80ddfd:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80de00:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80de04:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80de09:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80de0c:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
  80de12:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80de15:	89 d8                	mov    %ebx,%eax
  80de17:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80de1a:	5b                   	pop    %ebx
  80de1b:	5e                   	pop    %esi
  80de1c:	5d                   	pop    %ebp
  80de1d:	c3                   	ret    

0080de1e <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80de1e:	55                   	push   %ebp
  80de1f:	89 e5                	mov    %esp,%ebp
  80de21:	57                   	push   %edi
  80de22:	56                   	push   %esi
  80de23:	53                   	push   %ebx
  80de24:	83 ec 28             	sub    $0x28,%esp
  80de27:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80de2a:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80de2d:	0f b7 07             	movzwl (%edi),%eax
  80de30:	50                   	push   %eax
  80de31:	e8 ac 97 ff ff       	call   8075e2 <ntohs>
  80de36:	66 c1 e8 06          	shr    $0x6,%ax
  80de3a:	83 e0 3c             	and    $0x3c,%eax
  80de3d:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80de41:	89 c6                	mov    %eax,%esi
  80de43:	f7 de                	neg    %esi
  80de45:	0f bf f6             	movswl %si,%esi
  80de48:	83 c4 08             	add    $0x8,%esp
  80de4b:	56                   	push   %esi
  80de4c:	53                   	push   %ebx
  80de4d:	e8 00 68 ff ff       	call   804652 <pbuf_header>
  80de52:	83 c4 10             	add    $0x10,%esp
  80de55:	84 c0                	test   %al,%al
  80de57:	0f 85 b1 02 00 00    	jne    80e10e <icmp_input+0x2f0>
  80de5d:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80de62:	0f 86 a6 02 00 00    	jbe    80e10e <icmp_input+0x2f0>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80de68:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80de6b:	80 38 08             	cmpb   $0x8,(%eax)
  80de6e:	0f 85 8c 02 00 00    	jne    80e100 <icmp_input+0x2e2>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80de74:	83 ec 08             	sub    $0x8,%esp
  80de77:	ff 75 0c             	pushl  0xc(%ebp)
  80de7a:	8d 47 10             	lea    0x10(%edi),%eax
  80de7d:	50                   	push   %eax
  80de7e:	e8 4a 85 ff ff       	call   8063cd <ip_addr_isbroadcast>
  80de83:	83 c4 10             	add    $0x10,%esp
  80de86:	84 c0                	test   %al,%al
  80de88:	75 2d                	jne    80deb7 <icmp_input+0x99>
  80de8a:	8b 47 10             	mov    0x10(%edi),%eax
  80de8d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80de90:	83 ec 0c             	sub    $0xc,%esp
  80de93:	68 00 00 00 f0       	push   $0xf0000000
  80de98:	e8 73 99 ff ff       	call   807810 <ntohl>
  80de9d:	23 45 e0             	and    -0x20(%ebp),%eax
  80dea0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80dea3:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80deaa:	e8 61 99 ff ff       	call   807810 <ntohl>
  80deaf:	83 c4 10             	add    $0x10,%esp
  80deb2:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80deb5:	75 11                	jne    80dec8 <icmp_input+0xaa>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  80deb7:	83 ec 0c             	sub    $0xc,%esp
  80deba:	53                   	push   %ebx
  80debb:	e8 64 68 ff ff       	call   804724 <pbuf_free>
      return;
  80dec0:	83 c4 10             	add    $0x10,%esp
  80dec3:	e9 60 02 00 00       	jmp    80e128 <icmp_input+0x30a>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80dec8:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80decd:	0f 86 3b 02 00 00    	jbe    80e10e <icmp_input+0x2f0>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  80ded3:	83 ec 0c             	sub    $0xc,%esp
  80ded6:	53                   	push   %ebx
  80ded7:	e8 ea 95 ff ff       	call   8074c6 <inet_chksum_pbuf>
  80dedc:	83 c4 10             	add    $0x10,%esp
  80dedf:	66 85 c0             	test   %ax,%ax
  80dee2:	74 11                	je     80def5 <icmp_input+0xd7>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  80dee4:	83 ec 0c             	sub    $0xc,%esp
  80dee7:	53                   	push   %ebx
  80dee8:	e8 37 68 ff ff       	call   804724 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  80deed:	83 c4 10             	add    $0x10,%esp
  80def0:	e9 33 02 00 00       	jmp    80e128 <icmp_input+0x30a>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80def5:	83 ec 08             	sub    $0x8,%esp
  80def8:	6a 22                	push   $0x22
  80defa:	53                   	push   %ebx
  80defb:	e8 52 67 ff ff       	call   804652 <pbuf_header>
  80df00:	83 c4 10             	add    $0x10,%esp
  80df03:	84 c0                	test   %al,%al
  80df05:	0f 84 d7 00 00 00    	je     80dfe2 <icmp_input+0x1c4>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  80df0b:	83 ec 08             	sub    $0x8,%esp
  80df0e:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80df12:	50                   	push   %eax
  80df13:	53                   	push   %ebx
  80df14:	e8 39 67 ff ff       	call   804652 <pbuf_header>
  80df19:	83 c4 10             	add    $0x10,%esp
  80df1c:	84 c0                	test   %al,%al
  80df1e:	74 14                	je     80df34 <icmp_input+0x116>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80df20:	83 ec 04             	sub    $0x4,%esp
  80df23:	68 d8 2f 81 00       	push   $0x812fd8
  80df28:	6a 7b                	push   $0x7b
  80df2a:	68 cc 30 81 00       	push   $0x8130cc
  80df2f:	e8 24 04 00 00       	call   80e358 <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80df34:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80df38:	83 ec 04             	sub    $0x4,%esp
  80df3b:	6a 00                	push   $0x0
  80df3d:	50                   	push   %eax
  80df3e:	6a 02                	push   $0x2
  80df40:	e8 a5 68 ff ff       	call   8047ea <pbuf_alloc>
  80df45:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80df48:	83 c4 10             	add    $0x10,%esp
  80df4b:	85 c0                	test   %eax,%eax
  80df4d:	0f 84 c9 01 00 00    	je     80e11c <icmp_input+0x2fe>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80df53:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80df57:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80df5b:	83 c0 08             	add    $0x8,%eax
  80df5e:	39 c2                	cmp    %eax,%edx
  80df60:	73 17                	jae    80df79 <icmp_input+0x15b>
  80df62:	83 ec 04             	sub    $0x4,%esp
  80df65:	68 0c 30 81 00       	push   $0x81300c
  80df6a:	68 85 00 00 00       	push   $0x85
  80df6f:	68 cc 30 81 00       	push   $0x8130cc
  80df74:	e8 df 03 00 00       	call   80e358 <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  80df79:	83 ec 08             	sub    $0x8,%esp
  80df7c:	53                   	push   %ebx
  80df7d:	ff 75 e0             	pushl  -0x20(%ebp)
  80df80:	e8 63 6d ff ff       	call   804ce8 <pbuf_copy>
  80df85:	83 c4 10             	add    $0x10,%esp
  80df88:	84 c0                	test   %al,%al
  80df8a:	74 17                	je     80dfa3 <icmp_input+0x185>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80df8c:	83 ec 04             	sub    $0x4,%esp
  80df8f:	68 44 30 81 00       	push   $0x813044
  80df94:	68 88 00 00 00       	push   $0x88
  80df99:	68 cc 30 81 00       	push   $0x8130cc
  80df9e:	e8 b5 03 00 00       	call   80e358 <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  80dfa3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80dfa6:	8b 78 04             	mov    0x4(%eax),%edi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  80dfa9:	83 ec 08             	sub    $0x8,%esp
  80dfac:	56                   	push   %esi
  80dfad:	50                   	push   %eax
  80dfae:	e8 9f 66 ff ff       	call   804652 <pbuf_header>
  80dfb3:	83 c4 10             	add    $0x10,%esp
  80dfb6:	84 c0                	test   %al,%al
  80dfb8:	74 17                	je     80dfd1 <icmp_input+0x1b3>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80dfba:	83 ec 04             	sub    $0x4,%esp
  80dfbd:	68 6c 30 81 00       	push   $0x81306c
  80dfc2:	68 8e 00 00 00       	push   $0x8e
  80dfc7:	68 cc 30 81 00       	push   $0x8130cc
  80dfcc:	e8 87 03 00 00       	call   80e358 <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  80dfd1:	83 ec 0c             	sub    $0xc,%esp
  80dfd4:	53                   	push   %ebx
  80dfd5:	e8 4a 67 ff ff       	call   804724 <pbuf_free>
  80dfda:	83 c4 10             	add    $0x10,%esp
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  80dfdd:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80dfe0:	eb 29                	jmp    80e00b <icmp_input+0x1ed>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80dfe2:	83 ec 08             	sub    $0x8,%esp
  80dfe5:	6a de                	push   $0xffffffde
  80dfe7:	53                   	push   %ebx
  80dfe8:	e8 65 66 ff ff       	call   804652 <pbuf_header>
  80dfed:	83 c4 10             	add    $0x10,%esp
  80dff0:	84 c0                	test   %al,%al
  80dff2:	74 17                	je     80e00b <icmp_input+0x1ed>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80dff4:	83 ec 04             	sub    $0x4,%esp
  80dff7:	68 6c 30 81 00       	push   $0x81306c
  80dffc:	68 98 00 00 00       	push   $0x98
  80e001:	68 cc 30 81 00       	push   $0x8130cc
  80e006:	e8 4d 03 00 00       	call   80e358 <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  80e00b:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e00e:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e011:	8b 57 10             	mov    0x10(%edi),%edx
  80e014:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e017:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e01a:	83 ec 0c             	sub    $0xc,%esp
  80e01d:	0f b7 06             	movzwl (%esi),%eax
  80e020:	50                   	push   %eax
  80e021:	e8 bc 95 ff ff       	call   8075e2 <ntohs>
  80e026:	0f b6 c0             	movzbl %al,%eax
  80e029:	89 04 24             	mov    %eax,(%esp)
  80e02c:	e8 a4 95 ff ff       	call   8075d5 <htons>
  80e031:	66 89 06             	mov    %ax,(%esi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e034:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e038:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e03c:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e043:	e8 8d 95 ff ff       	call   8075d5 <htons>
  80e048:	83 c4 10             	add    $0x10,%esp
  80e04b:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e04f:	72 1c                	jb     80e06d <icmp_input+0x24f>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e051:	83 ec 0c             	sub    $0xc,%esp
  80e054:	68 00 08 00 00       	push   $0x800
  80e059:	e8 77 95 ff ff       	call   8075d5 <htons>
  80e05e:	0f b7 c0             	movzwl %ax,%eax
  80e061:	83 c0 01             	add    $0x1,%eax
  80e064:	66 01 46 02          	add    %ax,0x2(%esi)
  80e068:	83 c4 10             	add    $0x10,%esp
  80e06b:	eb 14                	jmp    80e081 <icmp_input+0x263>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e06d:	83 ec 0c             	sub    $0xc,%esp
  80e070:	68 00 08 00 00       	push   $0x800
  80e075:	e8 5b 95 ff ff       	call   8075d5 <htons>
  80e07a:	66 01 46 02          	add    %ax,0x2(%esi)
  80e07e:	83 c4 10             	add    $0x10,%esp
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e081:	83 ec 0c             	sub    $0xc,%esp
  80e084:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e088:	50                   	push   %eax
  80e089:	e8 54 95 ff ff       	call   8075e2 <ntohs>
  80e08e:	66 0d 00 ff          	or     $0xff00,%ax
  80e092:	0f b7 c0             	movzwl %ax,%eax
  80e095:	89 04 24             	mov    %eax,(%esp)
  80e098:	e8 38 95 ff ff       	call   8075d5 <htons>
  80e09d:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e0a1:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e0a7:	83 c4 08             	add    $0x8,%esp
  80e0aa:	6a 14                	push   $0x14
  80e0ac:	57                   	push   %edi
  80e0ad:	e8 fe 93 ff ff       	call   8074b0 <inet_chksum>
  80e0b2:	66 89 47 0a          	mov    %ax,0xa(%edi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  80e0b6:	83 c4 08             	add    $0x8,%esp
  80e0b9:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e0bd:	50                   	push   %eax
  80e0be:	53                   	push   %ebx
  80e0bf:	e8 8e 65 ff ff       	call   804652 <pbuf_header>
  80e0c4:	83 c4 10             	add    $0x10,%esp
  80e0c7:	84 c0                	test   %al,%al
  80e0c9:	74 17                	je     80e0e2 <icmp_input+0x2c4>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e0cb:	83 ec 04             	sub    $0x4,%esp
  80e0ce:	68 34 21 81 00       	push   $0x812134
  80e0d3:	68 b9 00 00 00       	push   $0xb9
  80e0d8:	68 cc 30 81 00       	push   $0x8130cc
  80e0dd:	e8 76 02 00 00       	call   80e358 <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e0e2:	83 ec 04             	sub    $0x4,%esp
  80e0e5:	ff 75 0c             	pushl  0xc(%ebp)
  80e0e8:	6a 01                	push   $0x1
  80e0ea:	6a 00                	push   $0x0
  80e0ec:	68 ff 00 00 00       	push   $0xff
  80e0f1:	6a 00                	push   $0x0
  80e0f3:	83 c7 0c             	add    $0xc,%edi
  80e0f6:	57                   	push   %edi
  80e0f7:	53                   	push   %ebx
  80e0f8:	e8 7e 86 ff ff       	call   80677b <ip_output_if>
  80e0fd:	83 c4 20             	add    $0x20,%esp
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80e100:	83 ec 0c             	sub    $0xc,%esp
  80e103:	53                   	push   %ebx
  80e104:	e8 1b 66 ff ff       	call   804724 <pbuf_free>
  return;
  80e109:	83 c4 10             	add    $0x10,%esp
  80e10c:	eb 1a                	jmp    80e128 <icmp_input+0x30a>
lenerr:
  pbuf_free(p);
  80e10e:	83 ec 0c             	sub    $0xc,%esp
  80e111:	53                   	push   %ebx
  80e112:	e8 0d 66 ff ff       	call   804724 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e117:	83 c4 10             	add    $0x10,%esp
  80e11a:	eb 0c                	jmp    80e128 <icmp_input+0x30a>
memerr:
  pbuf_free(p);
  80e11c:	83 ec 0c             	sub    $0xc,%esp
  80e11f:	53                   	push   %ebx
  80e120:	e8 ff 65 ff ff       	call   804724 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
  80e125:	83 c4 10             	add    $0x10,%esp
}
  80e128:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e12b:	5b                   	pop    %ebx
  80e12c:	5e                   	pop    %esi
  80e12d:	5f                   	pop    %edi
  80e12e:	5d                   	pop    %ebp
  80e12f:	c3                   	ret    

0080e130 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e130:	55                   	push   %ebp
  80e131:	89 e5                	mov    %esp,%ebp
  80e133:	57                   	push   %edi
  80e134:	56                   	push   %esi
  80e135:	53                   	push   %ebx
  80e136:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e139:	6a 00                	push   $0x0
  80e13b:	6a 24                	push   $0x24
  80e13d:	6a 01                	push   $0x1
  80e13f:	e8 a6 66 ff ff       	call   8047ea <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e144:	83 c4 10             	add    $0x10,%esp
  80e147:	85 c0                	test   %eax,%eax
  80e149:	0f 84 b8 00 00 00    	je     80e207 <icmp_dest_unreach+0xd7>
  80e14f:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e151:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e156:	77 17                	ja     80e16f <icmp_dest_unreach+0x3f>
  80e158:	83 ec 04             	sub    $0x4,%esp
  80e15b:	68 a0 30 81 00       	push   $0x8130a0
  80e160:	68 ef 00 00 00       	push   $0xef
  80e165:	68 cc 30 81 00       	push   $0x8130cc
  80e16a:	e8 e9 01 00 00       	call   80e358 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e16f:	8b 45 08             	mov    0x8(%ebp),%eax
  80e172:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e175:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e178:	83 ec 0c             	sub    $0xc,%esp
  80e17b:	0f b7 06             	movzwl (%esi),%eax
  80e17e:	50                   	push   %eax
  80e17f:	e8 5e 94 ff ff       	call   8075e2 <ntohs>
  80e184:	0f b6 c0             	movzbl %al,%eax
  80e187:	80 cc 03             	or     $0x3,%ah
  80e18a:	89 04 24             	mov    %eax,(%esp)
  80e18d:	e8 43 94 ff ff       	call   8075d5 <htons>
  80e192:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e195:	0f b7 c0             	movzwl %ax,%eax
  80e198:	89 04 24             	mov    %eax,(%esp)
  80e19b:	e8 42 94 ff ff       	call   8075e2 <ntohs>
  80e1a0:	b0 00                	mov    $0x0,%al
  80e1a2:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e1a6:	0f b7 c0             	movzwl %ax,%eax
  80e1a9:	89 04 24             	mov    %eax,(%esp)
  80e1ac:	e8 24 94 ff ff       	call   8075d5 <htons>
  80e1b1:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e1b4:	83 c4 0c             	add    $0xc,%esp
  80e1b7:	6a 1c                	push   $0x1c
  80e1b9:	8b 45 08             	mov    0x8(%ebp),%eax
  80e1bc:	ff 70 04             	pushl  0x4(%eax)
  80e1bf:	8b 43 04             	mov    0x4(%ebx),%eax
  80e1c2:	83 c0 08             	add    $0x8,%eax
  80e1c5:	50                   	push   %eax
  80e1c6:	e8 e5 09 00 00       	call   80ebb0 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e1cb:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e1d1:	83 c4 08             	add    $0x8,%esp
  80e1d4:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e1d8:	50                   	push   %eax
  80e1d9:	56                   	push   %esi
  80e1da:	e8 d1 92 ff ff       	call   8074b0 <inet_chksum>
  80e1df:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e1e3:	83 c4 08             	add    $0x8,%esp
  80e1e6:	6a 01                	push   $0x1
  80e1e8:	6a 00                	push   $0x0
  80e1ea:	68 ff 00 00 00       	push   $0xff
  80e1ef:	83 c7 0c             	add    $0xc,%edi
  80e1f2:	57                   	push   %edi
  80e1f3:	6a 00                	push   $0x0
  80e1f5:	53                   	push   %ebx
  80e1f6:	e8 08 87 ff ff       	call   806903 <ip_output>
  pbuf_free(q);
  80e1fb:	83 c4 14             	add    $0x14,%esp
  80e1fe:	53                   	push   %ebx
  80e1ff:	e8 20 65 ff ff       	call   804724 <pbuf_free>
  80e204:	83 c4 10             	add    $0x10,%esp
}
  80e207:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e20a:	5b                   	pop    %ebx
  80e20b:	5e                   	pop    %esi
  80e20c:	5f                   	pop    %edi
  80e20d:	5d                   	pop    %ebp
  80e20e:	c3                   	ret    

0080e20f <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e20f:	55                   	push   %ebp
  80e210:	89 e5                	mov    %esp,%ebp
  80e212:	57                   	push   %edi
  80e213:	56                   	push   %esi
  80e214:	53                   	push   %ebx
  80e215:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e218:	6a 00                	push   $0x0
  80e21a:	6a 24                	push   $0x24
  80e21c:	6a 01                	push   $0x1
  80e21e:	e8 c7 65 ff ff       	call   8047ea <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e223:	83 c4 10             	add    $0x10,%esp
  80e226:	85 c0                	test   %eax,%eax
  80e228:	0f 84 b8 00 00 00    	je     80e2e6 <icmp_time_exceeded+0xd7>
  80e22e:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e230:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e235:	77 17                	ja     80e24e <icmp_time_exceeded+0x3f>
  80e237:	83 ec 04             	sub    $0x4,%esp
  80e23a:	68 a0 30 81 00       	push   $0x8130a0
  80e23f:	68 1e 01 00 00       	push   $0x11e
  80e244:	68 cc 30 81 00       	push   $0x8130cc
  80e249:	e8 0a 01 00 00       	call   80e358 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e24e:	8b 45 08             	mov    0x8(%ebp),%eax
  80e251:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e254:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e257:	83 ec 0c             	sub    $0xc,%esp
  80e25a:	0f b7 06             	movzwl (%esi),%eax
  80e25d:	50                   	push   %eax
  80e25e:	e8 7f 93 ff ff       	call   8075e2 <ntohs>
  80e263:	0f b6 c0             	movzbl %al,%eax
  80e266:	80 cc 0b             	or     $0xb,%ah
  80e269:	89 04 24             	mov    %eax,(%esp)
  80e26c:	e8 64 93 ff ff       	call   8075d5 <htons>
  80e271:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e274:	0f b7 c0             	movzwl %ax,%eax
  80e277:	89 04 24             	mov    %eax,(%esp)
  80e27a:	e8 63 93 ff ff       	call   8075e2 <ntohs>
  80e27f:	b0 00                	mov    $0x0,%al
  80e281:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e285:	0f b7 c0             	movzwl %ax,%eax
  80e288:	89 04 24             	mov    %eax,(%esp)
  80e28b:	e8 45 93 ff ff       	call   8075d5 <htons>
  80e290:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e293:	83 c4 0c             	add    $0xc,%esp
  80e296:	6a 1c                	push   $0x1c
  80e298:	8b 45 08             	mov    0x8(%ebp),%eax
  80e29b:	ff 70 04             	pushl  0x4(%eax)
  80e29e:	8b 43 04             	mov    0x4(%ebx),%eax
  80e2a1:	83 c0 08             	add    $0x8,%eax
  80e2a4:	50                   	push   %eax
  80e2a5:	e8 06 09 00 00       	call   80ebb0 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e2aa:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e2b0:	83 c4 08             	add    $0x8,%esp
  80e2b3:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e2b7:	50                   	push   %eax
  80e2b8:	56                   	push   %esi
  80e2b9:	e8 f2 91 ff ff       	call   8074b0 <inet_chksum>
  80e2be:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e2c2:	83 c4 08             	add    $0x8,%esp
  80e2c5:	6a 01                	push   $0x1
  80e2c7:	6a 00                	push   $0x0
  80e2c9:	68 ff 00 00 00       	push   $0xff
  80e2ce:	83 c7 0c             	add    $0xc,%edi
  80e2d1:	57                   	push   %edi
  80e2d2:	6a 00                	push   $0x0
  80e2d4:	53                   	push   %ebx
  80e2d5:	e8 29 86 ff ff       	call   806903 <ip_output>
  pbuf_free(q);
  80e2da:	83 c4 14             	add    $0x14,%esp
  80e2dd:	53                   	push   %ebx
  80e2de:	e8 41 64 ff ff       	call   804724 <pbuf_free>
  80e2e3:	83 c4 10             	add    $0x10,%esp
}
  80e2e6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e2e9:	5b                   	pop    %ebx
  80e2ea:	5e                   	pop    %esi
  80e2eb:	5f                   	pop    %edi
  80e2ec:	5d                   	pop    %ebp
  80e2ed:	c3                   	ret    

0080e2ee <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80e2ee:	55                   	push   %ebp
  80e2ef:	89 e5                	mov    %esp,%ebp
  80e2f1:	56                   	push   %esi
  80e2f2:	53                   	push   %ebx
  80e2f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e2f6:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = 0;
  80e2f9:	c7 05 5c b2 b3 00 00 	movl   $0x0,0xb3b25c
  80e300:	00 00 00 
	thisenv = &envs[ENVX(sys_getenvid())];
  80e303:	e8 73 0a 00 00       	call   80ed7b <sys_getenvid>
  80e308:	25 ff 03 00 00       	and    $0x3ff,%eax
  80e30d:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80e310:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80e315:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e31a:	85 db                	test   %ebx,%ebx
  80e31c:	7e 07                	jle    80e325 <libmain+0x37>
		binaryname = argv[0];
  80e31e:	8b 06                	mov    (%esi),%eax
  80e320:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	// call user main routine
	umain(argc, argv);
  80e325:	83 ec 08             	sub    $0x8,%esp
  80e328:	56                   	push   %esi
  80e329:	53                   	push   %ebx
  80e32a:	e8 2a 22 ff ff       	call   800559 <umain>

	// exit gracefully
	exit();
  80e32f:	e8 0a 00 00 00       	call   80e33e <exit>
}
  80e334:	83 c4 10             	add    $0x10,%esp
  80e337:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e33a:	5b                   	pop    %ebx
  80e33b:	5e                   	pop    %esi
  80e33c:	5d                   	pop    %ebp
  80e33d:	c3                   	ret    

0080e33e <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e33e:	55                   	push   %ebp
  80e33f:	89 e5                	mov    %esp,%ebp
  80e341:	83 ec 08             	sub    $0x8,%esp
	close_all();
  80e344:	e8 75 12 00 00       	call   80f5be <close_all>
	sys_env_destroy(0);
  80e349:	83 ec 0c             	sub    $0xc,%esp
  80e34c:	6a 00                	push   $0x0
  80e34e:	e8 e7 09 00 00       	call   80ed3a <sys_env_destroy>
}
  80e353:	83 c4 10             	add    $0x10,%esp
  80e356:	c9                   	leave  
  80e357:	c3                   	ret    

0080e358 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e358:	55                   	push   %ebp
  80e359:	89 e5                	mov    %esp,%ebp
  80e35b:	56                   	push   %esi
  80e35c:	53                   	push   %ebx
	va_list ap;

	va_start(ap, fmt);
  80e35d:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e360:	8b 35 e8 42 81 00    	mov    0x8142e8,%esi
  80e366:	e8 10 0a 00 00       	call   80ed7b <sys_getenvid>
  80e36b:	83 ec 0c             	sub    $0xc,%esp
  80e36e:	ff 75 0c             	pushl  0xc(%ebp)
  80e371:	ff 75 08             	pushl  0x8(%ebp)
  80e374:	56                   	push   %esi
  80e375:	50                   	push   %eax
  80e376:	68 f0 30 81 00       	push   $0x8130f0
  80e37b:	e8 b1 00 00 00       	call   80e431 <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e380:	83 c4 18             	add    $0x18,%esp
  80e383:	53                   	push   %ebx
  80e384:	ff 75 10             	pushl  0x10(%ebp)
  80e387:	e8 54 00 00 00       	call   80e3e0 <vcprintf>
	cprintf("\n");
  80e38c:	c7 04 24 7a 34 81 00 	movl   $0x81347a,(%esp)
  80e393:	e8 99 00 00 00       	call   80e431 <cprintf>
  80e398:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e39b:	cc                   	int3   
  80e39c:	eb fd                	jmp    80e39b <_panic+0x43>

0080e39e <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e39e:	55                   	push   %ebp
  80e39f:	89 e5                	mov    %esp,%ebp
  80e3a1:	53                   	push   %ebx
  80e3a2:	83 ec 04             	sub    $0x4,%esp
  80e3a5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e3a8:	8b 13                	mov    (%ebx),%edx
  80e3aa:	8d 42 01             	lea    0x1(%edx),%eax
  80e3ad:	89 03                	mov    %eax,(%ebx)
  80e3af:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e3b2:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e3b6:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e3bb:	75 1a                	jne    80e3d7 <putch+0x39>
		sys_cputs(b->buf, b->idx);
  80e3bd:	83 ec 08             	sub    $0x8,%esp
  80e3c0:	68 ff 00 00 00       	push   $0xff
  80e3c5:	8d 43 08             	lea    0x8(%ebx),%eax
  80e3c8:	50                   	push   %eax
  80e3c9:	e8 2f 09 00 00       	call   80ecfd <sys_cputs>
		b->idx = 0;
  80e3ce:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e3d4:	83 c4 10             	add    $0x10,%esp
	}
	b->cnt++;
  80e3d7:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e3db:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e3de:	c9                   	leave  
  80e3df:	c3                   	ret    

0080e3e0 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e3e0:	55                   	push   %ebp
  80e3e1:	89 e5                	mov    %esp,%ebp
  80e3e3:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e3e9:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e3f0:	00 00 00 
	b.cnt = 0;
  80e3f3:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e3fa:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e3fd:	ff 75 0c             	pushl  0xc(%ebp)
  80e400:	ff 75 08             	pushl  0x8(%ebp)
  80e403:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e409:	50                   	push   %eax
  80e40a:	68 9e e3 80 00       	push   $0x80e39e
  80e40f:	e8 54 01 00 00       	call   80e568 <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80e414:	83 c4 08             	add    $0x8,%esp
  80e417:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80e41d:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80e423:	50                   	push   %eax
  80e424:	e8 d4 08 00 00       	call   80ecfd <sys_cputs>

	return b.cnt;
}
  80e429:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80e42f:	c9                   	leave  
  80e430:	c3                   	ret    

0080e431 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80e431:	55                   	push   %ebp
  80e432:	89 e5                	mov    %esp,%ebp
  80e434:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80e437:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80e43a:	50                   	push   %eax
  80e43b:	ff 75 08             	pushl  0x8(%ebp)
  80e43e:	e8 9d ff ff ff       	call   80e3e0 <vcprintf>
	va_end(ap);

	return cnt;
}
  80e443:	c9                   	leave  
  80e444:	c3                   	ret    

0080e445 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80e445:	55                   	push   %ebp
  80e446:	89 e5                	mov    %esp,%ebp
  80e448:	57                   	push   %edi
  80e449:	56                   	push   %esi
  80e44a:	53                   	push   %ebx
  80e44b:	83 ec 1c             	sub    $0x1c,%esp
  80e44e:	89 c7                	mov    %eax,%edi
  80e450:	89 d6                	mov    %edx,%esi
  80e452:	8b 45 08             	mov    0x8(%ebp),%eax
  80e455:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e458:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e45b:	89 55 dc             	mov    %edx,-0x24(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80e45e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80e461:	bb 00 00 00 00       	mov    $0x0,%ebx
  80e466:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80e469:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80e46c:	39 d3                	cmp    %edx,%ebx
  80e46e:	72 05                	jb     80e475 <printnum+0x30>
  80e470:	39 45 10             	cmp    %eax,0x10(%ebp)
  80e473:	77 45                	ja     80e4ba <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80e475:	83 ec 0c             	sub    $0xc,%esp
  80e478:	ff 75 18             	pushl  0x18(%ebp)
  80e47b:	8b 45 14             	mov    0x14(%ebp),%eax
  80e47e:	8d 58 ff             	lea    -0x1(%eax),%ebx
  80e481:	53                   	push   %ebx
  80e482:	ff 75 10             	pushl  0x10(%ebp)
  80e485:	83 ec 08             	sub    $0x8,%esp
  80e488:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e48b:	ff 75 e0             	pushl  -0x20(%ebp)
  80e48e:	ff 75 dc             	pushl  -0x24(%ebp)
  80e491:	ff 75 d8             	pushl  -0x28(%ebp)
  80e494:	e8 17 24 00 00       	call   8108b0 <__udivdi3>
  80e499:	83 c4 18             	add    $0x18,%esp
  80e49c:	52                   	push   %edx
  80e49d:	50                   	push   %eax
  80e49e:	89 f2                	mov    %esi,%edx
  80e4a0:	89 f8                	mov    %edi,%eax
  80e4a2:	e8 9e ff ff ff       	call   80e445 <printnum>
  80e4a7:	83 c4 20             	add    $0x20,%esp
  80e4aa:	eb 18                	jmp    80e4c4 <printnum+0x7f>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80e4ac:	83 ec 08             	sub    $0x8,%esp
  80e4af:	56                   	push   %esi
  80e4b0:	ff 75 18             	pushl  0x18(%ebp)
  80e4b3:	ff d7                	call   *%edi
  80e4b5:	83 c4 10             	add    $0x10,%esp
  80e4b8:	eb 03                	jmp    80e4bd <printnum+0x78>
  80e4ba:	8b 5d 14             	mov    0x14(%ebp),%ebx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80e4bd:	83 eb 01             	sub    $0x1,%ebx
  80e4c0:	85 db                	test   %ebx,%ebx
  80e4c2:	7f e8                	jg     80e4ac <printnum+0x67>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80e4c4:	83 ec 08             	sub    $0x8,%esp
  80e4c7:	56                   	push   %esi
  80e4c8:	83 ec 04             	sub    $0x4,%esp
  80e4cb:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e4ce:	ff 75 e0             	pushl  -0x20(%ebp)
  80e4d1:	ff 75 dc             	pushl  -0x24(%ebp)
  80e4d4:	ff 75 d8             	pushl  -0x28(%ebp)
  80e4d7:	e8 04 25 00 00       	call   8109e0 <__umoddi3>
  80e4dc:	83 c4 14             	add    $0x14,%esp
  80e4df:	0f be 80 13 31 81 00 	movsbl 0x813113(%eax),%eax
  80e4e6:	50                   	push   %eax
  80e4e7:	ff d7                	call   *%edi
}
  80e4e9:	83 c4 10             	add    $0x10,%esp
  80e4ec:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e4ef:	5b                   	pop    %ebx
  80e4f0:	5e                   	pop    %esi
  80e4f1:	5f                   	pop    %edi
  80e4f2:	5d                   	pop    %ebp
  80e4f3:	c3                   	ret    

0080e4f4 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  80e4f4:	55                   	push   %ebp
  80e4f5:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  80e4f7:	83 fa 01             	cmp    $0x1,%edx
  80e4fa:	7e 0e                	jle    80e50a <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  80e4fc:	8b 10                	mov    (%eax),%edx
  80e4fe:	8d 4a 08             	lea    0x8(%edx),%ecx
  80e501:	89 08                	mov    %ecx,(%eax)
  80e503:	8b 02                	mov    (%edx),%eax
  80e505:	8b 52 04             	mov    0x4(%edx),%edx
  80e508:	eb 22                	jmp    80e52c <getuint+0x38>
	else if (lflag)
  80e50a:	85 d2                	test   %edx,%edx
  80e50c:	74 10                	je     80e51e <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  80e50e:	8b 10                	mov    (%eax),%edx
  80e510:	8d 4a 04             	lea    0x4(%edx),%ecx
  80e513:	89 08                	mov    %ecx,(%eax)
  80e515:	8b 02                	mov    (%edx),%eax
  80e517:	ba 00 00 00 00       	mov    $0x0,%edx
  80e51c:	eb 0e                	jmp    80e52c <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  80e51e:	8b 10                	mov    (%eax),%edx
  80e520:	8d 4a 04             	lea    0x4(%edx),%ecx
  80e523:	89 08                	mov    %ecx,(%eax)
  80e525:	8b 02                	mov    (%edx),%eax
  80e527:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80e52c:	5d                   	pop    %ebp
  80e52d:	c3                   	ret    

0080e52e <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80e52e:	55                   	push   %ebp
  80e52f:	89 e5                	mov    %esp,%ebp
  80e531:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80e534:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80e538:	8b 10                	mov    (%eax),%edx
  80e53a:	3b 50 04             	cmp    0x4(%eax),%edx
  80e53d:	73 0a                	jae    80e549 <sprintputch+0x1b>
		*b->buf++ = ch;
  80e53f:	8d 4a 01             	lea    0x1(%edx),%ecx
  80e542:	89 08                	mov    %ecx,(%eax)
  80e544:	8b 45 08             	mov    0x8(%ebp),%eax
  80e547:	88 02                	mov    %al,(%edx)
}
  80e549:	5d                   	pop    %ebp
  80e54a:	c3                   	ret    

0080e54b <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  80e54b:	55                   	push   %ebp
  80e54c:	89 e5                	mov    %esp,%ebp
  80e54e:	83 ec 08             	sub    $0x8,%esp
	va_list ap;

	va_start(ap, fmt);
  80e551:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80e554:	50                   	push   %eax
  80e555:	ff 75 10             	pushl  0x10(%ebp)
  80e558:	ff 75 0c             	pushl  0xc(%ebp)
  80e55b:	ff 75 08             	pushl  0x8(%ebp)
  80e55e:	e8 05 00 00 00       	call   80e568 <vprintfmt>
	va_end(ap);
}
  80e563:	83 c4 10             	add    $0x10,%esp
  80e566:	c9                   	leave  
  80e567:	c3                   	ret    

0080e568 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80e568:	55                   	push   %ebp
  80e569:	89 e5                	mov    %esp,%ebp
  80e56b:	57                   	push   %edi
  80e56c:	56                   	push   %esi
  80e56d:	53                   	push   %ebx
  80e56e:	83 ec 2c             	sub    $0x2c,%esp
  80e571:	8b 75 08             	mov    0x8(%ebp),%esi
  80e574:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e577:	8b 7d 10             	mov    0x10(%ebp),%edi
  80e57a:	eb 12                	jmp    80e58e <vprintfmt+0x26>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  80e57c:	85 c0                	test   %eax,%eax
  80e57e:	0f 84 89 03 00 00    	je     80e90d <vprintfmt+0x3a5>
				return;
			putch(ch, putdat);
  80e584:	83 ec 08             	sub    $0x8,%esp
  80e587:	53                   	push   %ebx
  80e588:	50                   	push   %eax
  80e589:	ff d6                	call   *%esi
  80e58b:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80e58e:	83 c7 01             	add    $0x1,%edi
  80e591:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e595:	83 f8 25             	cmp    $0x25,%eax
  80e598:	75 e2                	jne    80e57c <vprintfmt+0x14>
  80e59a:	c6 45 d4 20          	movb   $0x20,-0x2c(%ebp)
  80e59e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80e5a5:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  80e5ac:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
  80e5b3:	ba 00 00 00 00       	mov    $0x0,%edx
  80e5b8:	eb 07                	jmp    80e5c1 <vprintfmt+0x59>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e5ba:	8b 7d e4             	mov    -0x1c(%ebp),%edi

		// flag to pad on the right
		case '-':
			padc = '-';
  80e5bd:	c6 45 d4 2d          	movb   $0x2d,-0x2c(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e5c1:	8d 47 01             	lea    0x1(%edi),%eax
  80e5c4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80e5c7:	0f b6 07             	movzbl (%edi),%eax
  80e5ca:	0f b6 c8             	movzbl %al,%ecx
  80e5cd:	83 e8 23             	sub    $0x23,%eax
  80e5d0:	3c 55                	cmp    $0x55,%al
  80e5d2:	0f 87 1a 03 00 00    	ja     80e8f2 <vprintfmt+0x38a>
  80e5d8:	0f b6 c0             	movzbl %al,%eax
  80e5db:	ff 24 85 60 32 81 00 	jmp    *0x813260(,%eax,4)
  80e5e2:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
			goto reswitch;

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  80e5e5:	c6 45 d4 30          	movb   $0x30,-0x2c(%ebp)
  80e5e9:	eb d6                	jmp    80e5c1 <vprintfmt+0x59>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e5eb:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e5ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80e5f3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  80e5f6:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80e5f9:	8d 44 41 d0          	lea    -0x30(%ecx,%eax,2),%eax
				ch = *fmt;
  80e5fd:	0f be 0f             	movsbl (%edi),%ecx
				if (ch < '0' || ch > '9')
  80e600:	8d 51 d0             	lea    -0x30(%ecx),%edx
  80e603:	83 fa 09             	cmp    $0x9,%edx
  80e606:	77 39                	ja     80e641 <vprintfmt+0xd9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80e608:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80e60b:	eb e9                	jmp    80e5f6 <vprintfmt+0x8e>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  80e60d:	8b 45 14             	mov    0x14(%ebp),%eax
  80e610:	8d 48 04             	lea    0x4(%eax),%ecx
  80e613:	89 4d 14             	mov    %ecx,0x14(%ebp)
  80e616:	8b 00                	mov    (%eax),%eax
  80e618:	89 45 d0             	mov    %eax,-0x30(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e61b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
			goto process_precision;
  80e61e:	eb 27                	jmp    80e647 <vprintfmt+0xdf>
  80e620:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e623:	85 c0                	test   %eax,%eax
  80e625:	b9 00 00 00 00       	mov    $0x0,%ecx
  80e62a:	0f 49 c8             	cmovns %eax,%ecx
  80e62d:	89 4d e0             	mov    %ecx,-0x20(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e630:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e633:	eb 8c                	jmp    80e5c1 <vprintfmt+0x59>
  80e635:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
  80e638:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
			goto reswitch;
  80e63f:	eb 80                	jmp    80e5c1 <vprintfmt+0x59>
  80e641:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80e644:	89 45 d0             	mov    %eax,-0x30(%ebp)

		process_precision:
			if (width < 0)
  80e647:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e64b:	0f 89 70 ff ff ff    	jns    80e5c1 <vprintfmt+0x59>
				width = precision, precision = -1;
  80e651:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80e654:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e657:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  80e65e:	e9 5e ff ff ff       	jmp    80e5c1 <vprintfmt+0x59>
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  80e663:	83 c2 01             	add    $0x1,%edx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e666:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
			goto reswitch;
  80e669:	e9 53 ff ff ff       	jmp    80e5c1 <vprintfmt+0x59>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  80e66e:	8b 45 14             	mov    0x14(%ebp),%eax
  80e671:	8d 50 04             	lea    0x4(%eax),%edx
  80e674:	89 55 14             	mov    %edx,0x14(%ebp)
  80e677:	83 ec 08             	sub    $0x8,%esp
  80e67a:	53                   	push   %ebx
  80e67b:	ff 30                	pushl  (%eax)
  80e67d:	ff d6                	call   *%esi
			break;
  80e67f:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e682:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
			break;
  80e685:	e9 04 ff ff ff       	jmp    80e58e <vprintfmt+0x26>

		// error message
		case 'e':
			err = va_arg(ap, int);
  80e68a:	8b 45 14             	mov    0x14(%ebp),%eax
  80e68d:	8d 50 04             	lea    0x4(%eax),%edx
  80e690:	89 55 14             	mov    %edx,0x14(%ebp)
  80e693:	8b 00                	mov    (%eax),%eax
  80e695:	99                   	cltd   
  80e696:	31 d0                	xor    %edx,%eax
  80e698:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80e69a:	83 f8 0f             	cmp    $0xf,%eax
  80e69d:	7f 0b                	jg     80e6aa <vprintfmt+0x142>
  80e69f:	8b 14 85 c0 33 81 00 	mov    0x8133c0(,%eax,4),%edx
  80e6a6:	85 d2                	test   %edx,%edx
  80e6a8:	75 18                	jne    80e6c2 <vprintfmt+0x15a>
				printfmt(putch, putdat, "error %d", err);
  80e6aa:	50                   	push   %eax
  80e6ab:	68 2b 31 81 00       	push   $0x81312b
  80e6b0:	53                   	push   %ebx
  80e6b1:	56                   	push   %esi
  80e6b2:	e8 94 fe ff ff       	call   80e54b <printfmt>
  80e6b7:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e6ba:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		case 'e':
			err = va_arg(ap, int);
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
  80e6bd:	e9 cc fe ff ff       	jmp    80e58e <vprintfmt+0x26>
			else
				printfmt(putch, putdat, "%s", p);
  80e6c2:	52                   	push   %edx
  80e6c3:	68 f9 22 81 00       	push   $0x8122f9
  80e6c8:	53                   	push   %ebx
  80e6c9:	56                   	push   %esi
  80e6ca:	e8 7c fe ff ff       	call   80e54b <printfmt>
  80e6cf:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e6d2:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e6d5:	e9 b4 fe ff ff       	jmp    80e58e <vprintfmt+0x26>
				printfmt(putch, putdat, "%s", p);
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  80e6da:	8b 45 14             	mov    0x14(%ebp),%eax
  80e6dd:	8d 50 04             	lea    0x4(%eax),%edx
  80e6e0:	89 55 14             	mov    %edx,0x14(%ebp)
  80e6e3:	8b 38                	mov    (%eax),%edi
				p = "(null)";
  80e6e5:	85 ff                	test   %edi,%edi
  80e6e7:	b8 24 31 81 00       	mov    $0x813124,%eax
  80e6ec:	0f 44 f8             	cmove  %eax,%edi
			if (width > 0 && padc != '-')
  80e6ef:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e6f3:	0f 8e 94 00 00 00    	jle    80e78d <vprintfmt+0x225>
  80e6f9:	80 7d d4 2d          	cmpb   $0x2d,-0x2c(%ebp)
  80e6fd:	0f 84 98 00 00 00    	je     80e79b <vprintfmt+0x233>
				for (width -= strnlen(p, precision); width > 0; width--)
  80e703:	83 ec 08             	sub    $0x8,%esp
  80e706:	ff 75 d0             	pushl  -0x30(%ebp)
  80e709:	57                   	push   %edi
  80e70a:	e8 86 02 00 00       	call   80e995 <strnlen>
  80e70f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e712:	29 c1                	sub    %eax,%ecx
  80e714:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  80e717:	83 c4 10             	add    $0x10,%esp
					putch(padc, putdat);
  80e71a:	0f be 45 d4          	movsbl -0x2c(%ebp),%eax
  80e71e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e721:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  80e724:	89 cf                	mov    %ecx,%edi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80e726:	eb 0f                	jmp    80e737 <vprintfmt+0x1cf>
					putch(padc, putdat);
  80e728:	83 ec 08             	sub    $0x8,%esp
  80e72b:	53                   	push   %ebx
  80e72c:	ff 75 e0             	pushl  -0x20(%ebp)
  80e72f:	ff d6                	call   *%esi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80e731:	83 ef 01             	sub    $0x1,%edi
  80e734:	83 c4 10             	add    $0x10,%esp
  80e737:	85 ff                	test   %edi,%edi
  80e739:	7f ed                	jg     80e728 <vprintfmt+0x1c0>
  80e73b:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  80e73e:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  80e741:	85 c9                	test   %ecx,%ecx
  80e743:	b8 00 00 00 00       	mov    $0x0,%eax
  80e748:	0f 49 c1             	cmovns %ecx,%eax
  80e74b:	29 c1                	sub    %eax,%ecx
  80e74d:	89 75 08             	mov    %esi,0x8(%ebp)
  80e750:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e753:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e756:	89 cb                	mov    %ecx,%ebx
  80e758:	eb 4d                	jmp    80e7a7 <vprintfmt+0x23f>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  80e75a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80e75e:	74 1b                	je     80e77b <vprintfmt+0x213>
  80e760:	0f be c0             	movsbl %al,%eax
  80e763:	83 e8 20             	sub    $0x20,%eax
  80e766:	83 f8 5e             	cmp    $0x5e,%eax
  80e769:	76 10                	jbe    80e77b <vprintfmt+0x213>
					putch('?', putdat);
  80e76b:	83 ec 08             	sub    $0x8,%esp
  80e76e:	ff 75 0c             	pushl  0xc(%ebp)
  80e771:	6a 3f                	push   $0x3f
  80e773:	ff 55 08             	call   *0x8(%ebp)
  80e776:	83 c4 10             	add    $0x10,%esp
  80e779:	eb 0d                	jmp    80e788 <vprintfmt+0x220>
				else
					putch(ch, putdat);
  80e77b:	83 ec 08             	sub    $0x8,%esp
  80e77e:	ff 75 0c             	pushl  0xc(%ebp)
  80e781:	52                   	push   %edx
  80e782:	ff 55 08             	call   *0x8(%ebp)
  80e785:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80e788:	83 eb 01             	sub    $0x1,%ebx
  80e78b:	eb 1a                	jmp    80e7a7 <vprintfmt+0x23f>
  80e78d:	89 75 08             	mov    %esi,0x8(%ebp)
  80e790:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e793:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e796:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e799:	eb 0c                	jmp    80e7a7 <vprintfmt+0x23f>
  80e79b:	89 75 08             	mov    %esi,0x8(%ebp)
  80e79e:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80e7a1:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  80e7a4:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e7a7:	83 c7 01             	add    $0x1,%edi
  80e7aa:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e7ae:	0f be d0             	movsbl %al,%edx
  80e7b1:	85 d2                	test   %edx,%edx
  80e7b3:	74 23                	je     80e7d8 <vprintfmt+0x270>
  80e7b5:	85 f6                	test   %esi,%esi
  80e7b7:	78 a1                	js     80e75a <vprintfmt+0x1f2>
  80e7b9:	83 ee 01             	sub    $0x1,%esi
  80e7bc:	79 9c                	jns    80e75a <vprintfmt+0x1f2>
  80e7be:	89 df                	mov    %ebx,%edi
  80e7c0:	8b 75 08             	mov    0x8(%ebp),%esi
  80e7c3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e7c6:	eb 18                	jmp    80e7e0 <vprintfmt+0x278>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  80e7c8:	83 ec 08             	sub    $0x8,%esp
  80e7cb:	53                   	push   %ebx
  80e7cc:	6a 20                	push   $0x20
  80e7ce:	ff d6                	call   *%esi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80e7d0:	83 ef 01             	sub    $0x1,%edi
  80e7d3:	83 c4 10             	add    $0x10,%esp
  80e7d6:	eb 08                	jmp    80e7e0 <vprintfmt+0x278>
  80e7d8:	89 df                	mov    %ebx,%edi
  80e7da:	8b 75 08             	mov    0x8(%ebp),%esi
  80e7dd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e7e0:	85 ff                	test   %edi,%edi
  80e7e2:	7f e4                	jg     80e7c8 <vprintfmt+0x260>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e7e4:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e7e7:	e9 a2 fd ff ff       	jmp    80e58e <vprintfmt+0x26>
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80e7ec:	83 fa 01             	cmp    $0x1,%edx
  80e7ef:	7e 16                	jle    80e807 <vprintfmt+0x29f>
		return va_arg(*ap, long long);
  80e7f1:	8b 45 14             	mov    0x14(%ebp),%eax
  80e7f4:	8d 50 08             	lea    0x8(%eax),%edx
  80e7f7:	89 55 14             	mov    %edx,0x14(%ebp)
  80e7fa:	8b 50 04             	mov    0x4(%eax),%edx
  80e7fd:	8b 00                	mov    (%eax),%eax
  80e7ff:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e802:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80e805:	eb 32                	jmp    80e839 <vprintfmt+0x2d1>
	else if (lflag)
  80e807:	85 d2                	test   %edx,%edx
  80e809:	74 18                	je     80e823 <vprintfmt+0x2bb>
		return va_arg(*ap, long);
  80e80b:	8b 45 14             	mov    0x14(%ebp),%eax
  80e80e:	8d 50 04             	lea    0x4(%eax),%edx
  80e811:	89 55 14             	mov    %edx,0x14(%ebp)
  80e814:	8b 00                	mov    (%eax),%eax
  80e816:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e819:	89 c1                	mov    %eax,%ecx
  80e81b:	c1 f9 1f             	sar    $0x1f,%ecx
  80e81e:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80e821:	eb 16                	jmp    80e839 <vprintfmt+0x2d1>
	else
		return va_arg(*ap, int);
  80e823:	8b 45 14             	mov    0x14(%ebp),%eax
  80e826:	8d 50 04             	lea    0x4(%eax),%edx
  80e829:	89 55 14             	mov    %edx,0x14(%ebp)
  80e82c:	8b 00                	mov    (%eax),%eax
  80e82e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e831:	89 c1                	mov    %eax,%ecx
  80e833:	c1 f9 1f             	sar    $0x1f,%ecx
  80e836:	89 4d dc             	mov    %ecx,-0x24(%ebp)
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  80e839:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e83c:	8b 55 dc             	mov    -0x24(%ebp),%edx
			if ((long long) num < 0) {
				putch('-', putdat);
				num = -(long long) num;
			}
			base = 10;
  80e83f:	b9 0a 00 00 00       	mov    $0xa,%ecx
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
  80e844:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80e848:	79 74                	jns    80e8be <vprintfmt+0x356>
				putch('-', putdat);
  80e84a:	83 ec 08             	sub    $0x8,%esp
  80e84d:	53                   	push   %ebx
  80e84e:	6a 2d                	push   $0x2d
  80e850:	ff d6                	call   *%esi
				num = -(long long) num;
  80e852:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e855:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e858:	f7 d8                	neg    %eax
  80e85a:	83 d2 00             	adc    $0x0,%edx
  80e85d:	f7 da                	neg    %edx
  80e85f:	83 c4 10             	add    $0x10,%esp
			}
			base = 10;
  80e862:	b9 0a 00 00 00       	mov    $0xa,%ecx
  80e867:	eb 55                	jmp    80e8be <vprintfmt+0x356>
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  80e869:	8d 45 14             	lea    0x14(%ebp),%eax
  80e86c:	e8 83 fc ff ff       	call   80e4f4 <getuint>
			base = 10;
  80e871:	b9 0a 00 00 00       	mov    $0xa,%ecx
			goto number;
  80e876:	eb 46                	jmp    80e8be <vprintfmt+0x356>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getuint(&ap, lflag);
  80e878:	8d 45 14             	lea    0x14(%ebp),%eax
  80e87b:	e8 74 fc ff ff       	call   80e4f4 <getuint>
		        base = 8;
  80e880:	b9 08 00 00 00       	mov    $0x8,%ecx
                        goto number;
  80e885:	eb 37                	jmp    80e8be <vprintfmt+0x356>

		// pointer
		case 'p':
			putch('0', putdat);
  80e887:	83 ec 08             	sub    $0x8,%esp
  80e88a:	53                   	push   %ebx
  80e88b:	6a 30                	push   $0x30
  80e88d:	ff d6                	call   *%esi
			putch('x', putdat);
  80e88f:	83 c4 08             	add    $0x8,%esp
  80e892:	53                   	push   %ebx
  80e893:	6a 78                	push   $0x78
  80e895:	ff d6                	call   *%esi
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
  80e897:	8b 45 14             	mov    0x14(%ebp),%eax
  80e89a:	8d 50 04             	lea    0x4(%eax),%edx
  80e89d:	89 55 14             	mov    %edx,0x14(%ebp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  80e8a0:	8b 00                	mov    (%eax),%eax
  80e8a2:	ba 00 00 00 00       	mov    $0x0,%edx
				(uintptr_t) va_arg(ap, void *);
			base = 16;
			goto number;
  80e8a7:	83 c4 10             	add    $0x10,%esp
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
			base = 16;
  80e8aa:	b9 10 00 00 00       	mov    $0x10,%ecx
			goto number;
  80e8af:	eb 0d                	jmp    80e8be <vprintfmt+0x356>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  80e8b1:	8d 45 14             	lea    0x14(%ebp),%eax
  80e8b4:	e8 3b fc ff ff       	call   80e4f4 <getuint>
			base = 16;
  80e8b9:	b9 10 00 00 00       	mov    $0x10,%ecx
		number:
			printnum(putch, putdat, num, base, width, padc);
  80e8be:	83 ec 0c             	sub    $0xc,%esp
  80e8c1:	0f be 7d d4          	movsbl -0x2c(%ebp),%edi
  80e8c5:	57                   	push   %edi
  80e8c6:	ff 75 e0             	pushl  -0x20(%ebp)
  80e8c9:	51                   	push   %ecx
  80e8ca:	52                   	push   %edx
  80e8cb:	50                   	push   %eax
  80e8cc:	89 da                	mov    %ebx,%edx
  80e8ce:	89 f0                	mov    %esi,%eax
  80e8d0:	e8 70 fb ff ff       	call   80e445 <printnum>
			break;
  80e8d5:	83 c4 20             	add    $0x20,%esp
  80e8d8:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e8db:	e9 ae fc ff ff       	jmp    80e58e <vprintfmt+0x26>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  80e8e0:	83 ec 08             	sub    $0x8,%esp
  80e8e3:	53                   	push   %ebx
  80e8e4:	51                   	push   %ecx
  80e8e5:	ff d6                	call   *%esi
			break;
  80e8e7:	83 c4 10             	add    $0x10,%esp
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80e8ea:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			break;

		// escaped '%' character
		case '%':
			putch(ch, putdat);
			break;
  80e8ed:	e9 9c fc ff ff       	jmp    80e58e <vprintfmt+0x26>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  80e8f2:	83 ec 08             	sub    $0x8,%esp
  80e8f5:	53                   	push   %ebx
  80e8f6:	6a 25                	push   $0x25
  80e8f8:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80e8fa:	83 c4 10             	add    $0x10,%esp
  80e8fd:	eb 03                	jmp    80e902 <vprintfmt+0x39a>
  80e8ff:	83 ef 01             	sub    $0x1,%edi
  80e902:	80 7f ff 25          	cmpb   $0x25,-0x1(%edi)
  80e906:	75 f7                	jne    80e8ff <vprintfmt+0x397>
  80e908:	e9 81 fc ff ff       	jmp    80e58e <vprintfmt+0x26>
				/* do nothing */;
			break;
		}
	}
}
  80e90d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e910:	5b                   	pop    %ebx
  80e911:	5e                   	pop    %esi
  80e912:	5f                   	pop    %edi
  80e913:	5d                   	pop    %ebp
  80e914:	c3                   	ret    

0080e915 <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80e915:	55                   	push   %ebp
  80e916:	89 e5                	mov    %esp,%ebp
  80e918:	83 ec 18             	sub    $0x18,%esp
  80e91b:	8b 45 08             	mov    0x8(%ebp),%eax
  80e91e:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80e921:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80e924:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80e928:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80e92b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80e932:	85 c0                	test   %eax,%eax
  80e934:	74 26                	je     80e95c <vsnprintf+0x47>
  80e936:	85 d2                	test   %edx,%edx
  80e938:	7e 22                	jle    80e95c <vsnprintf+0x47>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80e93a:	ff 75 14             	pushl  0x14(%ebp)
  80e93d:	ff 75 10             	pushl  0x10(%ebp)
  80e940:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80e943:	50                   	push   %eax
  80e944:	68 2e e5 80 00       	push   $0x80e52e
  80e949:	e8 1a fc ff ff       	call   80e568 <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80e94e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80e951:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80e954:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80e957:	83 c4 10             	add    $0x10,%esp
  80e95a:	eb 05                	jmp    80e961 <vsnprintf+0x4c>
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
		return -E_INVAL;
  80e95c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

	// null terminate the buffer
	*b.buf = '\0';

	return b.cnt;
}
  80e961:	c9                   	leave  
  80e962:	c3                   	ret    

0080e963 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80e963:	55                   	push   %ebp
  80e964:	89 e5                	mov    %esp,%ebp
  80e966:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80e969:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80e96c:	50                   	push   %eax
  80e96d:	ff 75 10             	pushl  0x10(%ebp)
  80e970:	ff 75 0c             	pushl  0xc(%ebp)
  80e973:	ff 75 08             	pushl  0x8(%ebp)
  80e976:	e8 9a ff ff ff       	call   80e915 <vsnprintf>
	va_end(ap);

	return rc;
}
  80e97b:	c9                   	leave  
  80e97c:	c3                   	ret    

0080e97d <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80e97d:	55                   	push   %ebp
  80e97e:	89 e5                	mov    %esp,%ebp
  80e980:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80e983:	b8 00 00 00 00       	mov    $0x0,%eax
  80e988:	eb 03                	jmp    80e98d <strlen+0x10>
		n++;
  80e98a:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  80e98d:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80e991:	75 f7                	jne    80e98a <strlen+0xd>
		n++;
	return n;
}
  80e993:	5d                   	pop    %ebp
  80e994:	c3                   	ret    

0080e995 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80e995:	55                   	push   %ebp
  80e996:	89 e5                	mov    %esp,%ebp
  80e998:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e99b:	8b 45 0c             	mov    0xc(%ebp),%eax
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80e99e:	ba 00 00 00 00       	mov    $0x0,%edx
  80e9a3:	eb 03                	jmp    80e9a8 <strnlen+0x13>
		n++;
  80e9a5:	83 c2 01             	add    $0x1,%edx
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80e9a8:	39 c2                	cmp    %eax,%edx
  80e9aa:	74 08                	je     80e9b4 <strnlen+0x1f>
  80e9ac:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
  80e9b0:	75 f3                	jne    80e9a5 <strnlen+0x10>
  80e9b2:	89 d0                	mov    %edx,%eax
		n++;
	return n;
}
  80e9b4:	5d                   	pop    %ebp
  80e9b5:	c3                   	ret    

0080e9b6 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80e9b6:	55                   	push   %ebp
  80e9b7:	89 e5                	mov    %esp,%ebp
  80e9b9:	53                   	push   %ebx
  80e9ba:	8b 45 08             	mov    0x8(%ebp),%eax
  80e9bd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80e9c0:	89 c2                	mov    %eax,%edx
  80e9c2:	83 c2 01             	add    $0x1,%edx
  80e9c5:	83 c1 01             	add    $0x1,%ecx
  80e9c8:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
  80e9cc:	88 5a ff             	mov    %bl,-0x1(%edx)
  80e9cf:	84 db                	test   %bl,%bl
  80e9d1:	75 ef                	jne    80e9c2 <strcpy+0xc>
		/* do nothing */;
	return ret;
}
  80e9d3:	5b                   	pop    %ebx
  80e9d4:	5d                   	pop    %ebp
  80e9d5:	c3                   	ret    

0080e9d6 <strcat>:

char *
strcat(char *dst, const char *src)
{
  80e9d6:	55                   	push   %ebp
  80e9d7:	89 e5                	mov    %esp,%ebp
  80e9d9:	53                   	push   %ebx
  80e9da:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80e9dd:	53                   	push   %ebx
  80e9de:	e8 9a ff ff ff       	call   80e97d <strlen>
  80e9e3:	83 c4 04             	add    $0x4,%esp
	strcpy(dst + len, src);
  80e9e6:	ff 75 0c             	pushl  0xc(%ebp)
  80e9e9:	01 d8                	add    %ebx,%eax
  80e9eb:	50                   	push   %eax
  80e9ec:	e8 c5 ff ff ff       	call   80e9b6 <strcpy>
	return dst;
}
  80e9f1:	89 d8                	mov    %ebx,%eax
  80e9f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e9f6:	c9                   	leave  
  80e9f7:	c3                   	ret    

0080e9f8 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80e9f8:	55                   	push   %ebp
  80e9f9:	89 e5                	mov    %esp,%ebp
  80e9fb:	56                   	push   %esi
  80e9fc:	53                   	push   %ebx
  80e9fd:	8b 75 08             	mov    0x8(%ebp),%esi
  80ea00:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ea03:	89 f3                	mov    %esi,%ebx
  80ea05:	03 5d 10             	add    0x10(%ebp),%ebx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80ea08:	89 f2                	mov    %esi,%edx
  80ea0a:	eb 0f                	jmp    80ea1b <strncpy+0x23>
		*dst++ = *src;
  80ea0c:	83 c2 01             	add    $0x1,%edx
  80ea0f:	0f b6 01             	movzbl (%ecx),%eax
  80ea12:	88 42 ff             	mov    %al,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80ea15:	80 39 01             	cmpb   $0x1,(%ecx)
  80ea18:	83 d9 ff             	sbb    $0xffffffff,%ecx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80ea1b:	39 da                	cmp    %ebx,%edx
  80ea1d:	75 ed                	jne    80ea0c <strncpy+0x14>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  80ea1f:	89 f0                	mov    %esi,%eax
  80ea21:	5b                   	pop    %ebx
  80ea22:	5e                   	pop    %esi
  80ea23:	5d                   	pop    %ebp
  80ea24:	c3                   	ret    

0080ea25 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80ea25:	55                   	push   %ebp
  80ea26:	89 e5                	mov    %esp,%ebp
  80ea28:	56                   	push   %esi
  80ea29:	53                   	push   %ebx
  80ea2a:	8b 75 08             	mov    0x8(%ebp),%esi
  80ea2d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ea30:	8b 55 10             	mov    0x10(%ebp),%edx
  80ea33:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80ea35:	85 d2                	test   %edx,%edx
  80ea37:	74 21                	je     80ea5a <strlcpy+0x35>
  80ea39:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80ea3d:	89 f2                	mov    %esi,%edx
  80ea3f:	eb 09                	jmp    80ea4a <strlcpy+0x25>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  80ea41:	83 c2 01             	add    $0x1,%edx
  80ea44:	83 c1 01             	add    $0x1,%ecx
  80ea47:	88 5a ff             	mov    %bl,-0x1(%edx)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  80ea4a:	39 c2                	cmp    %eax,%edx
  80ea4c:	74 09                	je     80ea57 <strlcpy+0x32>
  80ea4e:	0f b6 19             	movzbl (%ecx),%ebx
  80ea51:	84 db                	test   %bl,%bl
  80ea53:	75 ec                	jne    80ea41 <strlcpy+0x1c>
  80ea55:	89 d0                	mov    %edx,%eax
			*dst++ = *src++;
		*dst = '\0';
  80ea57:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80ea5a:	29 f0                	sub    %esi,%eax
}
  80ea5c:	5b                   	pop    %ebx
  80ea5d:	5e                   	pop    %esi
  80ea5e:	5d                   	pop    %ebp
  80ea5f:	c3                   	ret    

0080ea60 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80ea60:	55                   	push   %ebp
  80ea61:	89 e5                	mov    %esp,%ebp
  80ea63:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ea66:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80ea69:	eb 06                	jmp    80ea71 <strcmp+0x11>
		p++, q++;
  80ea6b:	83 c1 01             	add    $0x1,%ecx
  80ea6e:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80ea71:	0f b6 01             	movzbl (%ecx),%eax
  80ea74:	84 c0                	test   %al,%al
  80ea76:	74 04                	je     80ea7c <strcmp+0x1c>
  80ea78:	3a 02                	cmp    (%edx),%al
  80ea7a:	74 ef                	je     80ea6b <strcmp+0xb>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80ea7c:	0f b6 c0             	movzbl %al,%eax
  80ea7f:	0f b6 12             	movzbl (%edx),%edx
  80ea82:	29 d0                	sub    %edx,%eax
}
  80ea84:	5d                   	pop    %ebp
  80ea85:	c3                   	ret    

0080ea86 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80ea86:	55                   	push   %ebp
  80ea87:	89 e5                	mov    %esp,%ebp
  80ea89:	53                   	push   %ebx
  80ea8a:	8b 45 08             	mov    0x8(%ebp),%eax
  80ea8d:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ea90:	89 c3                	mov    %eax,%ebx
  80ea92:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80ea95:	eb 06                	jmp    80ea9d <strncmp+0x17>
		n--, p++, q++;
  80ea97:	83 c0 01             	add    $0x1,%eax
  80ea9a:	83 c2 01             	add    $0x1,%edx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80ea9d:	39 d8                	cmp    %ebx,%eax
  80ea9f:	74 15                	je     80eab6 <strncmp+0x30>
  80eaa1:	0f b6 08             	movzbl (%eax),%ecx
  80eaa4:	84 c9                	test   %cl,%cl
  80eaa6:	74 04                	je     80eaac <strncmp+0x26>
  80eaa8:	3a 0a                	cmp    (%edx),%cl
  80eaaa:	74 eb                	je     80ea97 <strncmp+0x11>
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80eaac:	0f b6 00             	movzbl (%eax),%eax
  80eaaf:	0f b6 12             	movzbl (%edx),%edx
  80eab2:	29 d0                	sub    %edx,%eax
  80eab4:	eb 05                	jmp    80eabb <strncmp+0x35>
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
  80eab6:	b8 00 00 00 00       	mov    $0x0,%eax
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  80eabb:	5b                   	pop    %ebx
  80eabc:	5d                   	pop    %ebp
  80eabd:	c3                   	ret    

0080eabe <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80eabe:	55                   	push   %ebp
  80eabf:	89 e5                	mov    %esp,%ebp
  80eac1:	8b 45 08             	mov    0x8(%ebp),%eax
  80eac4:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80eac8:	eb 07                	jmp    80ead1 <strchr+0x13>
		if (*s == c)
  80eaca:	38 ca                	cmp    %cl,%dl
  80eacc:	74 0f                	je     80eadd <strchr+0x1f>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80eace:	83 c0 01             	add    $0x1,%eax
  80ead1:	0f b6 10             	movzbl (%eax),%edx
  80ead4:	84 d2                	test   %dl,%dl
  80ead6:	75 f2                	jne    80eaca <strchr+0xc>
		if (*s == c)
			return (char *) s;
	return 0;
  80ead8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80eadd:	5d                   	pop    %ebp
  80eade:	c3                   	ret    

0080eadf <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80eadf:	55                   	push   %ebp
  80eae0:	89 e5                	mov    %esp,%ebp
  80eae2:	8b 45 08             	mov    0x8(%ebp),%eax
  80eae5:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80eae9:	eb 03                	jmp    80eaee <strfind+0xf>
  80eaeb:	83 c0 01             	add    $0x1,%eax
  80eaee:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80eaf1:	38 ca                	cmp    %cl,%dl
  80eaf3:	74 04                	je     80eaf9 <strfind+0x1a>
  80eaf5:	84 d2                	test   %dl,%dl
  80eaf7:	75 f2                	jne    80eaeb <strfind+0xc>
			break;
	return (char *) s;
}
  80eaf9:	5d                   	pop    %ebp
  80eafa:	c3                   	ret    

0080eafb <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80eafb:	55                   	push   %ebp
  80eafc:	89 e5                	mov    %esp,%ebp
  80eafe:	57                   	push   %edi
  80eaff:	56                   	push   %esi
  80eb00:	53                   	push   %ebx
  80eb01:	8b 7d 08             	mov    0x8(%ebp),%edi
  80eb04:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80eb07:	85 c9                	test   %ecx,%ecx
  80eb09:	74 36                	je     80eb41 <memset+0x46>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80eb0b:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80eb11:	75 28                	jne    80eb3b <memset+0x40>
  80eb13:	f6 c1 03             	test   $0x3,%cl
  80eb16:	75 23                	jne    80eb3b <memset+0x40>
		c &= 0xFF;
  80eb18:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80eb1c:	89 d3                	mov    %edx,%ebx
  80eb1e:	c1 e3 08             	shl    $0x8,%ebx
  80eb21:	89 d6                	mov    %edx,%esi
  80eb23:	c1 e6 18             	shl    $0x18,%esi
  80eb26:	89 d0                	mov    %edx,%eax
  80eb28:	c1 e0 10             	shl    $0x10,%eax
  80eb2b:	09 f0                	or     %esi,%eax
  80eb2d:	09 c2                	or     %eax,%edx
		asm volatile("cld; rep stosl\n"
  80eb2f:	89 d8                	mov    %ebx,%eax
  80eb31:	09 d0                	or     %edx,%eax
  80eb33:	c1 e9 02             	shr    $0x2,%ecx
  80eb36:	fc                   	cld    
  80eb37:	f3 ab                	rep stos %eax,%es:(%edi)
  80eb39:	eb 06                	jmp    80eb41 <memset+0x46>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80eb3b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80eb3e:	fc                   	cld    
  80eb3f:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80eb41:	89 f8                	mov    %edi,%eax
  80eb43:	5b                   	pop    %ebx
  80eb44:	5e                   	pop    %esi
  80eb45:	5f                   	pop    %edi
  80eb46:	5d                   	pop    %ebp
  80eb47:	c3                   	ret    

0080eb48 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80eb48:	55                   	push   %ebp
  80eb49:	89 e5                	mov    %esp,%ebp
  80eb4b:	57                   	push   %edi
  80eb4c:	56                   	push   %esi
  80eb4d:	8b 45 08             	mov    0x8(%ebp),%eax
  80eb50:	8b 75 0c             	mov    0xc(%ebp),%esi
  80eb53:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80eb56:	39 c6                	cmp    %eax,%esi
  80eb58:	73 35                	jae    80eb8f <memmove+0x47>
  80eb5a:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80eb5d:	39 d0                	cmp    %edx,%eax
  80eb5f:	73 2e                	jae    80eb8f <memmove+0x47>
		s += n;
		d += n;
  80eb61:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80eb64:	89 d6                	mov    %edx,%esi
  80eb66:	09 fe                	or     %edi,%esi
  80eb68:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80eb6e:	75 13                	jne    80eb83 <memmove+0x3b>
  80eb70:	f6 c1 03             	test   $0x3,%cl
  80eb73:	75 0e                	jne    80eb83 <memmove+0x3b>
			asm volatile("std; rep movsl\n"
  80eb75:	83 ef 04             	sub    $0x4,%edi
  80eb78:	8d 72 fc             	lea    -0x4(%edx),%esi
  80eb7b:	c1 e9 02             	shr    $0x2,%ecx
  80eb7e:	fd                   	std    
  80eb7f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80eb81:	eb 09                	jmp    80eb8c <memmove+0x44>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80eb83:	83 ef 01             	sub    $0x1,%edi
  80eb86:	8d 72 ff             	lea    -0x1(%edx),%esi
  80eb89:	fd                   	std    
  80eb8a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80eb8c:	fc                   	cld    
  80eb8d:	eb 1d                	jmp    80ebac <memmove+0x64>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80eb8f:	89 f2                	mov    %esi,%edx
  80eb91:	09 c2                	or     %eax,%edx
  80eb93:	f6 c2 03             	test   $0x3,%dl
  80eb96:	75 0f                	jne    80eba7 <memmove+0x5f>
  80eb98:	f6 c1 03             	test   $0x3,%cl
  80eb9b:	75 0a                	jne    80eba7 <memmove+0x5f>
			asm volatile("cld; rep movsl\n"
  80eb9d:	c1 e9 02             	shr    $0x2,%ecx
  80eba0:	89 c7                	mov    %eax,%edi
  80eba2:	fc                   	cld    
  80eba3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80eba5:	eb 05                	jmp    80ebac <memmove+0x64>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80eba7:	89 c7                	mov    %eax,%edi
  80eba9:	fc                   	cld    
  80ebaa:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80ebac:	5e                   	pop    %esi
  80ebad:	5f                   	pop    %edi
  80ebae:	5d                   	pop    %ebp
  80ebaf:	c3                   	ret    

0080ebb0 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80ebb0:	55                   	push   %ebp
  80ebb1:	89 e5                	mov    %esp,%ebp
	return memmove(dst, src, n);
  80ebb3:	ff 75 10             	pushl  0x10(%ebp)
  80ebb6:	ff 75 0c             	pushl  0xc(%ebp)
  80ebb9:	ff 75 08             	pushl  0x8(%ebp)
  80ebbc:	e8 87 ff ff ff       	call   80eb48 <memmove>
}
  80ebc1:	c9                   	leave  
  80ebc2:	c3                   	ret    

0080ebc3 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80ebc3:	55                   	push   %ebp
  80ebc4:	89 e5                	mov    %esp,%ebp
  80ebc6:	56                   	push   %esi
  80ebc7:	53                   	push   %ebx
  80ebc8:	8b 45 08             	mov    0x8(%ebp),%eax
  80ebcb:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ebce:	89 c6                	mov    %eax,%esi
  80ebd0:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80ebd3:	eb 1a                	jmp    80ebef <memcmp+0x2c>
		if (*s1 != *s2)
  80ebd5:	0f b6 08             	movzbl (%eax),%ecx
  80ebd8:	0f b6 1a             	movzbl (%edx),%ebx
  80ebdb:	38 d9                	cmp    %bl,%cl
  80ebdd:	74 0a                	je     80ebe9 <memcmp+0x26>
			return (int) *s1 - (int) *s2;
  80ebdf:	0f b6 c1             	movzbl %cl,%eax
  80ebe2:	0f b6 db             	movzbl %bl,%ebx
  80ebe5:	29 d8                	sub    %ebx,%eax
  80ebe7:	eb 0f                	jmp    80ebf8 <memcmp+0x35>
		s1++, s2++;
  80ebe9:	83 c0 01             	add    $0x1,%eax
  80ebec:	83 c2 01             	add    $0x1,%edx
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80ebef:	39 f0                	cmp    %esi,%eax
  80ebf1:	75 e2                	jne    80ebd5 <memcmp+0x12>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80ebf3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ebf8:	5b                   	pop    %ebx
  80ebf9:	5e                   	pop    %esi
  80ebfa:	5d                   	pop    %ebp
  80ebfb:	c3                   	ret    

0080ebfc <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80ebfc:	55                   	push   %ebp
  80ebfd:	89 e5                	mov    %esp,%ebp
  80ebff:	53                   	push   %ebx
  80ec00:	8b 45 08             	mov    0x8(%ebp),%eax
	const void *ends = (const char *) s + n;
  80ec03:	89 c1                	mov    %eax,%ecx
  80ec05:	03 4d 10             	add    0x10(%ebp),%ecx
	for (; s < ends; s++)
		if (*(const unsigned char *) s == (unsigned char) c)
  80ec08:	0f b6 5d 0c          	movzbl 0xc(%ebp),%ebx

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80ec0c:	eb 0a                	jmp    80ec18 <memfind+0x1c>
		if (*(const unsigned char *) s == (unsigned char) c)
  80ec0e:	0f b6 10             	movzbl (%eax),%edx
  80ec11:	39 da                	cmp    %ebx,%edx
  80ec13:	74 07                	je     80ec1c <memfind+0x20>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80ec15:	83 c0 01             	add    $0x1,%eax
  80ec18:	39 c8                	cmp    %ecx,%eax
  80ec1a:	72 f2                	jb     80ec0e <memfind+0x12>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  80ec1c:	5b                   	pop    %ebx
  80ec1d:	5d                   	pop    %ebp
  80ec1e:	c3                   	ret    

0080ec1f <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80ec1f:	55                   	push   %ebp
  80ec20:	89 e5                	mov    %esp,%ebp
  80ec22:	57                   	push   %edi
  80ec23:	56                   	push   %esi
  80ec24:	53                   	push   %ebx
  80ec25:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ec28:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80ec2b:	eb 03                	jmp    80ec30 <strtol+0x11>
		s++;
  80ec2d:	83 c1 01             	add    $0x1,%ecx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80ec30:	0f b6 01             	movzbl (%ecx),%eax
  80ec33:	3c 20                	cmp    $0x20,%al
  80ec35:	74 f6                	je     80ec2d <strtol+0xe>
  80ec37:	3c 09                	cmp    $0x9,%al
  80ec39:	74 f2                	je     80ec2d <strtol+0xe>
		s++;

	// plus/minus sign
	if (*s == '+')
  80ec3b:	3c 2b                	cmp    $0x2b,%al
  80ec3d:	75 0a                	jne    80ec49 <strtol+0x2a>
		s++;
  80ec3f:	83 c1 01             	add    $0x1,%ecx
}

long
strtol(const char *s, char **endptr, int base)
{
	int neg = 0;
  80ec42:	bf 00 00 00 00       	mov    $0x0,%edi
  80ec47:	eb 11                	jmp    80ec5a <strtol+0x3b>
  80ec49:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;

	// plus/minus sign
	if (*s == '+')
		s++;
	else if (*s == '-')
  80ec4e:	3c 2d                	cmp    $0x2d,%al
  80ec50:	75 08                	jne    80ec5a <strtol+0x3b>
		s++, neg = 1;
  80ec52:	83 c1 01             	add    $0x1,%ecx
  80ec55:	bf 01 00 00 00       	mov    $0x1,%edi

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80ec5a:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80ec60:	75 15                	jne    80ec77 <strtol+0x58>
  80ec62:	80 39 30             	cmpb   $0x30,(%ecx)
  80ec65:	75 10                	jne    80ec77 <strtol+0x58>
  80ec67:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80ec6b:	75 7c                	jne    80ece9 <strtol+0xca>
		s += 2, base = 16;
  80ec6d:	83 c1 02             	add    $0x2,%ecx
  80ec70:	bb 10 00 00 00       	mov    $0x10,%ebx
  80ec75:	eb 16                	jmp    80ec8d <strtol+0x6e>
	else if (base == 0 && s[0] == '0')
  80ec77:	85 db                	test   %ebx,%ebx
  80ec79:	75 12                	jne    80ec8d <strtol+0x6e>
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80ec7b:	bb 0a 00 00 00       	mov    $0xa,%ebx
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80ec80:	80 39 30             	cmpb   $0x30,(%ecx)
  80ec83:	75 08                	jne    80ec8d <strtol+0x6e>
		s++, base = 8;
  80ec85:	83 c1 01             	add    $0x1,%ecx
  80ec88:	bb 08 00 00 00       	mov    $0x8,%ebx
	else if (base == 0)
		base = 10;
  80ec8d:	b8 00 00 00 00       	mov    $0x0,%eax
  80ec92:	89 5d 10             	mov    %ebx,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80ec95:	0f b6 11             	movzbl (%ecx),%edx
  80ec98:	8d 72 d0             	lea    -0x30(%edx),%esi
  80ec9b:	89 f3                	mov    %esi,%ebx
  80ec9d:	80 fb 09             	cmp    $0x9,%bl
  80eca0:	77 08                	ja     80ecaa <strtol+0x8b>
			dig = *s - '0';
  80eca2:	0f be d2             	movsbl %dl,%edx
  80eca5:	83 ea 30             	sub    $0x30,%edx
  80eca8:	eb 22                	jmp    80eccc <strtol+0xad>
		else if (*s >= 'a' && *s <= 'z')
  80ecaa:	8d 72 9f             	lea    -0x61(%edx),%esi
  80ecad:	89 f3                	mov    %esi,%ebx
  80ecaf:	80 fb 19             	cmp    $0x19,%bl
  80ecb2:	77 08                	ja     80ecbc <strtol+0x9d>
			dig = *s - 'a' + 10;
  80ecb4:	0f be d2             	movsbl %dl,%edx
  80ecb7:	83 ea 57             	sub    $0x57,%edx
  80ecba:	eb 10                	jmp    80eccc <strtol+0xad>
		else if (*s >= 'A' && *s <= 'Z')
  80ecbc:	8d 72 bf             	lea    -0x41(%edx),%esi
  80ecbf:	89 f3                	mov    %esi,%ebx
  80ecc1:	80 fb 19             	cmp    $0x19,%bl
  80ecc4:	77 16                	ja     80ecdc <strtol+0xbd>
			dig = *s - 'A' + 10;
  80ecc6:	0f be d2             	movsbl %dl,%edx
  80ecc9:	83 ea 37             	sub    $0x37,%edx
		else
			break;
		if (dig >= base)
  80eccc:	3b 55 10             	cmp    0x10(%ebp),%edx
  80eccf:	7d 0b                	jge    80ecdc <strtol+0xbd>
			break;
		s++, val = (val * base) + dig;
  80ecd1:	83 c1 01             	add    $0x1,%ecx
  80ecd4:	0f af 45 10          	imul   0x10(%ebp),%eax
  80ecd8:	01 d0                	add    %edx,%eax
		// we don't properly detect overflow!
	}
  80ecda:	eb b9                	jmp    80ec95 <strtol+0x76>

	if (endptr)
  80ecdc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80ece0:	74 0d                	je     80ecef <strtol+0xd0>
		*endptr = (char *) s;
  80ece2:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ece5:	89 0e                	mov    %ecx,(%esi)
  80ece7:	eb 06                	jmp    80ecef <strtol+0xd0>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80ece9:	85 db                	test   %ebx,%ebx
  80eceb:	74 98                	je     80ec85 <strtol+0x66>
  80eced:	eb 9e                	jmp    80ec8d <strtol+0x6e>
		// we don't properly detect overflow!
	}

	if (endptr)
		*endptr = (char *) s;
	return (neg ? -val : val);
  80ecef:	89 c2                	mov    %eax,%edx
  80ecf1:	f7 da                	neg    %edx
  80ecf3:	85 ff                	test   %edi,%edi
  80ecf5:	0f 45 c2             	cmovne %edx,%eax
}
  80ecf8:	5b                   	pop    %ebx
  80ecf9:	5e                   	pop    %esi
  80ecfa:	5f                   	pop    %edi
  80ecfb:	5d                   	pop    %ebp
  80ecfc:	c3                   	ret    

0080ecfd <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80ecfd:	55                   	push   %ebp
  80ecfe:	89 e5                	mov    %esp,%ebp
  80ed00:	57                   	push   %edi
  80ed01:	56                   	push   %esi
  80ed02:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ed03:	b8 00 00 00 00       	mov    $0x0,%eax
  80ed08:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ed0b:	8b 55 08             	mov    0x8(%ebp),%edx
  80ed0e:	89 c3                	mov    %eax,%ebx
  80ed10:	89 c7                	mov    %eax,%edi
  80ed12:	89 c6                	mov    %eax,%esi
  80ed14:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80ed16:	5b                   	pop    %ebx
  80ed17:	5e                   	pop    %esi
  80ed18:	5f                   	pop    %edi
  80ed19:	5d                   	pop    %ebp
  80ed1a:	c3                   	ret    

0080ed1b <sys_cgetc>:

int
sys_cgetc(void)
{
  80ed1b:	55                   	push   %ebp
  80ed1c:	89 e5                	mov    %esp,%ebp
  80ed1e:	57                   	push   %edi
  80ed1f:	56                   	push   %esi
  80ed20:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ed21:	ba 00 00 00 00       	mov    $0x0,%edx
  80ed26:	b8 01 00 00 00       	mov    $0x1,%eax
  80ed2b:	89 d1                	mov    %edx,%ecx
  80ed2d:	89 d3                	mov    %edx,%ebx
  80ed2f:	89 d7                	mov    %edx,%edi
  80ed31:	89 d6                	mov    %edx,%esi
  80ed33:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80ed35:	5b                   	pop    %ebx
  80ed36:	5e                   	pop    %esi
  80ed37:	5f                   	pop    %edi
  80ed38:	5d                   	pop    %ebp
  80ed39:	c3                   	ret    

0080ed3a <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80ed3a:	55                   	push   %ebp
  80ed3b:	89 e5                	mov    %esp,%ebp
  80ed3d:	57                   	push   %edi
  80ed3e:	56                   	push   %esi
  80ed3f:	53                   	push   %ebx
  80ed40:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ed43:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ed48:	b8 03 00 00 00       	mov    $0x3,%eax
  80ed4d:	8b 55 08             	mov    0x8(%ebp),%edx
  80ed50:	89 cb                	mov    %ecx,%ebx
  80ed52:	89 cf                	mov    %ecx,%edi
  80ed54:	89 ce                	mov    %ecx,%esi
  80ed56:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ed58:	85 c0                	test   %eax,%eax
  80ed5a:	7e 17                	jle    80ed73 <sys_env_destroy+0x39>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ed5c:	83 ec 0c             	sub    $0xc,%esp
  80ed5f:	50                   	push   %eax
  80ed60:	6a 03                	push   $0x3
  80ed62:	68 1f 34 81 00       	push   $0x81341f
  80ed67:	6a 23                	push   $0x23
  80ed69:	68 3c 34 81 00       	push   $0x81343c
  80ed6e:	e8 e5 f5 ff ff       	call   80e358 <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80ed73:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ed76:	5b                   	pop    %ebx
  80ed77:	5e                   	pop    %esi
  80ed78:	5f                   	pop    %edi
  80ed79:	5d                   	pop    %ebp
  80ed7a:	c3                   	ret    

0080ed7b <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80ed7b:	55                   	push   %ebp
  80ed7c:	89 e5                	mov    %esp,%ebp
  80ed7e:	57                   	push   %edi
  80ed7f:	56                   	push   %esi
  80ed80:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ed81:	ba 00 00 00 00       	mov    $0x0,%edx
  80ed86:	b8 02 00 00 00       	mov    $0x2,%eax
  80ed8b:	89 d1                	mov    %edx,%ecx
  80ed8d:	89 d3                	mov    %edx,%ebx
  80ed8f:	89 d7                	mov    %edx,%edi
  80ed91:	89 d6                	mov    %edx,%esi
  80ed93:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80ed95:	5b                   	pop    %ebx
  80ed96:	5e                   	pop    %esi
  80ed97:	5f                   	pop    %edi
  80ed98:	5d                   	pop    %ebp
  80ed99:	c3                   	ret    

0080ed9a <sys_yield>:

void
sys_yield(void)
{
  80ed9a:	55                   	push   %ebp
  80ed9b:	89 e5                	mov    %esp,%ebp
  80ed9d:	57                   	push   %edi
  80ed9e:	56                   	push   %esi
  80ed9f:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80eda0:	ba 00 00 00 00       	mov    $0x0,%edx
  80eda5:	b8 0b 00 00 00       	mov    $0xb,%eax
  80edaa:	89 d1                	mov    %edx,%ecx
  80edac:	89 d3                	mov    %edx,%ebx
  80edae:	89 d7                	mov    %edx,%edi
  80edb0:	89 d6                	mov    %edx,%esi
  80edb2:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80edb4:	5b                   	pop    %ebx
  80edb5:	5e                   	pop    %esi
  80edb6:	5f                   	pop    %edi
  80edb7:	5d                   	pop    %ebp
  80edb8:	c3                   	ret    

0080edb9 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80edb9:	55                   	push   %ebp
  80edba:	89 e5                	mov    %esp,%ebp
  80edbc:	57                   	push   %edi
  80edbd:	56                   	push   %esi
  80edbe:	53                   	push   %ebx
  80edbf:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80edc2:	be 00 00 00 00       	mov    $0x0,%esi
  80edc7:	b8 04 00 00 00       	mov    $0x4,%eax
  80edcc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80edcf:	8b 55 08             	mov    0x8(%ebp),%edx
  80edd2:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80edd5:	89 f7                	mov    %esi,%edi
  80edd7:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80edd9:	85 c0                	test   %eax,%eax
  80eddb:	7e 17                	jle    80edf4 <sys_page_alloc+0x3b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80eddd:	83 ec 0c             	sub    $0xc,%esp
  80ede0:	50                   	push   %eax
  80ede1:	6a 04                	push   $0x4
  80ede3:	68 1f 34 81 00       	push   $0x81341f
  80ede8:	6a 23                	push   $0x23
  80edea:	68 3c 34 81 00       	push   $0x81343c
  80edef:	e8 64 f5 ff ff       	call   80e358 <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80edf4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80edf7:	5b                   	pop    %ebx
  80edf8:	5e                   	pop    %esi
  80edf9:	5f                   	pop    %edi
  80edfa:	5d                   	pop    %ebp
  80edfb:	c3                   	ret    

0080edfc <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80edfc:	55                   	push   %ebp
  80edfd:	89 e5                	mov    %esp,%ebp
  80edff:	57                   	push   %edi
  80ee00:	56                   	push   %esi
  80ee01:	53                   	push   %ebx
  80ee02:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ee05:	b8 05 00 00 00       	mov    $0x5,%eax
  80ee0a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ee0d:	8b 55 08             	mov    0x8(%ebp),%edx
  80ee10:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80ee13:	8b 7d 14             	mov    0x14(%ebp),%edi
  80ee16:	8b 75 18             	mov    0x18(%ebp),%esi
  80ee19:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ee1b:	85 c0                	test   %eax,%eax
  80ee1d:	7e 17                	jle    80ee36 <sys_page_map+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ee1f:	83 ec 0c             	sub    $0xc,%esp
  80ee22:	50                   	push   %eax
  80ee23:	6a 05                	push   $0x5
  80ee25:	68 1f 34 81 00       	push   $0x81341f
  80ee2a:	6a 23                	push   $0x23
  80ee2c:	68 3c 34 81 00       	push   $0x81343c
  80ee31:	e8 22 f5 ff ff       	call   80e358 <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80ee36:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ee39:	5b                   	pop    %ebx
  80ee3a:	5e                   	pop    %esi
  80ee3b:	5f                   	pop    %edi
  80ee3c:	5d                   	pop    %ebp
  80ee3d:	c3                   	ret    

0080ee3e <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80ee3e:	55                   	push   %ebp
  80ee3f:	89 e5                	mov    %esp,%ebp
  80ee41:	57                   	push   %edi
  80ee42:	56                   	push   %esi
  80ee43:	53                   	push   %ebx
  80ee44:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ee47:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ee4c:	b8 06 00 00 00       	mov    $0x6,%eax
  80ee51:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ee54:	8b 55 08             	mov    0x8(%ebp),%edx
  80ee57:	89 df                	mov    %ebx,%edi
  80ee59:	89 de                	mov    %ebx,%esi
  80ee5b:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ee5d:	85 c0                	test   %eax,%eax
  80ee5f:	7e 17                	jle    80ee78 <sys_page_unmap+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ee61:	83 ec 0c             	sub    $0xc,%esp
  80ee64:	50                   	push   %eax
  80ee65:	6a 06                	push   $0x6
  80ee67:	68 1f 34 81 00       	push   $0x81341f
  80ee6c:	6a 23                	push   $0x23
  80ee6e:	68 3c 34 81 00       	push   $0x81343c
  80ee73:	e8 e0 f4 ff ff       	call   80e358 <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80ee78:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ee7b:	5b                   	pop    %ebx
  80ee7c:	5e                   	pop    %esi
  80ee7d:	5f                   	pop    %edi
  80ee7e:	5d                   	pop    %ebp
  80ee7f:	c3                   	ret    

0080ee80 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80ee80:	55                   	push   %ebp
  80ee81:	89 e5                	mov    %esp,%ebp
  80ee83:	57                   	push   %edi
  80ee84:	56                   	push   %esi
  80ee85:	53                   	push   %ebx
  80ee86:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ee89:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ee8e:	b8 08 00 00 00       	mov    $0x8,%eax
  80ee93:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ee96:	8b 55 08             	mov    0x8(%ebp),%edx
  80ee99:	89 df                	mov    %ebx,%edi
  80ee9b:	89 de                	mov    %ebx,%esi
  80ee9d:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ee9f:	85 c0                	test   %eax,%eax
  80eea1:	7e 17                	jle    80eeba <sys_env_set_status+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80eea3:	83 ec 0c             	sub    $0xc,%esp
  80eea6:	50                   	push   %eax
  80eea7:	6a 08                	push   $0x8
  80eea9:	68 1f 34 81 00       	push   $0x81341f
  80eeae:	6a 23                	push   $0x23
  80eeb0:	68 3c 34 81 00       	push   $0x81343c
  80eeb5:	e8 9e f4 ff ff       	call   80e358 <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80eeba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80eebd:	5b                   	pop    %ebx
  80eebe:	5e                   	pop    %esi
  80eebf:	5f                   	pop    %edi
  80eec0:	5d                   	pop    %ebp
  80eec1:	c3                   	ret    

0080eec2 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80eec2:	55                   	push   %ebp
  80eec3:	89 e5                	mov    %esp,%ebp
  80eec5:	57                   	push   %edi
  80eec6:	56                   	push   %esi
  80eec7:	53                   	push   %ebx
  80eec8:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80eecb:	bb 00 00 00 00       	mov    $0x0,%ebx
  80eed0:	b8 09 00 00 00       	mov    $0x9,%eax
  80eed5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80eed8:	8b 55 08             	mov    0x8(%ebp),%edx
  80eedb:	89 df                	mov    %ebx,%edi
  80eedd:	89 de                	mov    %ebx,%esi
  80eedf:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80eee1:	85 c0                	test   %eax,%eax
  80eee3:	7e 17                	jle    80eefc <sys_env_set_trapframe+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80eee5:	83 ec 0c             	sub    $0xc,%esp
  80eee8:	50                   	push   %eax
  80eee9:	6a 09                	push   $0x9
  80eeeb:	68 1f 34 81 00       	push   $0x81341f
  80eef0:	6a 23                	push   $0x23
  80eef2:	68 3c 34 81 00       	push   $0x81343c
  80eef7:	e8 5c f4 ff ff       	call   80e358 <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80eefc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80eeff:	5b                   	pop    %ebx
  80ef00:	5e                   	pop    %esi
  80ef01:	5f                   	pop    %edi
  80ef02:	5d                   	pop    %ebp
  80ef03:	c3                   	ret    

0080ef04 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80ef04:	55                   	push   %ebp
  80ef05:	89 e5                	mov    %esp,%ebp
  80ef07:	57                   	push   %edi
  80ef08:	56                   	push   %esi
  80ef09:	53                   	push   %ebx
  80ef0a:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ef0d:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ef12:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ef17:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef1a:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef1d:	89 df                	mov    %ebx,%edi
  80ef1f:	89 de                	mov    %ebx,%esi
  80ef21:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ef23:	85 c0                	test   %eax,%eax
  80ef25:	7e 17                	jle    80ef3e <sys_env_set_pgfault_upcall+0x3a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ef27:	83 ec 0c             	sub    $0xc,%esp
  80ef2a:	50                   	push   %eax
  80ef2b:	6a 0a                	push   $0xa
  80ef2d:	68 1f 34 81 00       	push   $0x81341f
  80ef32:	6a 23                	push   $0x23
  80ef34:	68 3c 34 81 00       	push   $0x81343c
  80ef39:	e8 1a f4 ff ff       	call   80e358 <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80ef3e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef41:	5b                   	pop    %ebx
  80ef42:	5e                   	pop    %esi
  80ef43:	5f                   	pop    %edi
  80ef44:	5d                   	pop    %ebp
  80ef45:	c3                   	ret    

0080ef46 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80ef46:	55                   	push   %ebp
  80ef47:	89 e5                	mov    %esp,%ebp
  80ef49:	57                   	push   %edi
  80ef4a:	56                   	push   %esi
  80ef4b:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ef4c:	be 00 00 00 00       	mov    $0x0,%esi
  80ef51:	b8 0c 00 00 00       	mov    $0xc,%eax
  80ef56:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef59:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef5c:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80ef5f:	8b 7d 14             	mov    0x14(%ebp),%edi
  80ef62:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80ef64:	5b                   	pop    %ebx
  80ef65:	5e                   	pop    %esi
  80ef66:	5f                   	pop    %edi
  80ef67:	5d                   	pop    %ebp
  80ef68:	c3                   	ret    

0080ef69 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80ef69:	55                   	push   %ebp
  80ef6a:	89 e5                	mov    %esp,%ebp
  80ef6c:	57                   	push   %edi
  80ef6d:	56                   	push   %esi
  80ef6e:	53                   	push   %ebx
  80ef6f:	83 ec 0c             	sub    $0xc,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80ef72:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ef77:	b8 0d 00 00 00       	mov    $0xd,%eax
  80ef7c:	8b 55 08             	mov    0x8(%ebp),%edx
  80ef7f:	89 cb                	mov    %ecx,%ebx
  80ef81:	89 cf                	mov    %ecx,%edi
  80ef83:	89 ce                	mov    %ecx,%esi
  80ef85:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  80ef87:	85 c0                	test   %eax,%eax
  80ef89:	7e 17                	jle    80efa2 <sys_ipc_recv+0x39>
		panic("syscall %d returned %d (> 0)", num, ret);
  80ef8b:	83 ec 0c             	sub    $0xc,%esp
  80ef8e:	50                   	push   %eax
  80ef8f:	6a 0d                	push   $0xd
  80ef91:	68 1f 34 81 00       	push   $0x81341f
  80ef96:	6a 23                	push   $0x23
  80ef98:	68 3c 34 81 00       	push   $0x81343c
  80ef9d:	e8 b6 f3 ff ff       	call   80e358 <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80efa2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80efa5:	5b                   	pop    %ebx
  80efa6:	5e                   	pop    %esi
  80efa7:	5f                   	pop    %edi
  80efa8:	5d                   	pop    %ebp
  80efa9:	c3                   	ret    

0080efaa <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80efaa:	55                   	push   %ebp
  80efab:	89 e5                	mov    %esp,%ebp
  80efad:	57                   	push   %edi
  80efae:	56                   	push   %esi
  80efaf:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80efb0:	ba 00 00 00 00       	mov    $0x0,%edx
  80efb5:	b8 0e 00 00 00       	mov    $0xe,%eax
  80efba:	89 d1                	mov    %edx,%ecx
  80efbc:	89 d3                	mov    %edx,%ebx
  80efbe:	89 d7                	mov    %edx,%edi
  80efc0:	89 d6                	mov    %edx,%esi
  80efc2:	cd 30                	int    $0x30

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80efc4:	5b                   	pop    %ebx
  80efc5:	5e                   	pop    %esi
  80efc6:	5f                   	pop    %edi
  80efc7:	5d                   	pop    %ebp
  80efc8:	c3                   	ret    

0080efc9 <sys_net_xmit>:

int sys_net_xmit(void * addr, size_t length)
{
  80efc9:	55                   	push   %ebp
  80efca:	89 e5                	mov    %esp,%ebp
  80efcc:	57                   	push   %edi
  80efcd:	56                   	push   %esi
  80efce:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80efcf:	bb 00 00 00 00       	mov    $0x0,%ebx
  80efd4:	b8 0f 00 00 00       	mov    $0xf,%eax
  80efd9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80efdc:	8b 55 08             	mov    0x8(%ebp),%edx
  80efdf:	89 df                	mov    %ebx,%edi
  80efe1:	89 de                	mov    %ebx,%esi
  80efe3:	cd 30                	int    $0x30
}

int sys_net_xmit(void * addr, size_t length)
{
	return (int) syscall(SYS_net_xmit, 0, (uint32_t)addr, (uint32_t)length, 0, 0, 0);
}
  80efe5:	5b                   	pop    %ebx
  80efe6:	5e                   	pop    %esi
  80efe7:	5f                   	pop    %edi
  80efe8:	5d                   	pop    %ebp
  80efe9:	c3                   	ret    

0080efea <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80efea:	55                   	push   %ebp
  80efeb:	89 e5                	mov    %esp,%ebp
  80efed:	53                   	push   %ebx
  80efee:	83 ec 04             	sub    $0x4,%esp
  80eff1:	8b 55 08             	mov    0x8(%ebp),%edx
	void *addr = (void *) utf->utf_fault_va;
  80eff4:	8b 02                	mov    (%edx),%eax
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
	 if (!((err & FEC_WR) && (uvpd[PDX(addr)] & PTE_P) && (uvpt[PGNUM(addr)] & PTE_P)  && (uvpt[PGNUM(addr)] & PTE_COW)))
  80eff6:	f6 42 04 02          	testb  $0x2,0x4(%edx)
  80effa:	74 2e                	je     80f02a <pgfault+0x40>
  80effc:	89 c2                	mov    %eax,%edx
  80effe:	c1 ea 16             	shr    $0x16,%edx
  80f001:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f008:	f6 c2 01             	test   $0x1,%dl
  80f00b:	74 1d                	je     80f02a <pgfault+0x40>
  80f00d:	89 c2                	mov    %eax,%edx
  80f00f:	c1 ea 0c             	shr    $0xc,%edx
  80f012:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
  80f019:	f6 c1 01             	test   $0x1,%cl
  80f01c:	74 0c                	je     80f02a <pgfault+0x40>
  80f01e:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f025:	f6 c6 08             	test   $0x8,%dh
  80f028:	75 14                	jne    80f03e <pgfault+0x54>
        panic("Not copy-on-write\n");
  80f02a:	83 ec 04             	sub    $0x4,%esp
  80f02d:	68 4a 34 81 00       	push   $0x81344a
  80f032:	6a 1d                	push   $0x1d
  80f034:	68 5d 34 81 00       	push   $0x81345d
  80f039:	e8 1a f3 ff ff       	call   80e358 <_panic>
	// page to the old page's address.
	// Hint:
	//   You should make three system calls.
	// LAB 4: Your code here.
	
	addr = ROUNDDOWN(addr, PGSIZE);
  80f03e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f043:	89 c3                	mov    %eax,%ebx
	if (sys_page_alloc(0, PFTEMP,  PTE_W | PTE_P | PTE_U) < 0)
  80f045:	83 ec 04             	sub    $0x4,%esp
  80f048:	6a 07                	push   $0x7
  80f04a:	68 00 f0 7f 00       	push   $0x7ff000
  80f04f:	6a 00                	push   $0x0
  80f051:	e8 63 fd ff ff       	call   80edb9 <sys_page_alloc>
  80f056:	83 c4 10             	add    $0x10,%esp
  80f059:	85 c0                	test   %eax,%eax
  80f05b:	79 14                	jns    80f071 <pgfault+0x87>
		panic("page alloc failed \n");
  80f05d:	83 ec 04             	sub    $0x4,%esp
  80f060:	68 68 34 81 00       	push   $0x813468
  80f065:	6a 28                	push   $0x28
  80f067:	68 5d 34 81 00       	push   $0x81345d
  80f06c:	e8 e7 f2 ff ff       	call   80e358 <_panic>
	memcpy(PFTEMP,addr, PGSIZE);
  80f071:	83 ec 04             	sub    $0x4,%esp
  80f074:	68 00 10 00 00       	push   $0x1000
  80f079:	53                   	push   %ebx
  80f07a:	68 00 f0 7f 00       	push   $0x7ff000
  80f07f:	e8 2c fb ff ff       	call   80ebb0 <memcpy>
	if (sys_page_map(0, PFTEMP, 0, addr, PTE_W | PTE_U | PTE_P) < 0)
  80f084:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f08b:	53                   	push   %ebx
  80f08c:	6a 00                	push   $0x0
  80f08e:	68 00 f0 7f 00       	push   $0x7ff000
  80f093:	6a 00                	push   $0x0
  80f095:	e8 62 fd ff ff       	call   80edfc <sys_page_map>
  80f09a:	83 c4 20             	add    $0x20,%esp
  80f09d:	85 c0                	test   %eax,%eax
  80f09f:	79 14                	jns    80f0b5 <pgfault+0xcb>
        panic("page map failed \n");
  80f0a1:	83 ec 04             	sub    $0x4,%esp
  80f0a4:	68 7c 34 81 00       	push   $0x81347c
  80f0a9:	6a 2b                	push   $0x2b
  80f0ab:	68 5d 34 81 00       	push   $0x81345d
  80f0b0:	e8 a3 f2 ff ff       	call   80e358 <_panic>
    if (sys_page_unmap(0, PFTEMP) < 0)
  80f0b5:	83 ec 08             	sub    $0x8,%esp
  80f0b8:	68 00 f0 7f 00       	push   $0x7ff000
  80f0bd:	6a 00                	push   $0x0
  80f0bf:	e8 7a fd ff ff       	call   80ee3e <sys_page_unmap>
  80f0c4:	83 c4 10             	add    $0x10,%esp
  80f0c7:	85 c0                	test   %eax,%eax
  80f0c9:	79 14                	jns    80f0df <pgfault+0xf5>
        panic("page unmap failed\n");
  80f0cb:	83 ec 04             	sub    $0x4,%esp
  80f0ce:	68 8e 34 81 00       	push   $0x81348e
  80f0d3:	6a 2d                	push   $0x2d
  80f0d5:	68 5d 34 81 00       	push   $0x81345d
  80f0da:	e8 79 f2 ff ff       	call   80e358 <_panic>
	
	//panic("pgfault not implemented");
}
  80f0df:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f0e2:	c9                   	leave  
  80f0e3:	c3                   	ret    

0080f0e4 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f0e4:	55                   	push   %ebp
  80f0e5:	89 e5                	mov    %esp,%ebp
  80f0e7:	57                   	push   %edi
  80f0e8:	56                   	push   %esi
  80f0e9:	53                   	push   %ebx
  80f0ea:	83 ec 28             	sub    $0x28,%esp
	envid_t envid;
    uint32_t addr;
	int r;
	extern void _pgfault_upcall(void);
	 
	set_pgfault_handler(pgfault);
  80f0ed:	68 ea ef 80 00       	push   $0x80efea
  80f0f2:	e8 df 16 00 00       	call   8107d6 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  80f0f7:	b8 07 00 00 00       	mov    $0x7,%eax
  80f0fc:	cd 30                	int    $0x30
  80f0fe:	89 c7                	mov    %eax,%edi
  80f100:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    envid = sys_exofork();
	if (envid < 0)
  80f103:	83 c4 10             	add    $0x10,%esp
  80f106:	85 c0                	test   %eax,%eax
  80f108:	79 12                	jns    80f11c <fork+0x38>
		panic("sys_exofork: %e \n", envid);
  80f10a:	50                   	push   %eax
  80f10b:	68 a1 34 81 00       	push   $0x8134a1
  80f110:	6a 7a                	push   $0x7a
  80f112:	68 5d 34 81 00       	push   $0x81345d
  80f117:	e8 3c f2 ff ff       	call   80e358 <_panic>
  80f11c:	bb 00 00 00 00       	mov    $0x0,%ebx
	if (envid == 0) {
  80f121:	85 c0                	test   %eax,%eax
  80f123:	75 21                	jne    80f146 <fork+0x62>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f125:	e8 51 fc ff ff       	call   80ed7b <sys_getenvid>
  80f12a:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f12f:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f132:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f137:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
		return 0;
  80f13c:	b8 00 00 00 00       	mov    $0x0,%eax
  80f141:	e9 91 01 00 00       	jmp    80f2d7 <fork+0x1f3>
	}
	
	for (addr = 0; addr < USTACKTOP; addr += PGSIZE) {
    	if ((uvpd[PDX(addr)] & PTE_P) && (uvpt[PGNUM(addr)] & PTE_P ) && (uvpt[PGNUM(addr)] & PTE_U )) {
  80f146:	89 d8                	mov    %ebx,%eax
  80f148:	c1 e8 16             	shr    $0x16,%eax
  80f14b:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f152:	a8 01                	test   $0x1,%al
  80f154:	0f 84 06 01 00 00    	je     80f260 <fork+0x17c>
  80f15a:	89 d8                	mov    %ebx,%eax
  80f15c:	c1 e8 0c             	shr    $0xc,%eax
  80f15f:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f166:	f6 c2 01             	test   $0x1,%dl
  80f169:	0f 84 f1 00 00 00    	je     80f260 <fork+0x17c>
  80f16f:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f176:	f6 c2 04             	test   $0x4,%dl
  80f179:	0f 84 e1 00 00 00    	je     80f260 <fork+0x17c>
duppage(envid_t envid, unsigned pn)
{
	int r;
    pte_t ptEntry;
    pde_t pdEntry;
    void *addr = (void *)(pn * PGSIZE);
  80f17f:	89 c6                	mov    %eax,%esi
  80f181:	c1 e6 0c             	shl    $0xc,%esi
	// LAB 4: Your code here.
    pdEntry = uvpd[PDX(addr)];
  80f184:	89 f2                	mov    %esi,%edx
  80f186:	c1 ea 16             	shr    $0x16,%edx
  80f189:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
    ptEntry = uvpt[pn]; 
  80f190:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
    
    if (ptEntry & PTE_SHARE) {
  80f197:	f6 c6 04             	test   $0x4,%dh
  80f19a:	74 39                	je     80f1d5 <fork+0xf1>
    	// Share this page with parent
        if ((r = sys_page_map(0, addr, envid, addr, uvpt[pn] & PTE_SYSCALL)) < 0)
  80f19c:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f1a3:	83 ec 0c             	sub    $0xc,%esp
  80f1a6:	25 07 0e 00 00       	and    $0xe07,%eax
  80f1ab:	50                   	push   %eax
  80f1ac:	56                   	push   %esi
  80f1ad:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f1b0:	56                   	push   %esi
  80f1b1:	6a 00                	push   $0x0
  80f1b3:	e8 44 fc ff ff       	call   80edfc <sys_page_map>
  80f1b8:	83 c4 20             	add    $0x20,%esp
  80f1bb:	85 c0                	test   %eax,%eax
  80f1bd:	0f 89 9d 00 00 00    	jns    80f260 <fork+0x17c>
        	panic("duppage: sys_page_map page to be shared %e \n", r);
  80f1c3:	50                   	push   %eax
  80f1c4:	68 f8 34 81 00       	push   $0x8134f8
  80f1c9:	6a 4b                	push   $0x4b
  80f1cb:	68 5d 34 81 00       	push   $0x81345d
  80f1d0:	e8 83 f1 ff ff       	call   80e358 <_panic>
    }
    else if (ptEntry & PTE_W || ptEntry & PTE_COW) {
  80f1d5:	f7 c2 02 08 00 00    	test   $0x802,%edx
  80f1db:	74 59                	je     80f236 <fork+0x152>
    	// Map to new env COW
        if ((r = sys_page_map(0, addr, envid, addr, PTE_COW | PTE_U | PTE_P)) < 0)
  80f1dd:	83 ec 0c             	sub    $0xc,%esp
  80f1e0:	68 05 08 00 00       	push   $0x805
  80f1e5:	56                   	push   %esi
  80f1e6:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f1e9:	56                   	push   %esi
  80f1ea:	6a 00                	push   $0x0
  80f1ec:	e8 0b fc ff ff       	call   80edfc <sys_page_map>
  80f1f1:	83 c4 20             	add    $0x20,%esp
  80f1f4:	85 c0                	test   %eax,%eax
  80f1f6:	79 12                	jns    80f20a <fork+0x126>
        	panic("duppage: sys_page_map to new env %e \n", r);
  80f1f8:	50                   	push   %eax
  80f1f9:	68 28 35 81 00       	push   $0x813528
  80f1fe:	6a 50                	push   $0x50
  80f200:	68 5d 34 81 00       	push   $0x81345d
  80f205:	e8 4e f1 ff ff       	call   80e358 <_panic>
        // Remap our own to COW
        if ((r = sys_page_map(0, addr, 0, addr, PTE_COW | PTE_U | PTE_P)) < 0)
  80f20a:	83 ec 0c             	sub    $0xc,%esp
  80f20d:	68 05 08 00 00       	push   $0x805
  80f212:	56                   	push   %esi
  80f213:	6a 00                	push   $0x0
  80f215:	56                   	push   %esi
  80f216:	6a 00                	push   $0x0
  80f218:	e8 df fb ff ff       	call   80edfc <sys_page_map>
  80f21d:	83 c4 20             	add    $0x20,%esp
  80f220:	85 c0                	test   %eax,%eax
  80f222:	79 3c                	jns    80f260 <fork+0x17c>
            panic("duppage: sys_page_map for remap %e \n", r);
  80f224:	50                   	push   %eax
  80f225:	68 50 35 81 00       	push   $0x813550
  80f22a:	6a 53                	push   $0x53
  80f22c:	68 5d 34 81 00       	push   $0x81345d
  80f231:	e8 22 f1 ff ff       	call   80e358 <_panic>
    }
    else {
    	// Just directly map pages that are present but not W or COW
        if ((r = sys_page_map(0, addr, envid, addr, PTE_P | PTE_U)) < 0)
  80f236:	83 ec 0c             	sub    $0xc,%esp
  80f239:	6a 05                	push   $0x5
  80f23b:	56                   	push   %esi
  80f23c:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f23f:	56                   	push   %esi
  80f240:	6a 00                	push   $0x0
  80f242:	e8 b5 fb ff ff       	call   80edfc <sys_page_map>
  80f247:	83 c4 20             	add    $0x20,%esp
  80f24a:	85 c0                	test   %eax,%eax
  80f24c:	79 12                	jns    80f260 <fork+0x17c>
        	panic("duppage: sys_page_map to new env PTE_P %e \n", r);
  80f24e:	50                   	push   %eax
  80f24f:	68 78 35 81 00       	push   $0x813578
  80f254:	6a 58                	push   $0x58
  80f256:	68 5d 34 81 00       	push   $0x81345d
  80f25b:	e8 f8 f0 ff ff       	call   80e358 <_panic>
	if (envid == 0) {
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	
	for (addr = 0; addr < USTACKTOP; addr += PGSIZE) {
  80f260:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f266:	81 fb 00 e0 bf ee    	cmp    $0xeebfe000,%ebx
  80f26c:	0f 85 d4 fe ff ff    	jne    80f146 <fork+0x62>
    	if ((uvpd[PDX(addr)] & PTE_P) && (uvpt[PGNUM(addr)] & PTE_P ) && (uvpt[PGNUM(addr)] & PTE_U )) {
            duppage(envid, PGNUM(addr));
        }
	}
	
	if (sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_W| PTE_P) < 0)
  80f272:	83 ec 04             	sub    $0x4,%esp
  80f275:	6a 07                	push   $0x7
  80f277:	68 00 f0 bf ee       	push   $0xeebff000
  80f27c:	57                   	push   %edi
  80f27d:	e8 37 fb ff ff       	call   80edb9 <sys_page_alloc>
  80f282:	83 c4 10             	add    $0x10,%esp
  80f285:	85 c0                	test   %eax,%eax
  80f287:	79 17                	jns    80f2a0 <fork+0x1bc>
        panic("page alloc failed\n");
  80f289:	83 ec 04             	sub    $0x4,%esp
  80f28c:	68 b3 34 81 00       	push   $0x8134b3
  80f291:	68 87 00 00 00       	push   $0x87
  80f296:	68 5d 34 81 00       	push   $0x81345d
  80f29b:	e8 b8 f0 ff ff       	call   80e358 <_panic>
	
	sys_env_set_pgfault_upcall(envid, _pgfault_upcall);
  80f2a0:	83 ec 08             	sub    $0x8,%esp
  80f2a3:	68 45 08 81 00       	push   $0x810845
  80f2a8:	57                   	push   %edi
  80f2a9:	e8 56 fc ff ff       	call   80ef04 <sys_env_set_pgfault_upcall>
	
	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0)
  80f2ae:	83 c4 08             	add    $0x8,%esp
  80f2b1:	6a 02                	push   $0x2
  80f2b3:	57                   	push   %edi
  80f2b4:	e8 c7 fb ff ff       	call   80ee80 <sys_env_set_status>
  80f2b9:	83 c4 10             	add    $0x10,%esp
  80f2bc:	85 c0                	test   %eax,%eax
  80f2be:	79 15                	jns    80f2d5 <fork+0x1f1>
		panic("sys_env_set_status: %e \n", r);
  80f2c0:	50                   	push   %eax
  80f2c1:	68 c6 34 81 00       	push   $0x8134c6
  80f2c6:	68 8c 00 00 00       	push   $0x8c
  80f2cb:	68 5d 34 81 00       	push   $0x81345d
  80f2d0:	e8 83 f0 ff ff       	call   80e358 <_panic>

	return envid;
  80f2d5:	89 f8                	mov    %edi,%eax
	
	
	//panic("fork not implemented");
}
  80f2d7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f2da:	5b                   	pop    %ebx
  80f2db:	5e                   	pop    %esi
  80f2dc:	5f                   	pop    %edi
  80f2dd:	5d                   	pop    %ebp
  80f2de:	c3                   	ret    

0080f2df <sfork>:

// Challenge!
int
sfork(void)
{
  80f2df:	55                   	push   %ebp
  80f2e0:	89 e5                	mov    %esp,%ebp
  80f2e2:	83 ec 0c             	sub    $0xc,%esp
	panic("sfork not implemented");
  80f2e5:	68 df 34 81 00       	push   $0x8134df
  80f2ea:	68 98 00 00 00       	push   $0x98
  80f2ef:	68 5d 34 81 00       	push   $0x81345d
  80f2f4:	e8 5f f0 ff ff       	call   80e358 <_panic>

0080f2f9 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80f2f9:	55                   	push   %ebp
  80f2fa:	89 e5                	mov    %esp,%ebp
  80f2fc:	56                   	push   %esi
  80f2fd:	53                   	push   %ebx
  80f2fe:	8b 75 08             	mov    0x8(%ebp),%esi
  80f301:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f304:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int ret;
	// LAB 4: Your code here.
    //if (!pg) {
    //	pg = (void*) -1;
    //}	
    if(pg != NULL)
  80f307:	85 c0                	test   %eax,%eax
  80f309:	74 0e                	je     80f319 <ipc_recv+0x20>
	{
	 	ret = sys_ipc_recv(pg);
  80f30b:	83 ec 0c             	sub    $0xc,%esp
  80f30e:	50                   	push   %eax
  80f30f:	e8 55 fc ff ff       	call   80ef69 <sys_ipc_recv>
  80f314:	83 c4 10             	add    $0x10,%esp
  80f317:	eb 10                	jmp    80f329 <ipc_recv+0x30>
		//cprintf("back from the rev wait\n");
	}
	else
	{
		ret = sys_ipc_recv((void * )0xF0000000);
  80f319:	83 ec 0c             	sub    $0xc,%esp
  80f31c:	68 00 00 00 f0       	push   $0xf0000000
  80f321:	e8 43 fc ff ff       	call   80ef69 <sys_ipc_recv>
  80f326:	83 c4 10             	add    $0x10,%esp
	}
    //int ret = sys_ipc_recv(pg);
    if (ret) {
  80f329:	85 c0                	test   %eax,%eax
  80f32b:	74 0e                	je     80f33b <ipc_recv+0x42>
    	*from_env_store = 0;
  80f32d:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    	*perm_store = 0;
  80f333:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    	return ret;
  80f339:	eb 24                	jmp    80f35f <ipc_recv+0x66>
    }	
    if (from_env_store) {
  80f33b:	85 f6                	test   %esi,%esi
  80f33d:	74 0a                	je     80f349 <ipc_recv+0x50>
        *from_env_store = thisenv->env_ipc_from;
  80f33f:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f344:	8b 40 74             	mov    0x74(%eax),%eax
  80f347:	89 06                	mov    %eax,(%esi)
    }    
    if (perm_store) {
  80f349:	85 db                	test   %ebx,%ebx
  80f34b:	74 0a                	je     80f357 <ipc_recv+0x5e>
        *perm_store = thisenv->env_ipc_perm;
  80f34d:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f352:	8b 40 78             	mov    0x78(%eax),%eax
  80f355:	89 03                	mov    %eax,(%ebx)
    }
    return thisenv->env_ipc_value;
  80f357:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f35c:	8b 40 70             	mov    0x70(%eax),%eax
	//panic("ipc_recv not implemented");
	//return 0;
}
  80f35f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f362:	5b                   	pop    %ebx
  80f363:	5e                   	pop    %esi
  80f364:	5d                   	pop    %ebp
  80f365:	c3                   	ret    

0080f366 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  80f366:	55                   	push   %ebp
  80f367:	89 e5                	mov    %esp,%ebp
  80f369:	57                   	push   %edi
  80f36a:	56                   	push   %esi
  80f36b:	53                   	push   %ebx
  80f36c:	83 ec 0c             	sub    $0xc,%esp
  80f36f:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f372:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f375:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	if (!pg) {
  80f378:	85 db                	test   %ebx,%ebx
		pg = (void*)-1;
  80f37a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80f37f:	0f 44 d8             	cmove  %eax,%ebx
  80f382:	eb 1c                	jmp    80f3a0 <ipc_send+0x3a>
	}	
    int ret;
    while ((ret = sys_ipc_try_send(to_env, val, pg, perm))) {
        //if (ret == 0) break;
        if (ret != -E_IPC_NOT_RECV) {
  80f384:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80f387:	74 12                	je     80f39b <ipc_send+0x35>
        	panic("not E_IPC_NOT_RECV, %e\n", ret);
  80f389:	50                   	push   %eax
  80f38a:	68 a4 35 81 00       	push   $0x8135a4
  80f38f:	6a 4b                	push   $0x4b
  80f391:	68 bc 35 81 00       	push   $0x8135bc
  80f396:	e8 bd ef ff ff       	call   80e358 <_panic>
        }	
        sys_yield();
  80f39b:	e8 fa f9 ff ff       	call   80ed9a <sys_yield>
	// LAB 4: Your code here.
	if (!pg) {
		pg = (void*)-1;
	}	
    int ret;
    while ((ret = sys_ipc_try_send(to_env, val, pg, perm))) {
  80f3a0:	ff 75 14             	pushl  0x14(%ebp)
  80f3a3:	53                   	push   %ebx
  80f3a4:	56                   	push   %esi
  80f3a5:	57                   	push   %edi
  80f3a6:	e8 9b fb ff ff       	call   80ef46 <sys_ipc_try_send>
  80f3ab:	83 c4 10             	add    $0x10,%esp
  80f3ae:	85 c0                	test   %eax,%eax
  80f3b0:	75 d2                	jne    80f384 <ipc_send+0x1e>
        }	
        sys_yield();
    }
   //return;
	//panic("ipc_send not implemented");
}
  80f3b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f3b5:	5b                   	pop    %ebx
  80f3b6:	5e                   	pop    %esi
  80f3b7:	5f                   	pop    %edi
  80f3b8:	5d                   	pop    %ebp
  80f3b9:	c3                   	ret    

0080f3ba <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80f3ba:	55                   	push   %ebp
  80f3bb:	89 e5                	mov    %esp,%ebp
  80f3bd:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80f3c0:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80f3c5:	6b d0 7c             	imul   $0x7c,%eax,%edx
  80f3c8:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80f3ce:	8b 52 50             	mov    0x50(%edx),%edx
  80f3d1:	39 ca                	cmp    %ecx,%edx
  80f3d3:	75 0d                	jne    80f3e2 <ipc_find_env+0x28>
			return envs[i].env_id;
  80f3d5:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f3d8:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f3dd:	8b 40 48             	mov    0x48(%eax),%eax
  80f3e0:	eb 0f                	jmp    80f3f1 <ipc_find_env+0x37>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  80f3e2:	83 c0 01             	add    $0x1,%eax
  80f3e5:	3d 00 04 00 00       	cmp    $0x400,%eax
  80f3ea:	75 d9                	jne    80f3c5 <ipc_find_env+0xb>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
  80f3ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f3f1:	5d                   	pop    %ebp
  80f3f2:	c3                   	ret    

0080f3f3 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80f3f3:	55                   	push   %ebp
  80f3f4:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f3f6:	8b 45 08             	mov    0x8(%ebp),%eax
  80f3f9:	05 00 00 00 30       	add    $0x30000000,%eax
  80f3fe:	c1 e8 0c             	shr    $0xc,%eax
}
  80f401:	5d                   	pop    %ebp
  80f402:	c3                   	ret    

0080f403 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80f403:	55                   	push   %ebp
  80f404:	89 e5                	mov    %esp,%ebp
	return INDEX2DATA(fd2num(fd));
  80f406:	8b 45 08             	mov    0x8(%ebp),%eax
  80f409:	05 00 00 00 30       	add    $0x30000000,%eax
  80f40e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f413:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80f418:	5d                   	pop    %ebp
  80f419:	c3                   	ret    

0080f41a <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80f41a:	55                   	push   %ebp
  80f41b:	89 e5                	mov    %esp,%ebp
  80f41d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f420:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80f425:	89 c2                	mov    %eax,%edx
  80f427:	c1 ea 16             	shr    $0x16,%edx
  80f42a:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f431:	f6 c2 01             	test   $0x1,%dl
  80f434:	74 11                	je     80f447 <fd_alloc+0x2d>
  80f436:	89 c2                	mov    %eax,%edx
  80f438:	c1 ea 0c             	shr    $0xc,%edx
  80f43b:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f442:	f6 c2 01             	test   $0x1,%dl
  80f445:	75 09                	jne    80f450 <fd_alloc+0x36>
			*fd_store = fd;
  80f447:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f449:	b8 00 00 00 00       	mov    $0x0,%eax
  80f44e:	eb 17                	jmp    80f467 <fd_alloc+0x4d>
  80f450:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  80f455:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80f45a:	75 c9                	jne    80f425 <fd_alloc+0xb>
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80f45c:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	return -E_MAX_OPEN;
  80f462:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
  80f467:	5d                   	pop    %ebp
  80f468:	c3                   	ret    

0080f469 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80f469:	55                   	push   %ebp
  80f46a:	89 e5                	mov    %esp,%ebp
  80f46c:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80f46f:	83 f8 1f             	cmp    $0x1f,%eax
  80f472:	77 36                	ja     80f4aa <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80f474:	c1 e0 0c             	shl    $0xc,%eax
  80f477:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80f47c:	89 c2                	mov    %eax,%edx
  80f47e:	c1 ea 16             	shr    $0x16,%edx
  80f481:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f488:	f6 c2 01             	test   $0x1,%dl
  80f48b:	74 24                	je     80f4b1 <fd_lookup+0x48>
  80f48d:	89 c2                	mov    %eax,%edx
  80f48f:	c1 ea 0c             	shr    $0xc,%edx
  80f492:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f499:	f6 c2 01             	test   $0x1,%dl
  80f49c:	74 1a                	je     80f4b8 <fd_lookup+0x4f>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80f49e:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f4a1:	89 02                	mov    %eax,(%edx)
	return 0;
  80f4a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80f4a8:	eb 13                	jmp    80f4bd <fd_lookup+0x54>
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80f4aa:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f4af:	eb 0c                	jmp    80f4bd <fd_lookup+0x54>
	}
	fd = INDEX2FD(fdnum);
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80f4b1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f4b6:	eb 05                	jmp    80f4bd <fd_lookup+0x54>
  80f4b8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	}
	*fd_store = fd;
	return 0;
}
  80f4bd:	5d                   	pop    %ebp
  80f4be:	c3                   	ret    

0080f4bf <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80f4bf:	55                   	push   %ebp
  80f4c0:	89 e5                	mov    %esp,%ebp
  80f4c2:	83 ec 08             	sub    $0x8,%esp
  80f4c5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f4c8:	ba 44 36 81 00       	mov    $0x813644,%edx
	int i;
	for (i = 0; devtab[i]; i++)
  80f4cd:	eb 13                	jmp    80f4e2 <dev_lookup+0x23>
  80f4cf:	83 c2 04             	add    $0x4,%edx
		if (devtab[i]->dev_id == dev_id) {
  80f4d2:	39 08                	cmp    %ecx,(%eax)
  80f4d4:	75 0c                	jne    80f4e2 <dev_lookup+0x23>
			*dev = devtab[i];
  80f4d6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f4d9:	89 01                	mov    %eax,(%ecx)
			return 0;
  80f4db:	b8 00 00 00 00       	mov    $0x0,%eax
  80f4e0:	eb 2e                	jmp    80f510 <dev_lookup+0x51>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  80f4e2:	8b 02                	mov    (%edx),%eax
  80f4e4:	85 c0                	test   %eax,%eax
  80f4e6:	75 e7                	jne    80f4cf <dev_lookup+0x10>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80f4e8:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f4ed:	8b 40 48             	mov    0x48(%eax),%eax
  80f4f0:	83 ec 04             	sub    $0x4,%esp
  80f4f3:	51                   	push   %ecx
  80f4f4:	50                   	push   %eax
  80f4f5:	68 c8 35 81 00       	push   $0x8135c8
  80f4fa:	e8 32 ef ff ff       	call   80e431 <cprintf>
	*dev = 0;
  80f4ff:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f502:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80f508:	83 c4 10             	add    $0x10,%esp
  80f50b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80f510:	c9                   	leave  
  80f511:	c3                   	ret    

0080f512 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  80f512:	55                   	push   %ebp
  80f513:	89 e5                	mov    %esp,%ebp
  80f515:	56                   	push   %esi
  80f516:	53                   	push   %ebx
  80f517:	83 ec 10             	sub    $0x10,%esp
  80f51a:	8b 75 08             	mov    0x8(%ebp),%esi
  80f51d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80f520:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f523:	50                   	push   %eax
  80f524:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80f52a:	c1 e8 0c             	shr    $0xc,%eax
  80f52d:	50                   	push   %eax
  80f52e:	e8 36 ff ff ff       	call   80f469 <fd_lookup>
  80f533:	83 c4 08             	add    $0x8,%esp
  80f536:	85 c0                	test   %eax,%eax
  80f538:	78 05                	js     80f53f <fd_close+0x2d>
	    || fd != fd2)
  80f53a:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  80f53d:	74 0c                	je     80f54b <fd_close+0x39>
		return (must_exist ? r : 0);
  80f53f:	84 db                	test   %bl,%bl
  80f541:	ba 00 00 00 00       	mov    $0x0,%edx
  80f546:	0f 44 c2             	cmove  %edx,%eax
  80f549:	eb 41                	jmp    80f58c <fd_close+0x7a>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80f54b:	83 ec 08             	sub    $0x8,%esp
  80f54e:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f551:	50                   	push   %eax
  80f552:	ff 36                	pushl  (%esi)
  80f554:	e8 66 ff ff ff       	call   80f4bf <dev_lookup>
  80f559:	89 c3                	mov    %eax,%ebx
  80f55b:	83 c4 10             	add    $0x10,%esp
  80f55e:	85 c0                	test   %eax,%eax
  80f560:	78 1a                	js     80f57c <fd_close+0x6a>
		if (dev->dev_close)
  80f562:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f565:	8b 40 10             	mov    0x10(%eax),%eax
			r = (*dev->dev_close)(fd);
		else
			r = 0;
  80f568:	bb 00 00 00 00       	mov    $0x0,%ebx
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
	    || fd != fd2)
		return (must_exist ? r : 0);
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
		if (dev->dev_close)
  80f56d:	85 c0                	test   %eax,%eax
  80f56f:	74 0b                	je     80f57c <fd_close+0x6a>
			r = (*dev->dev_close)(fd);
  80f571:	83 ec 0c             	sub    $0xc,%esp
  80f574:	56                   	push   %esi
  80f575:	ff d0                	call   *%eax
  80f577:	89 c3                	mov    %eax,%ebx
  80f579:	83 c4 10             	add    $0x10,%esp
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  80f57c:	83 ec 08             	sub    $0x8,%esp
  80f57f:	56                   	push   %esi
  80f580:	6a 00                	push   $0x0
  80f582:	e8 b7 f8 ff ff       	call   80ee3e <sys_page_unmap>
	return r;
  80f587:	83 c4 10             	add    $0x10,%esp
  80f58a:	89 d8                	mov    %ebx,%eax
}
  80f58c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f58f:	5b                   	pop    %ebx
  80f590:	5e                   	pop    %esi
  80f591:	5d                   	pop    %ebp
  80f592:	c3                   	ret    

0080f593 <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  80f593:	55                   	push   %ebp
  80f594:	89 e5                	mov    %esp,%ebp
  80f596:	83 ec 18             	sub    $0x18,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f599:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f59c:	50                   	push   %eax
  80f59d:	ff 75 08             	pushl  0x8(%ebp)
  80f5a0:	e8 c4 fe ff ff       	call   80f469 <fd_lookup>
  80f5a5:	83 c4 08             	add    $0x8,%esp
  80f5a8:	85 c0                	test   %eax,%eax
  80f5aa:	78 10                	js     80f5bc <close+0x29>
		return r;
	else
		return fd_close(fd, 1);
  80f5ac:	83 ec 08             	sub    $0x8,%esp
  80f5af:	6a 01                	push   $0x1
  80f5b1:	ff 75 f4             	pushl  -0xc(%ebp)
  80f5b4:	e8 59 ff ff ff       	call   80f512 <fd_close>
  80f5b9:	83 c4 10             	add    $0x10,%esp
}
  80f5bc:	c9                   	leave  
  80f5bd:	c3                   	ret    

0080f5be <close_all>:

void
close_all(void)
{
  80f5be:	55                   	push   %ebp
  80f5bf:	89 e5                	mov    %esp,%ebp
  80f5c1:	53                   	push   %ebx
  80f5c2:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80f5c5:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80f5ca:	83 ec 0c             	sub    $0xc,%esp
  80f5cd:	53                   	push   %ebx
  80f5ce:	e8 c0 ff ff ff       	call   80f593 <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  80f5d3:	83 c3 01             	add    $0x1,%ebx
  80f5d6:	83 c4 10             	add    $0x10,%esp
  80f5d9:	83 fb 20             	cmp    $0x20,%ebx
  80f5dc:	75 ec                	jne    80f5ca <close_all+0xc>
		close(i);
}
  80f5de:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f5e1:	c9                   	leave  
  80f5e2:	c3                   	ret    

0080f5e3 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80f5e3:	55                   	push   %ebp
  80f5e4:	89 e5                	mov    %esp,%ebp
  80f5e6:	57                   	push   %edi
  80f5e7:	56                   	push   %esi
  80f5e8:	53                   	push   %ebx
  80f5e9:	83 ec 2c             	sub    $0x2c,%esp
  80f5ec:	8b 75 0c             	mov    0xc(%ebp),%esi
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80f5ef:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80f5f2:	50                   	push   %eax
  80f5f3:	ff 75 08             	pushl  0x8(%ebp)
  80f5f6:	e8 6e fe ff ff       	call   80f469 <fd_lookup>
  80f5fb:	83 c4 08             	add    $0x8,%esp
  80f5fe:	85 c0                	test   %eax,%eax
  80f600:	0f 88 c1 00 00 00    	js     80f6c7 <dup+0xe4>
		return r;
	close(newfdnum);
  80f606:	83 ec 0c             	sub    $0xc,%esp
  80f609:	56                   	push   %esi
  80f60a:	e8 84 ff ff ff       	call   80f593 <close>

	newfd = INDEX2FD(newfdnum);
  80f60f:	89 f3                	mov    %esi,%ebx
  80f611:	c1 e3 0c             	shl    $0xc,%ebx
  80f614:	81 eb 00 00 00 30    	sub    $0x30000000,%ebx
	ova = fd2data(oldfd);
  80f61a:	83 c4 04             	add    $0x4,%esp
  80f61d:	ff 75 e4             	pushl  -0x1c(%ebp)
  80f620:	e8 de fd ff ff       	call   80f403 <fd2data>
  80f625:	89 c7                	mov    %eax,%edi
	nva = fd2data(newfd);
  80f627:	89 1c 24             	mov    %ebx,(%esp)
  80f62a:	e8 d4 fd ff ff       	call   80f403 <fd2data>
  80f62f:	83 c4 10             	add    $0x10,%esp
  80f632:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80f635:	89 f8                	mov    %edi,%eax
  80f637:	c1 e8 16             	shr    $0x16,%eax
  80f63a:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f641:	a8 01                	test   $0x1,%al
  80f643:	74 37                	je     80f67c <dup+0x99>
  80f645:	89 f8                	mov    %edi,%eax
  80f647:	c1 e8 0c             	shr    $0xc,%eax
  80f64a:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80f651:	f6 c2 01             	test   $0x1,%dl
  80f654:	74 26                	je     80f67c <dup+0x99>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80f656:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f65d:	83 ec 0c             	sub    $0xc,%esp
  80f660:	25 07 0e 00 00       	and    $0xe07,%eax
  80f665:	50                   	push   %eax
  80f666:	ff 75 d4             	pushl  -0x2c(%ebp)
  80f669:	6a 00                	push   $0x0
  80f66b:	57                   	push   %edi
  80f66c:	6a 00                	push   $0x0
  80f66e:	e8 89 f7 ff ff       	call   80edfc <sys_page_map>
  80f673:	89 c7                	mov    %eax,%edi
  80f675:	83 c4 20             	add    $0x20,%esp
  80f678:	85 c0                	test   %eax,%eax
  80f67a:	78 2e                	js     80f6aa <dup+0xc7>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80f67c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80f67f:	89 d0                	mov    %edx,%eax
  80f681:	c1 e8 0c             	shr    $0xc,%eax
  80f684:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f68b:	83 ec 0c             	sub    $0xc,%esp
  80f68e:	25 07 0e 00 00       	and    $0xe07,%eax
  80f693:	50                   	push   %eax
  80f694:	53                   	push   %ebx
  80f695:	6a 00                	push   $0x0
  80f697:	52                   	push   %edx
  80f698:	6a 00                	push   $0x0
  80f69a:	e8 5d f7 ff ff       	call   80edfc <sys_page_map>
  80f69f:	89 c7                	mov    %eax,%edi
  80f6a1:	83 c4 20             	add    $0x20,%esp
		goto err;

	return newfdnum;
  80f6a4:	89 f0                	mov    %esi,%eax
	nva = fd2data(newfd);

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80f6a6:	85 ff                	test   %edi,%edi
  80f6a8:	79 1d                	jns    80f6c7 <dup+0xe4>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  80f6aa:	83 ec 08             	sub    $0x8,%esp
  80f6ad:	53                   	push   %ebx
  80f6ae:	6a 00                	push   $0x0
  80f6b0:	e8 89 f7 ff ff       	call   80ee3e <sys_page_unmap>
	sys_page_unmap(0, nva);
  80f6b5:	83 c4 08             	add    $0x8,%esp
  80f6b8:	ff 75 d4             	pushl  -0x2c(%ebp)
  80f6bb:	6a 00                	push   $0x0
  80f6bd:	e8 7c f7 ff ff       	call   80ee3e <sys_page_unmap>
	return r;
  80f6c2:	83 c4 10             	add    $0x10,%esp
  80f6c5:	89 f8                	mov    %edi,%eax
}
  80f6c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f6ca:	5b                   	pop    %ebx
  80f6cb:	5e                   	pop    %esi
  80f6cc:	5f                   	pop    %edi
  80f6cd:	5d                   	pop    %ebp
  80f6ce:	c3                   	ret    

0080f6cf <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80f6cf:	55                   	push   %ebp
  80f6d0:	89 e5                	mov    %esp,%ebp
  80f6d2:	53                   	push   %ebx
  80f6d3:	83 ec 14             	sub    $0x14,%esp
  80f6d6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f6d9:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f6dc:	50                   	push   %eax
  80f6dd:	53                   	push   %ebx
  80f6de:	e8 86 fd ff ff       	call   80f469 <fd_lookup>
  80f6e3:	83 c4 08             	add    $0x8,%esp
  80f6e6:	89 c2                	mov    %eax,%edx
  80f6e8:	85 c0                	test   %eax,%eax
  80f6ea:	78 6d                	js     80f759 <read+0x8a>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f6ec:	83 ec 08             	sub    $0x8,%esp
  80f6ef:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f6f2:	50                   	push   %eax
  80f6f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f6f6:	ff 30                	pushl  (%eax)
  80f6f8:	e8 c2 fd ff ff       	call   80f4bf <dev_lookup>
  80f6fd:	83 c4 10             	add    $0x10,%esp
  80f700:	85 c0                	test   %eax,%eax
  80f702:	78 4c                	js     80f750 <read+0x81>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80f704:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80f707:	8b 42 08             	mov    0x8(%edx),%eax
  80f70a:	83 e0 03             	and    $0x3,%eax
  80f70d:	83 f8 01             	cmp    $0x1,%eax
  80f710:	75 21                	jne    80f733 <read+0x64>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80f712:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f717:	8b 40 48             	mov    0x48(%eax),%eax
  80f71a:	83 ec 04             	sub    $0x4,%esp
  80f71d:	53                   	push   %ebx
  80f71e:	50                   	push   %eax
  80f71f:	68 09 36 81 00       	push   $0x813609
  80f724:	e8 08 ed ff ff       	call   80e431 <cprintf>
		return -E_INVAL;
  80f729:	83 c4 10             	add    $0x10,%esp
  80f72c:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f731:	eb 26                	jmp    80f759 <read+0x8a>
	}
	if (!dev->dev_read)
  80f733:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f736:	8b 40 08             	mov    0x8(%eax),%eax
  80f739:	85 c0                	test   %eax,%eax
  80f73b:	74 17                	je     80f754 <read+0x85>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80f73d:	83 ec 04             	sub    $0x4,%esp
  80f740:	ff 75 10             	pushl  0x10(%ebp)
  80f743:	ff 75 0c             	pushl  0xc(%ebp)
  80f746:	52                   	push   %edx
  80f747:	ff d0                	call   *%eax
  80f749:	89 c2                	mov    %eax,%edx
  80f74b:	83 c4 10             	add    $0x10,%esp
  80f74e:	eb 09                	jmp    80f759 <read+0x8a>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f750:	89 c2                	mov    %eax,%edx
  80f752:	eb 05                	jmp    80f759 <read+0x8a>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
		return -E_NOT_SUPP;
  80f754:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_read)(fd, buf, n);
}
  80f759:	89 d0                	mov    %edx,%eax
  80f75b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f75e:	c9                   	leave  
  80f75f:	c3                   	ret    

0080f760 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80f760:	55                   	push   %ebp
  80f761:	89 e5                	mov    %esp,%ebp
  80f763:	57                   	push   %edi
  80f764:	56                   	push   %esi
  80f765:	53                   	push   %ebx
  80f766:	83 ec 0c             	sub    $0xc,%esp
  80f769:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f76c:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80f76f:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f774:	eb 21                	jmp    80f797 <readn+0x37>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80f776:	83 ec 04             	sub    $0x4,%esp
  80f779:	89 f0                	mov    %esi,%eax
  80f77b:	29 d8                	sub    %ebx,%eax
  80f77d:	50                   	push   %eax
  80f77e:	89 d8                	mov    %ebx,%eax
  80f780:	03 45 0c             	add    0xc(%ebp),%eax
  80f783:	50                   	push   %eax
  80f784:	57                   	push   %edi
  80f785:	e8 45 ff ff ff       	call   80f6cf <read>
		if (m < 0)
  80f78a:	83 c4 10             	add    $0x10,%esp
  80f78d:	85 c0                	test   %eax,%eax
  80f78f:	78 10                	js     80f7a1 <readn+0x41>
			return m;
		if (m == 0)
  80f791:	85 c0                	test   %eax,%eax
  80f793:	74 0a                	je     80f79f <readn+0x3f>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80f795:	01 c3                	add    %eax,%ebx
  80f797:	39 f3                	cmp    %esi,%ebx
  80f799:	72 db                	jb     80f776 <readn+0x16>
  80f79b:	89 d8                	mov    %ebx,%eax
  80f79d:	eb 02                	jmp    80f7a1 <readn+0x41>
  80f79f:	89 d8                	mov    %ebx,%eax
			return m;
		if (m == 0)
			break;
	}
	return tot;
}
  80f7a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f7a4:	5b                   	pop    %ebx
  80f7a5:	5e                   	pop    %esi
  80f7a6:	5f                   	pop    %edi
  80f7a7:	5d                   	pop    %ebp
  80f7a8:	c3                   	ret    

0080f7a9 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80f7a9:	55                   	push   %ebp
  80f7aa:	89 e5                	mov    %esp,%ebp
  80f7ac:	53                   	push   %ebx
  80f7ad:	83 ec 14             	sub    $0x14,%esp
  80f7b0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f7b3:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f7b6:	50                   	push   %eax
  80f7b7:	53                   	push   %ebx
  80f7b8:	e8 ac fc ff ff       	call   80f469 <fd_lookup>
  80f7bd:	83 c4 08             	add    $0x8,%esp
  80f7c0:	89 c2                	mov    %eax,%edx
  80f7c2:	85 c0                	test   %eax,%eax
  80f7c4:	78 68                	js     80f82e <write+0x85>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f7c6:	83 ec 08             	sub    $0x8,%esp
  80f7c9:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f7cc:	50                   	push   %eax
  80f7cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f7d0:	ff 30                	pushl  (%eax)
  80f7d2:	e8 e8 fc ff ff       	call   80f4bf <dev_lookup>
  80f7d7:	83 c4 10             	add    $0x10,%esp
  80f7da:	85 c0                	test   %eax,%eax
  80f7dc:	78 47                	js     80f825 <write+0x7c>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80f7de:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f7e1:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80f7e5:	75 21                	jne    80f808 <write+0x5f>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  80f7e7:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f7ec:	8b 40 48             	mov    0x48(%eax),%eax
  80f7ef:	83 ec 04             	sub    $0x4,%esp
  80f7f2:	53                   	push   %ebx
  80f7f3:	50                   	push   %eax
  80f7f4:	68 25 36 81 00       	push   $0x813625
  80f7f9:	e8 33 ec ff ff       	call   80e431 <cprintf>
		return -E_INVAL;
  80f7fe:	83 c4 10             	add    $0x10,%esp
  80f801:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f806:	eb 26                	jmp    80f82e <write+0x85>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80f808:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80f80b:	8b 52 0c             	mov    0xc(%edx),%edx
  80f80e:	85 d2                	test   %edx,%edx
  80f810:	74 17                	je     80f829 <write+0x80>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80f812:	83 ec 04             	sub    $0x4,%esp
  80f815:	ff 75 10             	pushl  0x10(%ebp)
  80f818:	ff 75 0c             	pushl  0xc(%ebp)
  80f81b:	50                   	push   %eax
  80f81c:	ff d2                	call   *%edx
  80f81e:	89 c2                	mov    %eax,%edx
  80f820:	83 c4 10             	add    $0x10,%esp
  80f823:	eb 09                	jmp    80f82e <write+0x85>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f825:	89 c2                	mov    %eax,%edx
  80f827:	eb 05                	jmp    80f82e <write+0x85>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
		return -E_NOT_SUPP;
  80f829:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_write)(fd, buf, n);
}
  80f82e:	89 d0                	mov    %edx,%eax
  80f830:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f833:	c9                   	leave  
  80f834:	c3                   	ret    

0080f835 <seek>:

int
seek(int fdnum, off_t offset)
{
  80f835:	55                   	push   %ebp
  80f836:	89 e5                	mov    %esp,%ebp
  80f838:	83 ec 10             	sub    $0x10,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80f83b:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80f83e:	50                   	push   %eax
  80f83f:	ff 75 08             	pushl  0x8(%ebp)
  80f842:	e8 22 fc ff ff       	call   80f469 <fd_lookup>
  80f847:	83 c4 08             	add    $0x8,%esp
  80f84a:	85 c0                	test   %eax,%eax
  80f84c:	78 0e                	js     80f85c <seek+0x27>
		return r;
	fd->fd_offset = offset;
  80f84e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  80f851:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f854:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  80f857:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f85c:	c9                   	leave  
  80f85d:	c3                   	ret    

0080f85e <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  80f85e:	55                   	push   %ebp
  80f85f:	89 e5                	mov    %esp,%ebp
  80f861:	53                   	push   %ebx
  80f862:	83 ec 14             	sub    $0x14,%esp
  80f865:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f868:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f86b:	50                   	push   %eax
  80f86c:	53                   	push   %ebx
  80f86d:	e8 f7 fb ff ff       	call   80f469 <fd_lookup>
  80f872:	83 c4 08             	add    $0x8,%esp
  80f875:	89 c2                	mov    %eax,%edx
  80f877:	85 c0                	test   %eax,%eax
  80f879:	78 65                	js     80f8e0 <ftruncate+0x82>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f87b:	83 ec 08             	sub    $0x8,%esp
  80f87e:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f881:	50                   	push   %eax
  80f882:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f885:	ff 30                	pushl  (%eax)
  80f887:	e8 33 fc ff ff       	call   80f4bf <dev_lookup>
  80f88c:	83 c4 10             	add    $0x10,%esp
  80f88f:	85 c0                	test   %eax,%eax
  80f891:	78 44                	js     80f8d7 <ftruncate+0x79>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80f893:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f896:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80f89a:	75 21                	jne    80f8bd <ftruncate+0x5f>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  80f89c:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  80f8a1:	8b 40 48             	mov    0x48(%eax),%eax
  80f8a4:	83 ec 04             	sub    $0x4,%esp
  80f8a7:	53                   	push   %ebx
  80f8a8:	50                   	push   %eax
  80f8a9:	68 e8 35 81 00       	push   $0x8135e8
  80f8ae:	e8 7e eb ff ff       	call   80e431 <cprintf>
			thisenv->env_id, fdnum);
		return -E_INVAL;
  80f8b3:	83 c4 10             	add    $0x10,%esp
  80f8b6:	ba fd ff ff ff       	mov    $0xfffffffd,%edx
  80f8bb:	eb 23                	jmp    80f8e0 <ftruncate+0x82>
	}
	if (!dev->dev_trunc)
  80f8bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80f8c0:	8b 52 18             	mov    0x18(%edx),%edx
  80f8c3:	85 d2                	test   %edx,%edx
  80f8c5:	74 14                	je     80f8db <ftruncate+0x7d>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  80f8c7:	83 ec 08             	sub    $0x8,%esp
  80f8ca:	ff 75 0c             	pushl  0xc(%ebp)
  80f8cd:	50                   	push   %eax
  80f8ce:	ff d2                	call   *%edx
  80f8d0:	89 c2                	mov    %eax,%edx
  80f8d2:	83 c4 10             	add    $0x10,%esp
  80f8d5:	eb 09                	jmp    80f8e0 <ftruncate+0x82>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f8d7:	89 c2                	mov    %eax,%edx
  80f8d9:	eb 05                	jmp    80f8e0 <ftruncate+0x82>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
		return -E_NOT_SUPP;
  80f8db:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	return (*dev->dev_trunc)(fd, newsize);
}
  80f8e0:	89 d0                	mov    %edx,%eax
  80f8e2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f8e5:	c9                   	leave  
  80f8e6:	c3                   	ret    

0080f8e7 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  80f8e7:	55                   	push   %ebp
  80f8e8:	89 e5                	mov    %esp,%ebp
  80f8ea:	53                   	push   %ebx
  80f8eb:	83 ec 14             	sub    $0x14,%esp
  80f8ee:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80f8f1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80f8f4:	50                   	push   %eax
  80f8f5:	ff 75 08             	pushl  0x8(%ebp)
  80f8f8:	e8 6c fb ff ff       	call   80f469 <fd_lookup>
  80f8fd:	83 c4 08             	add    $0x8,%esp
  80f900:	89 c2                	mov    %eax,%edx
  80f902:	85 c0                	test   %eax,%eax
  80f904:	78 58                	js     80f95e <fstat+0x77>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f906:	83 ec 08             	sub    $0x8,%esp
  80f909:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f90c:	50                   	push   %eax
  80f90d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80f910:	ff 30                	pushl  (%eax)
  80f912:	e8 a8 fb ff ff       	call   80f4bf <dev_lookup>
  80f917:	83 c4 10             	add    $0x10,%esp
  80f91a:	85 c0                	test   %eax,%eax
  80f91c:	78 37                	js     80f955 <fstat+0x6e>
		return r;
	if (!dev->dev_stat)
  80f91e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f921:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  80f925:	74 32                	je     80f959 <fstat+0x72>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  80f927:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  80f92a:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80f931:	00 00 00 
	stat->st_isdir = 0;
  80f934:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  80f93b:	00 00 00 
	stat->st_dev = dev;
  80f93e:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  80f944:	83 ec 08             	sub    $0x8,%esp
  80f947:	53                   	push   %ebx
  80f948:	ff 75 f0             	pushl  -0x10(%ebp)
  80f94b:	ff 50 14             	call   *0x14(%eax)
  80f94e:	89 c2                	mov    %eax,%edx
  80f950:	83 c4 10             	add    $0x10,%esp
  80f953:	eb 09                	jmp    80f95e <fstat+0x77>
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80f955:	89 c2                	mov    %eax,%edx
  80f957:	eb 05                	jmp    80f95e <fstat+0x77>
		return r;
	if (!dev->dev_stat)
		return -E_NOT_SUPP;
  80f959:	ba f1 ff ff ff       	mov    $0xfffffff1,%edx
	stat->st_name[0] = 0;
	stat->st_size = 0;
	stat->st_isdir = 0;
	stat->st_dev = dev;
	return (*dev->dev_stat)(fd, stat);
}
  80f95e:	89 d0                	mov    %edx,%eax
  80f960:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f963:	c9                   	leave  
  80f964:	c3                   	ret    

0080f965 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  80f965:	55                   	push   %ebp
  80f966:	89 e5                	mov    %esp,%ebp
  80f968:	56                   	push   %esi
  80f969:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  80f96a:	83 ec 08             	sub    $0x8,%esp
  80f96d:	6a 00                	push   $0x0
  80f96f:	ff 75 08             	pushl  0x8(%ebp)
  80f972:	e8 e7 01 00 00       	call   80fb5e <open>
  80f977:	89 c3                	mov    %eax,%ebx
  80f979:	83 c4 10             	add    $0x10,%esp
  80f97c:	85 c0                	test   %eax,%eax
  80f97e:	78 1b                	js     80f99b <stat+0x36>
		return fd;
	r = fstat(fd, stat);
  80f980:	83 ec 08             	sub    $0x8,%esp
  80f983:	ff 75 0c             	pushl  0xc(%ebp)
  80f986:	50                   	push   %eax
  80f987:	e8 5b ff ff ff       	call   80f8e7 <fstat>
  80f98c:	89 c6                	mov    %eax,%esi
	close(fd);
  80f98e:	89 1c 24             	mov    %ebx,(%esp)
  80f991:	e8 fd fb ff ff       	call   80f593 <close>
	return r;
  80f996:	83 c4 10             	add    $0x10,%esp
  80f999:	89 f0                	mov    %esi,%eax
}
  80f99b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f99e:	5b                   	pop    %ebx
  80f99f:	5e                   	pop    %esi
  80f9a0:	5d                   	pop    %ebp
  80f9a1:	c3                   	ret    

0080f9a2 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  80f9a2:	55                   	push   %ebp
  80f9a3:	89 e5                	mov    %esp,%ebp
  80f9a5:	56                   	push   %esi
  80f9a6:	53                   	push   %ebx
  80f9a7:	89 c6                	mov    %eax,%esi
  80f9a9:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  80f9ab:	83 3d cc b1 b3 00 00 	cmpl   $0x0,0xb3b1cc
  80f9b2:	75 12                	jne    80f9c6 <fsipc+0x24>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  80f9b4:	83 ec 0c             	sub    $0xc,%esp
  80f9b7:	6a 01                	push   $0x1
  80f9b9:	e8 fc f9 ff ff       	call   80f3ba <ipc_find_env>
  80f9be:	a3 cc b1 b3 00       	mov    %eax,0xb3b1cc
  80f9c3:	83 c4 10             	add    $0x10,%esp
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  80f9c6:	6a 07                	push   $0x7
  80f9c8:	68 00 c0 b3 00       	push   $0xb3c000
  80f9cd:	56                   	push   %esi
  80f9ce:	ff 35 cc b1 b3 00    	pushl  0xb3b1cc
  80f9d4:	e8 8d f9 ff ff       	call   80f366 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  80f9d9:	83 c4 0c             	add    $0xc,%esp
  80f9dc:	6a 00                	push   $0x0
  80f9de:	53                   	push   %ebx
  80f9df:	6a 00                	push   $0x0
  80f9e1:	e8 13 f9 ff ff       	call   80f2f9 <ipc_recv>
}
  80f9e6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f9e9:	5b                   	pop    %ebx
  80f9ea:	5e                   	pop    %esi
  80f9eb:	5d                   	pop    %ebp
  80f9ec:	c3                   	ret    

0080f9ed <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  80f9ed:	55                   	push   %ebp
  80f9ee:	89 e5                	mov    %esp,%ebp
  80f9f0:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80f9f3:	8b 45 08             	mov    0x8(%ebp),%eax
  80f9f6:	8b 40 0c             	mov    0xc(%eax),%eax
  80f9f9:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.set_size.req_size = newsize;
  80f9fe:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fa01:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return fsipc(FSREQ_SET_SIZE, NULL);
  80fa06:	ba 00 00 00 00       	mov    $0x0,%edx
  80fa0b:	b8 02 00 00 00       	mov    $0x2,%eax
  80fa10:	e8 8d ff ff ff       	call   80f9a2 <fsipc>
}
  80fa15:	c9                   	leave  
  80fa16:	c3                   	ret    

0080fa17 <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  80fa17:	55                   	push   %ebp
  80fa18:	89 e5                	mov    %esp,%ebp
  80fa1a:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  80fa1d:	8b 45 08             	mov    0x8(%ebp),%eax
  80fa20:	8b 40 0c             	mov    0xc(%eax),%eax
  80fa23:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return fsipc(FSREQ_FLUSH, NULL);
  80fa28:	ba 00 00 00 00       	mov    $0x0,%edx
  80fa2d:	b8 06 00 00 00       	mov    $0x6,%eax
  80fa32:	e8 6b ff ff ff       	call   80f9a2 <fsipc>
}
  80fa37:	c9                   	leave  
  80fa38:	c3                   	ret    

0080fa39 <devfile_stat>:
	//panic("devfile_write not implemented");
}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  80fa39:	55                   	push   %ebp
  80fa3a:	89 e5                	mov    %esp,%ebp
  80fa3c:	53                   	push   %ebx
  80fa3d:	83 ec 04             	sub    $0x4,%esp
  80fa40:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  80fa43:	8b 45 08             	mov    0x8(%ebp),%eax
  80fa46:	8b 40 0c             	mov    0xc(%eax),%eax
  80fa49:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  80fa4e:	ba 00 00 00 00       	mov    $0x0,%edx
  80fa53:	b8 05 00 00 00       	mov    $0x5,%eax
  80fa58:	e8 45 ff ff ff       	call   80f9a2 <fsipc>
  80fa5d:	85 c0                	test   %eax,%eax
  80fa5f:	78 2c                	js     80fa8d <devfile_stat+0x54>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  80fa61:	83 ec 08             	sub    $0x8,%esp
  80fa64:	68 00 c0 b3 00       	push   $0xb3c000
  80fa69:	53                   	push   %ebx
  80fa6a:	e8 47 ef ff ff       	call   80e9b6 <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  80fa6f:	a1 80 c0 b3 00       	mov    0xb3c080,%eax
  80fa74:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  80fa7a:	a1 84 c0 b3 00       	mov    0xb3c084,%eax
  80fa7f:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  80fa85:	83 c4 10             	add    $0x10,%esp
  80fa88:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fa8d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fa90:	c9                   	leave  
  80fa91:	c3                   	ret    

0080fa92 <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  80fa92:	55                   	push   %ebp
  80fa93:	89 e5                	mov    %esp,%ebp
  80fa95:	53                   	push   %ebx
  80fa96:	83 ec 08             	sub    $0x8,%esp
  80fa99:	8b 45 10             	mov    0x10(%ebp),%eax
	// remember that write is always allowed to write *fewer*
	// bytes than requested.
	// LAB 5: Your code here
	uint32_t max_size = PGSIZE - (sizeof(int) + sizeof(size_t));

	n = n > max_size ? max_size : n;
  80fa9c:	3d f8 0f 00 00       	cmp    $0xff8,%eax
  80faa1:	bb f8 0f 00 00       	mov    $0xff8,%ebx
  80faa6:	0f 46 d8             	cmovbe %eax,%ebx
	
	memmove(fsipcbuf.write.req_buf, buf, n);
  80faa9:	53                   	push   %ebx
  80faaa:	ff 75 0c             	pushl  0xc(%ebp)
  80faad:	68 08 c0 b3 00       	push   $0xb3c008
  80fab2:	e8 91 f0 ff ff       	call   80eb48 <memmove>
	
 	fsipcbuf.write.req_fileid = fd->fd_file.id;
  80fab7:	8b 45 08             	mov    0x8(%ebp),%eax
  80faba:	8b 40 0c             	mov    0xc(%eax),%eax
  80fabd:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
 	fsipcbuf.write.req_n = n;
  80fac2:	89 1d 04 c0 b3 00    	mov    %ebx,0xb3c004

 	return fsipc(FSREQ_WRITE, NULL);
  80fac8:	ba 00 00 00 00       	mov    $0x0,%edx
  80facd:	b8 04 00 00 00       	mov    $0x4,%eax
  80fad2:	e8 cb fe ff ff       	call   80f9a2 <fsipc>
	//panic("devfile_write not implemented");
}
  80fad7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fada:	c9                   	leave  
  80fadb:	c3                   	ret    

0080fadc <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  80fadc:	55                   	push   %ebp
  80fadd:	89 e5                	mov    %esp,%ebp
  80fadf:	56                   	push   %esi
  80fae0:	53                   	push   %ebx
  80fae1:	8b 75 10             	mov    0x10(%ebp),%esi
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	int r;

	fsipcbuf.read.req_fileid = fd->fd_file.id;
  80fae4:	8b 45 08             	mov    0x8(%ebp),%eax
  80fae7:	8b 40 0c             	mov    0xc(%eax),%eax
  80faea:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.read.req_n = n;
  80faef:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  80faf5:	ba 00 00 00 00       	mov    $0x0,%edx
  80fafa:	b8 03 00 00 00       	mov    $0x3,%eax
  80faff:	e8 9e fe ff ff       	call   80f9a2 <fsipc>
  80fb04:	89 c3                	mov    %eax,%ebx
  80fb06:	85 c0                	test   %eax,%eax
  80fb08:	78 4b                	js     80fb55 <devfile_read+0x79>
		return r;
	assert(r <= n);
  80fb0a:	39 c6                	cmp    %eax,%esi
  80fb0c:	73 16                	jae    80fb24 <devfile_read+0x48>
  80fb0e:	68 58 36 81 00       	push   $0x813658
  80fb13:	68 e7 22 81 00       	push   $0x8122e7
  80fb18:	6a 7c                	push   $0x7c
  80fb1a:	68 5f 36 81 00       	push   $0x81365f
  80fb1f:	e8 34 e8 ff ff       	call   80e358 <_panic>
	assert(r <= PGSIZE);
  80fb24:	3d 00 10 00 00       	cmp    $0x1000,%eax
  80fb29:	7e 16                	jle    80fb41 <devfile_read+0x65>
  80fb2b:	68 6a 36 81 00       	push   $0x81366a
  80fb30:	68 e7 22 81 00       	push   $0x8122e7
  80fb35:	6a 7d                	push   $0x7d
  80fb37:	68 5f 36 81 00       	push   $0x81365f
  80fb3c:	e8 17 e8 ff ff       	call   80e358 <_panic>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  80fb41:	83 ec 04             	sub    $0x4,%esp
  80fb44:	50                   	push   %eax
  80fb45:	68 00 c0 b3 00       	push   $0xb3c000
  80fb4a:	ff 75 0c             	pushl  0xc(%ebp)
  80fb4d:	e8 f6 ef ff ff       	call   80eb48 <memmove>
	return r;
  80fb52:	83 c4 10             	add    $0x10,%esp
}
  80fb55:	89 d8                	mov    %ebx,%eax
  80fb57:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fb5a:	5b                   	pop    %ebx
  80fb5b:	5e                   	pop    %esi
  80fb5c:	5d                   	pop    %ebp
  80fb5d:	c3                   	ret    

0080fb5e <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  80fb5e:	55                   	push   %ebp
  80fb5f:	89 e5                	mov    %esp,%ebp
  80fb61:	53                   	push   %ebx
  80fb62:	83 ec 20             	sub    $0x20,%esp
  80fb65:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// file descriptor.

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
  80fb68:	53                   	push   %ebx
  80fb69:	e8 0f ee ff ff       	call   80e97d <strlen>
  80fb6e:	83 c4 10             	add    $0x10,%esp
  80fb71:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  80fb76:	7f 67                	jg     80fbdf <open+0x81>
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  80fb78:	83 ec 0c             	sub    $0xc,%esp
  80fb7b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fb7e:	50                   	push   %eax
  80fb7f:	e8 96 f8 ff ff       	call   80f41a <fd_alloc>
  80fb84:	83 c4 10             	add    $0x10,%esp
		return r;
  80fb87:	89 c2                	mov    %eax,%edx
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  80fb89:	85 c0                	test   %eax,%eax
  80fb8b:	78 57                	js     80fbe4 <open+0x86>
		return r;

	strcpy(fsipcbuf.open.req_path, path);
  80fb8d:	83 ec 08             	sub    $0x8,%esp
  80fb90:	53                   	push   %ebx
  80fb91:	68 00 c0 b3 00       	push   $0xb3c000
  80fb96:	e8 1b ee ff ff       	call   80e9b6 <strcpy>
	fsipcbuf.open.req_omode = mode;
  80fb9b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fb9e:	a3 00 c4 b3 00       	mov    %eax,0xb3c400

	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  80fba3:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fba6:	b8 01 00 00 00       	mov    $0x1,%eax
  80fbab:	e8 f2 fd ff ff       	call   80f9a2 <fsipc>
  80fbb0:	89 c3                	mov    %eax,%ebx
  80fbb2:	83 c4 10             	add    $0x10,%esp
  80fbb5:	85 c0                	test   %eax,%eax
  80fbb7:	79 14                	jns    80fbcd <open+0x6f>
		fd_close(fd, 0);
  80fbb9:	83 ec 08             	sub    $0x8,%esp
  80fbbc:	6a 00                	push   $0x0
  80fbbe:	ff 75 f4             	pushl  -0xc(%ebp)
  80fbc1:	e8 4c f9 ff ff       	call   80f512 <fd_close>
		return r;
  80fbc6:	83 c4 10             	add    $0x10,%esp
  80fbc9:	89 da                	mov    %ebx,%edx
  80fbcb:	eb 17                	jmp    80fbe4 <open+0x86>
	}

	return fd2num(fd);
  80fbcd:	83 ec 0c             	sub    $0xc,%esp
  80fbd0:	ff 75 f4             	pushl  -0xc(%ebp)
  80fbd3:	e8 1b f8 ff ff       	call   80f3f3 <fd2num>
  80fbd8:	89 c2                	mov    %eax,%edx
  80fbda:	83 c4 10             	add    $0x10,%esp
  80fbdd:	eb 05                	jmp    80fbe4 <open+0x86>

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;
  80fbdf:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
		fd_close(fd, 0);
		return r;
	}

	return fd2num(fd);
}
  80fbe4:	89 d0                	mov    %edx,%eax
  80fbe6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fbe9:	c9                   	leave  
  80fbea:	c3                   	ret    

0080fbeb <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  80fbeb:	55                   	push   %ebp
  80fbec:	89 e5                	mov    %esp,%ebp
  80fbee:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  80fbf1:	ba 00 00 00 00       	mov    $0x0,%edx
  80fbf6:	b8 08 00 00 00       	mov    $0x8,%eax
  80fbfb:	e8 a2 fd ff ff       	call   80f9a2 <fsipc>
}
  80fc00:	c9                   	leave  
  80fc01:	c3                   	ret    

0080fc02 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  80fc02:	55                   	push   %ebp
  80fc03:	89 e5                	mov    %esp,%ebp
  80fc05:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  80fc08:	68 76 36 81 00       	push   $0x813676
  80fc0d:	ff 75 0c             	pushl  0xc(%ebp)
  80fc10:	e8 a1 ed ff ff       	call   80e9b6 <strcpy>
	return 0;
}
  80fc15:	b8 00 00 00 00       	mov    $0x0,%eax
  80fc1a:	c9                   	leave  
  80fc1b:	c3                   	ret    

0080fc1c <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  80fc1c:	55                   	push   %ebp
  80fc1d:	89 e5                	mov    %esp,%ebp
  80fc1f:	53                   	push   %ebx
  80fc20:	83 ec 10             	sub    $0x10,%esp
  80fc23:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  80fc26:	53                   	push   %ebx
  80fc27:	e8 3d 0c 00 00       	call   810869 <pageref>
  80fc2c:	83 c4 10             	add    $0x10,%esp
		return nsipc_close(fd->fd_sock.sockid);
	else
		return 0;
  80fc2f:	ba 00 00 00 00       	mov    $0x0,%edx
}

static int
devsock_close(struct Fd *fd)
{
	if (pageref(fd) == 1)
  80fc34:	83 f8 01             	cmp    $0x1,%eax
  80fc37:	75 10                	jne    80fc49 <devsock_close+0x2d>
		return nsipc_close(fd->fd_sock.sockid);
  80fc39:	83 ec 0c             	sub    $0xc,%esp
  80fc3c:	ff 73 0c             	pushl  0xc(%ebx)
  80fc3f:	e8 c0 02 00 00       	call   80ff04 <nsipc_close>
  80fc44:	89 c2                	mov    %eax,%edx
  80fc46:	83 c4 10             	add    $0x10,%esp
	else
		return 0;
}
  80fc49:	89 d0                	mov    %edx,%eax
  80fc4b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fc4e:	c9                   	leave  
  80fc4f:	c3                   	ret    

0080fc50 <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  80fc50:	55                   	push   %ebp
  80fc51:	89 e5                	mov    %esp,%ebp
  80fc53:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  80fc56:	6a 00                	push   $0x0
  80fc58:	ff 75 10             	pushl  0x10(%ebp)
  80fc5b:	ff 75 0c             	pushl  0xc(%ebp)
  80fc5e:	8b 45 08             	mov    0x8(%ebp),%eax
  80fc61:	ff 70 0c             	pushl  0xc(%eax)
  80fc64:	e8 78 03 00 00       	call   80ffe1 <nsipc_send>
}
  80fc69:	c9                   	leave  
  80fc6a:	c3                   	ret    

0080fc6b <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  80fc6b:	55                   	push   %ebp
  80fc6c:	89 e5                	mov    %esp,%ebp
  80fc6e:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  80fc71:	6a 00                	push   $0x0
  80fc73:	ff 75 10             	pushl  0x10(%ebp)
  80fc76:	ff 75 0c             	pushl  0xc(%ebp)
  80fc79:	8b 45 08             	mov    0x8(%ebp),%eax
  80fc7c:	ff 70 0c             	pushl  0xc(%eax)
  80fc7f:	e8 f1 02 00 00       	call   80ff75 <nsipc_recv>
}
  80fc84:	c9                   	leave  
  80fc85:	c3                   	ret    

0080fc86 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  80fc86:	55                   	push   %ebp
  80fc87:	89 e5                	mov    %esp,%ebp
  80fc89:	83 ec 20             	sub    $0x20,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  80fc8c:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80fc8f:	52                   	push   %edx
  80fc90:	50                   	push   %eax
  80fc91:	e8 d3 f7 ff ff       	call   80f469 <fd_lookup>
  80fc96:	83 c4 10             	add    $0x10,%esp
  80fc99:	85 c0                	test   %eax,%eax
  80fc9b:	78 17                	js     80fcb4 <fd2sockid+0x2e>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  80fc9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fca0:	8b 0d 08 43 81 00    	mov    0x814308,%ecx
  80fca6:	39 08                	cmp    %ecx,(%eax)
  80fca8:	75 05                	jne    80fcaf <fd2sockid+0x29>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  80fcaa:	8b 40 0c             	mov    0xc(%eax),%eax
  80fcad:	eb 05                	jmp    80fcb4 <fd2sockid+0x2e>
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
		return -E_NOT_SUPP;
  80fcaf:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return sfd->fd_sock.sockid;
}
  80fcb4:	c9                   	leave  
  80fcb5:	c3                   	ret    

0080fcb6 <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  80fcb6:	55                   	push   %ebp
  80fcb7:	89 e5                	mov    %esp,%ebp
  80fcb9:	56                   	push   %esi
  80fcba:	53                   	push   %ebx
  80fcbb:	83 ec 1c             	sub    $0x1c,%esp
  80fcbe:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  80fcc0:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fcc3:	50                   	push   %eax
  80fcc4:	e8 51 f7 ff ff       	call   80f41a <fd_alloc>
  80fcc9:	89 c3                	mov    %eax,%ebx
  80fccb:	83 c4 10             	add    $0x10,%esp
  80fcce:	85 c0                	test   %eax,%eax
  80fcd0:	78 1b                	js     80fced <alloc_sockfd+0x37>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  80fcd2:	83 ec 04             	sub    $0x4,%esp
  80fcd5:	68 07 04 00 00       	push   $0x407
  80fcda:	ff 75 f4             	pushl  -0xc(%ebp)
  80fcdd:	6a 00                	push   $0x0
  80fcdf:	e8 d5 f0 ff ff       	call   80edb9 <sys_page_alloc>
  80fce4:	89 c3                	mov    %eax,%ebx
  80fce6:	83 c4 10             	add    $0x10,%esp
  80fce9:	85 c0                	test   %eax,%eax
  80fceb:	79 10                	jns    80fcfd <alloc_sockfd+0x47>
		nsipc_close(sockid);
  80fced:	83 ec 0c             	sub    $0xc,%esp
  80fcf0:	56                   	push   %esi
  80fcf1:	e8 0e 02 00 00       	call   80ff04 <nsipc_close>
		return r;
  80fcf6:	83 c4 10             	add    $0x10,%esp
  80fcf9:	89 d8                	mov    %ebx,%eax
  80fcfb:	eb 24                	jmp    80fd21 <alloc_sockfd+0x6b>
	}

	sfd->fd_dev_id = devsock.dev_id;
  80fcfd:	8b 15 08 43 81 00    	mov    0x814308,%edx
  80fd03:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fd06:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  80fd08:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fd0b:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  80fd12:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  80fd15:	83 ec 0c             	sub    $0xc,%esp
  80fd18:	50                   	push   %eax
  80fd19:	e8 d5 f6 ff ff       	call   80f3f3 <fd2num>
  80fd1e:	83 c4 10             	add    $0x10,%esp
}
  80fd21:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fd24:	5b                   	pop    %ebx
  80fd25:	5e                   	pop    %esi
  80fd26:	5d                   	pop    %ebp
  80fd27:	c3                   	ret    

0080fd28 <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80fd28:	55                   	push   %ebp
  80fd29:	89 e5                	mov    %esp,%ebp
  80fd2b:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fd2e:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd31:	e8 50 ff ff ff       	call   80fc86 <fd2sockid>
		return r;
  80fd36:	89 c1                	mov    %eax,%ecx

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fd38:	85 c0                	test   %eax,%eax
  80fd3a:	78 1f                	js     80fd5b <accept+0x33>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80fd3c:	83 ec 04             	sub    $0x4,%esp
  80fd3f:	ff 75 10             	pushl  0x10(%ebp)
  80fd42:	ff 75 0c             	pushl  0xc(%ebp)
  80fd45:	50                   	push   %eax
  80fd46:	e8 12 01 00 00       	call   80fe5d <nsipc_accept>
  80fd4b:	83 c4 10             	add    $0x10,%esp
		return r;
  80fd4e:	89 c1                	mov    %eax,%ecx
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80fd50:	85 c0                	test   %eax,%eax
  80fd52:	78 07                	js     80fd5b <accept+0x33>
		return r;
	return alloc_sockfd(r);
  80fd54:	e8 5d ff ff ff       	call   80fcb6 <alloc_sockfd>
  80fd59:	89 c1                	mov    %eax,%ecx
}
  80fd5b:	89 c8                	mov    %ecx,%eax
  80fd5d:	c9                   	leave  
  80fd5e:	c3                   	ret    

0080fd5f <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80fd5f:	55                   	push   %ebp
  80fd60:	89 e5                	mov    %esp,%ebp
  80fd62:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fd65:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd68:	e8 19 ff ff ff       	call   80fc86 <fd2sockid>
  80fd6d:	85 c0                	test   %eax,%eax
  80fd6f:	78 12                	js     80fd83 <bind+0x24>
		return r;
	return nsipc_bind(r, name, namelen);
  80fd71:	83 ec 04             	sub    $0x4,%esp
  80fd74:	ff 75 10             	pushl  0x10(%ebp)
  80fd77:	ff 75 0c             	pushl  0xc(%ebp)
  80fd7a:	50                   	push   %eax
  80fd7b:	e8 2d 01 00 00       	call   80fead <nsipc_bind>
  80fd80:	83 c4 10             	add    $0x10,%esp
}
  80fd83:	c9                   	leave  
  80fd84:	c3                   	ret    

0080fd85 <shutdown>:

int
shutdown(int s, int how)
{
  80fd85:	55                   	push   %ebp
  80fd86:	89 e5                	mov    %esp,%ebp
  80fd88:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fd8b:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd8e:	e8 f3 fe ff ff       	call   80fc86 <fd2sockid>
  80fd93:	85 c0                	test   %eax,%eax
  80fd95:	78 0f                	js     80fda6 <shutdown+0x21>
		return r;
	return nsipc_shutdown(r, how);
  80fd97:	83 ec 08             	sub    $0x8,%esp
  80fd9a:	ff 75 0c             	pushl  0xc(%ebp)
  80fd9d:	50                   	push   %eax
  80fd9e:	e8 3f 01 00 00       	call   80fee2 <nsipc_shutdown>
  80fda3:	83 c4 10             	add    $0x10,%esp
}
  80fda6:	c9                   	leave  
  80fda7:	c3                   	ret    

0080fda8 <connect>:
		return 0;
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80fda8:	55                   	push   %ebp
  80fda9:	89 e5                	mov    %esp,%ebp
  80fdab:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fdae:	8b 45 08             	mov    0x8(%ebp),%eax
  80fdb1:	e8 d0 fe ff ff       	call   80fc86 <fd2sockid>
  80fdb6:	85 c0                	test   %eax,%eax
  80fdb8:	78 12                	js     80fdcc <connect+0x24>
		return r;
	return nsipc_connect(r, name, namelen);
  80fdba:	83 ec 04             	sub    $0x4,%esp
  80fdbd:	ff 75 10             	pushl  0x10(%ebp)
  80fdc0:	ff 75 0c             	pushl  0xc(%ebp)
  80fdc3:	50                   	push   %eax
  80fdc4:	e8 55 01 00 00       	call   80ff1e <nsipc_connect>
  80fdc9:	83 c4 10             	add    $0x10,%esp
}
  80fdcc:	c9                   	leave  
  80fdcd:	c3                   	ret    

0080fdce <listen>:

int
listen(int s, int backlog)
{
  80fdce:	55                   	push   %ebp
  80fdcf:	89 e5                	mov    %esp,%ebp
  80fdd1:	83 ec 08             	sub    $0x8,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80fdd4:	8b 45 08             	mov    0x8(%ebp),%eax
  80fdd7:	e8 aa fe ff ff       	call   80fc86 <fd2sockid>
  80fddc:	85 c0                	test   %eax,%eax
  80fdde:	78 0f                	js     80fdef <listen+0x21>
		return r;
	return nsipc_listen(r, backlog);
  80fde0:	83 ec 08             	sub    $0x8,%esp
  80fde3:	ff 75 0c             	pushl  0xc(%ebp)
  80fde6:	50                   	push   %eax
  80fde7:	e8 67 01 00 00       	call   80ff53 <nsipc_listen>
  80fdec:	83 c4 10             	add    $0x10,%esp
}
  80fdef:	c9                   	leave  
  80fdf0:	c3                   	ret    

0080fdf1 <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  80fdf1:	55                   	push   %ebp
  80fdf2:	89 e5                	mov    %esp,%ebp
  80fdf4:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  80fdf7:	ff 75 10             	pushl  0x10(%ebp)
  80fdfa:	ff 75 0c             	pushl  0xc(%ebp)
  80fdfd:	ff 75 08             	pushl  0x8(%ebp)
  80fe00:	e8 3a 02 00 00       	call   81003f <nsipc_socket>
  80fe05:	83 c4 10             	add    $0x10,%esp
  80fe08:	85 c0                	test   %eax,%eax
  80fe0a:	78 05                	js     80fe11 <socket+0x20>
		return r;
	return alloc_sockfd(r);
  80fe0c:	e8 a5 fe ff ff       	call   80fcb6 <alloc_sockfd>
}
  80fe11:	c9                   	leave  
  80fe12:	c3                   	ret    

0080fe13 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  80fe13:	55                   	push   %ebp
  80fe14:	89 e5                	mov    %esp,%ebp
  80fe16:	53                   	push   %ebx
  80fe17:	83 ec 04             	sub    $0x4,%esp
  80fe1a:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  80fe1c:	83 3d d0 b1 b3 00 00 	cmpl   $0x0,0xb3b1d0
  80fe23:	75 12                	jne    80fe37 <nsipc+0x24>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  80fe25:	83 ec 0c             	sub    $0xc,%esp
  80fe28:	6a 02                	push   $0x2
  80fe2a:	e8 8b f5 ff ff       	call   80f3ba <ipc_find_env>
  80fe2f:	a3 d0 b1 b3 00       	mov    %eax,0xb3b1d0
  80fe34:	83 c4 10             	add    $0x10,%esp
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  80fe37:	6a 07                	push   $0x7
  80fe39:	68 00 d0 b3 00       	push   $0xb3d000
  80fe3e:	53                   	push   %ebx
  80fe3f:	ff 35 d0 b1 b3 00    	pushl  0xb3b1d0
  80fe45:	e8 1c f5 ff ff       	call   80f366 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  80fe4a:	83 c4 0c             	add    $0xc,%esp
  80fe4d:	6a 00                	push   $0x0
  80fe4f:	6a 00                	push   $0x0
  80fe51:	6a 00                	push   $0x0
  80fe53:	e8 a1 f4 ff ff       	call   80f2f9 <ipc_recv>
}
  80fe58:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fe5b:	c9                   	leave  
  80fe5c:	c3                   	ret    

0080fe5d <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80fe5d:	55                   	push   %ebp
  80fe5e:	89 e5                	mov    %esp,%ebp
  80fe60:	56                   	push   %esi
  80fe61:	53                   	push   %ebx
  80fe62:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  80fe65:	8b 45 08             	mov    0x8(%ebp),%eax
  80fe68:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.accept.req_addrlen = *addrlen;
  80fe6d:	8b 06                	mov    (%esi),%eax
  80fe6f:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  80fe74:	b8 01 00 00 00       	mov    $0x1,%eax
  80fe79:	e8 95 ff ff ff       	call   80fe13 <nsipc>
  80fe7e:	89 c3                	mov    %eax,%ebx
  80fe80:	85 c0                	test   %eax,%eax
  80fe82:	78 20                	js     80fea4 <nsipc_accept+0x47>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  80fe84:	83 ec 04             	sub    $0x4,%esp
  80fe87:	ff 35 10 d0 b3 00    	pushl  0xb3d010
  80fe8d:	68 00 d0 b3 00       	push   $0xb3d000
  80fe92:	ff 75 0c             	pushl  0xc(%ebp)
  80fe95:	e8 ae ec ff ff       	call   80eb48 <memmove>
		*addrlen = ret->ret_addrlen;
  80fe9a:	a1 10 d0 b3 00       	mov    0xb3d010,%eax
  80fe9f:	89 06                	mov    %eax,(%esi)
  80fea1:	83 c4 10             	add    $0x10,%esp
	}
	return r;
}
  80fea4:	89 d8                	mov    %ebx,%eax
  80fea6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fea9:	5b                   	pop    %ebx
  80feaa:	5e                   	pop    %esi
  80feab:	5d                   	pop    %ebp
  80feac:	c3                   	ret    

0080fead <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80fead:	55                   	push   %ebp
  80feae:	89 e5                	mov    %esp,%ebp
  80feb0:	53                   	push   %ebx
  80feb1:	83 ec 08             	sub    $0x8,%esp
  80feb4:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  80feb7:	8b 45 08             	mov    0x8(%ebp),%eax
  80feba:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  80febf:	53                   	push   %ebx
  80fec0:	ff 75 0c             	pushl  0xc(%ebp)
  80fec3:	68 04 d0 b3 00       	push   $0xb3d004
  80fec8:	e8 7b ec ff ff       	call   80eb48 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  80fecd:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_BIND);
  80fed3:	b8 02 00 00 00       	mov    $0x2,%eax
  80fed8:	e8 36 ff ff ff       	call   80fe13 <nsipc>
}
  80fedd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fee0:	c9                   	leave  
  80fee1:	c3                   	ret    

0080fee2 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  80fee2:	55                   	push   %ebp
  80fee3:	89 e5                	mov    %esp,%ebp
  80fee5:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  80fee8:	8b 45 08             	mov    0x8(%ebp),%eax
  80feeb:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.shutdown.req_how = how;
  80fef0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fef3:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_SHUTDOWN);
  80fef8:	b8 03 00 00 00       	mov    $0x3,%eax
  80fefd:	e8 11 ff ff ff       	call   80fe13 <nsipc>
}
  80ff02:	c9                   	leave  
  80ff03:	c3                   	ret    

0080ff04 <nsipc_close>:

int
nsipc_close(int s)
{
  80ff04:	55                   	push   %ebp
  80ff05:	89 e5                	mov    %esp,%ebp
  80ff07:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  80ff0a:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff0d:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return nsipc(NSREQ_CLOSE);
  80ff12:	b8 04 00 00 00       	mov    $0x4,%eax
  80ff17:	e8 f7 fe ff ff       	call   80fe13 <nsipc>
}
  80ff1c:	c9                   	leave  
  80ff1d:	c3                   	ret    

0080ff1e <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80ff1e:	55                   	push   %ebp
  80ff1f:	89 e5                	mov    %esp,%ebp
  80ff21:	53                   	push   %ebx
  80ff22:	83 ec 08             	sub    $0x8,%esp
  80ff25:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  80ff28:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff2b:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  80ff30:	53                   	push   %ebx
  80ff31:	ff 75 0c             	pushl  0xc(%ebp)
  80ff34:	68 04 d0 b3 00       	push   $0xb3d004
  80ff39:	e8 0a ec ff ff       	call   80eb48 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  80ff3e:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_CONNECT);
  80ff44:	b8 05 00 00 00       	mov    $0x5,%eax
  80ff49:	e8 c5 fe ff ff       	call   80fe13 <nsipc>
}
  80ff4e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ff51:	c9                   	leave  
  80ff52:	c3                   	ret    

0080ff53 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  80ff53:	55                   	push   %ebp
  80ff54:	89 e5                	mov    %esp,%ebp
  80ff56:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  80ff59:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff5c:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.listen.req_backlog = backlog;
  80ff61:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ff64:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_LISTEN);
  80ff69:	b8 06 00 00 00       	mov    $0x6,%eax
  80ff6e:	e8 a0 fe ff ff       	call   80fe13 <nsipc>
}
  80ff73:	c9                   	leave  
  80ff74:	c3                   	ret    

0080ff75 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  80ff75:	55                   	push   %ebp
  80ff76:	89 e5                	mov    %esp,%ebp
  80ff78:	56                   	push   %esi
  80ff79:	53                   	push   %ebx
  80ff7a:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  80ff7d:	8b 45 08             	mov    0x8(%ebp),%eax
  80ff80:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.recv.req_len = len;
  80ff85:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	nsipcbuf.recv.req_flags = flags;
  80ff8b:	8b 45 14             	mov    0x14(%ebp),%eax
  80ff8e:	a3 08 d0 b3 00       	mov    %eax,0xb3d008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  80ff93:	b8 07 00 00 00       	mov    $0x7,%eax
  80ff98:	e8 76 fe ff ff       	call   80fe13 <nsipc>
  80ff9d:	89 c3                	mov    %eax,%ebx
  80ff9f:	85 c0                	test   %eax,%eax
  80ffa1:	78 35                	js     80ffd8 <nsipc_recv+0x63>
		assert(r < 1600 && r <= len);
  80ffa3:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  80ffa8:	7f 04                	jg     80ffae <nsipc_recv+0x39>
  80ffaa:	39 c6                	cmp    %eax,%esi
  80ffac:	7d 16                	jge    80ffc4 <nsipc_recv+0x4f>
  80ffae:	68 82 36 81 00       	push   $0x813682
  80ffb3:	68 e7 22 81 00       	push   $0x8122e7
  80ffb8:	6a 62                	push   $0x62
  80ffba:	68 97 36 81 00       	push   $0x813697
  80ffbf:	e8 94 e3 ff ff       	call   80e358 <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  80ffc4:	83 ec 04             	sub    $0x4,%esp
  80ffc7:	50                   	push   %eax
  80ffc8:	68 00 d0 b3 00       	push   $0xb3d000
  80ffcd:	ff 75 0c             	pushl  0xc(%ebp)
  80ffd0:	e8 73 eb ff ff       	call   80eb48 <memmove>
  80ffd5:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  80ffd8:	89 d8                	mov    %ebx,%eax
  80ffda:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ffdd:	5b                   	pop    %ebx
  80ffde:	5e                   	pop    %esi
  80ffdf:	5d                   	pop    %ebp
  80ffe0:	c3                   	ret    

0080ffe1 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  80ffe1:	55                   	push   %ebp
  80ffe2:	89 e5                	mov    %esp,%ebp
  80ffe4:	53                   	push   %ebx
  80ffe5:	83 ec 04             	sub    $0x4,%esp
  80ffe8:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  80ffeb:	8b 45 08             	mov    0x8(%ebp),%eax
  80ffee:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	assert(size < 1600);
  80fff3:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  80fff9:	7e 16                	jle    810011 <nsipc_send+0x30>
  80fffb:	68 a3 36 81 00       	push   $0x8136a3
  810000:	68 e7 22 81 00       	push   $0x8122e7
  810005:	6a 6d                	push   $0x6d
  810007:	68 97 36 81 00       	push   $0x813697
  81000c:	e8 47 e3 ff ff       	call   80e358 <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  810011:	83 ec 04             	sub    $0x4,%esp
  810014:	53                   	push   %ebx
  810015:	ff 75 0c             	pushl  0xc(%ebp)
  810018:	68 0c d0 b3 00       	push   $0xb3d00c
  81001d:	e8 26 eb ff ff       	call   80eb48 <memmove>
	nsipcbuf.send.req_size = size;
  810022:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	nsipcbuf.send.req_flags = flags;
  810028:	8b 45 14             	mov    0x14(%ebp),%eax
  81002b:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SEND);
  810030:	b8 08 00 00 00       	mov    $0x8,%eax
  810035:	e8 d9 fd ff ff       	call   80fe13 <nsipc>
}
  81003a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81003d:	c9                   	leave  
  81003e:	c3                   	ret    

0081003f <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  81003f:	55                   	push   %ebp
  810040:	89 e5                	mov    %esp,%ebp
  810042:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  810045:	8b 45 08             	mov    0x8(%ebp),%eax
  810048:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.socket.req_type = type;
  81004d:	8b 45 0c             	mov    0xc(%ebp),%eax
  810050:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	nsipcbuf.socket.req_protocol = protocol;
  810055:	8b 45 10             	mov    0x10(%ebp),%eax
  810058:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SOCKET);
  81005d:	b8 09 00 00 00       	mov    $0x9,%eax
  810062:	e8 ac fd ff ff       	call   80fe13 <nsipc>
}
  810067:	c9                   	leave  
  810068:	c3                   	ret    

00810069 <free>:
	return v;
}

void
free(void *v)
{
  810069:	55                   	push   %ebp
  81006a:	89 e5                	mov    %esp,%ebp
  81006c:	53                   	push   %ebx
  81006d:	83 ec 04             	sub    $0x4,%esp
  810070:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  810073:	85 db                	test   %ebx,%ebx
  810075:	0f 84 97 00 00 00    	je     810112 <free+0xa9>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  81007b:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  810081:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810086:	76 16                	jbe    81009e <free+0x35>
  810088:	68 b0 36 81 00       	push   $0x8136b0
  81008d:	68 e7 22 81 00       	push   $0x8122e7
  810092:	6a 7a                	push   $0x7a
  810094:	68 de 36 81 00       	push   $0x8136de
  810099:	e8 ba e2 ff ff       	call   80e358 <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  81009e:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8100a4:	eb 3a                	jmp    8100e0 <free+0x77>
		sys_page_unmap(0, c);
  8100a6:	83 ec 08             	sub    $0x8,%esp
  8100a9:	53                   	push   %ebx
  8100aa:	6a 00                	push   $0x0
  8100ac:	e8 8d ed ff ff       	call   80ee3e <sys_page_unmap>
		c += PGSIZE;
  8100b1:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  8100b7:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  8100bd:	83 c4 10             	add    $0x10,%esp
  8100c0:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  8100c5:	76 19                	jbe    8100e0 <free+0x77>
  8100c7:	68 eb 36 81 00       	push   $0x8136eb
  8100cc:	68 e7 22 81 00       	push   $0x8122e7
  8100d1:	68 81 00 00 00       	push   $0x81
  8100d6:	68 de 36 81 00       	push   $0x8136de
  8100db:	e8 78 e2 ff ff       	call   80e358 <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8100e0:	89 d8                	mov    %ebx,%eax
  8100e2:	c1 e8 0c             	shr    $0xc,%eax
  8100e5:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  8100ec:	f6 c4 02             	test   $0x2,%ah
  8100ef:	75 b5                	jne    8100a6 <free+0x3d>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  8100f1:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  8100f7:	83 e8 01             	sub    $0x1,%eax
  8100fa:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  810100:	85 c0                	test   %eax,%eax
  810102:	75 0e                	jne    810112 <free+0xa9>
		sys_page_unmap(0, c);
  810104:	83 ec 08             	sub    $0x8,%esp
  810107:	53                   	push   %ebx
  810108:	6a 00                	push   $0x0
  81010a:	e8 2f ed ff ff       	call   80ee3e <sys_page_unmap>
  81010f:	83 c4 10             	add    $0x10,%esp
}
  810112:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810115:	c9                   	leave  
  810116:	c3                   	ret    

00810117 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  810117:	55                   	push   %ebp
  810118:	89 e5                	mov    %esp,%ebp
  81011a:	57                   	push   %edi
  81011b:	56                   	push   %esi
  81011c:	53                   	push   %ebx
  81011d:	83 ec 1c             	sub    $0x1c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  810120:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  810125:	85 c0                	test   %eax,%eax
  810127:	75 22                	jne    81014b <malloc+0x34>
		mptr = mbegin;
  810129:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  810130:	00 00 08 

	n = ROUNDUP(n, 4);
  810133:	8b 45 08             	mov    0x8(%ebp),%eax
  810136:	83 c0 03             	add    $0x3,%eax
  810139:	83 e0 fc             	and    $0xfffffffc,%eax
  81013c:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if (n >= MAXMALLOC)
  81013f:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  810144:	76 74                	jbe    8101ba <malloc+0xa3>
  810146:	e9 7a 01 00 00       	jmp    8102c5 <malloc+0x1ae>
	void *v;

	if (mptr == 0)
		mptr = mbegin;

	n = ROUNDUP(n, 4);
  81014b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  81014e:	8d 53 03             	lea    0x3(%ebx),%edx
  810151:	83 e2 fc             	and    $0xfffffffc,%edx
  810154:	89 55 dc             	mov    %edx,-0x24(%ebp)

	if (n >= MAXMALLOC)
  810157:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  81015d:	0f 87 69 01 00 00    	ja     8102cc <malloc+0x1b5>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  810163:	a9 ff 0f 00 00       	test   $0xfff,%eax
  810168:	74 50                	je     8101ba <malloc+0xa3>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  81016a:	89 c1                	mov    %eax,%ecx
  81016c:	c1 e9 0c             	shr    $0xc,%ecx
  81016f:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  810173:	c1 ea 0c             	shr    $0xc,%edx
  810176:	39 d1                	cmp    %edx,%ecx
  810178:	75 20                	jne    81019a <malloc+0x83>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  81017a:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
  810180:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  810186:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  81018a:	8b 55 dc             	mov    -0x24(%ebp),%edx
  81018d:	01 c2                	add    %eax,%edx
  81018f:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
			return v;
  810195:	e9 55 01 00 00       	jmp    8102ef <malloc+0x1d8>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  81019a:	83 ec 0c             	sub    $0xc,%esp
  81019d:	50                   	push   %eax
  81019e:	e8 c6 fe ff ff       	call   810069 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  8101a3:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  8101a8:	05 00 10 00 00       	add    $0x1000,%eax
  8101ad:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  8101b2:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
  8101b7:	83 c4 10             	add    $0x10,%esp
  8101ba:	8b 35 d4 b1 b3 00    	mov    0xb3b1d4,%esi
	return 1;
}

void*
malloc(size_t n)
{
  8101c0:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%ebp)
  8101c7:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  8101cb:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8101ce:	8d 78 04             	lea    0x4(%eax),%edi
  8101d1:	89 75 e0             	mov    %esi,-0x20(%ebp)
  8101d4:	89 fb                	mov    %edi,%ebx
  8101d6:	8d 0c 37             	lea    (%edi,%esi,1),%ecx
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8101d9:	89 f0                	mov    %esi,%eax
  8101db:	eb 36                	jmp    810213 <malloc+0xfc>
		if (va >= (uintptr_t) mend
  8101dd:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  8101e2:	0f 87 eb 00 00 00    	ja     8102d3 <malloc+0x1bc>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  8101e8:	89 c2                	mov    %eax,%edx
  8101ea:	c1 ea 16             	shr    $0x16,%edx
  8101ed:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  8101f4:	f6 c2 01             	test   $0x1,%dl
  8101f7:	74 15                	je     81020e <malloc+0xf7>
  8101f9:	89 c2                	mov    %eax,%edx
  8101fb:	c1 ea 0c             	shr    $0xc,%edx
  8101fe:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  810205:	f6 c2 01             	test   $0x1,%dl
  810208:	0f 85 c5 00 00 00    	jne    8102d3 <malloc+0x1bc>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81020e:	05 00 10 00 00       	add    $0x1000,%eax
  810213:	39 c8                	cmp    %ecx,%eax
  810215:	72 c6                	jb     8101dd <malloc+0xc6>
  810217:	eb 79                	jmp    810292 <malloc+0x17b>
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
  810219:	be 00 00 00 08       	mov    $0x8000000,%esi
  81021e:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
			if (++nwrap == 2)
  810222:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  810226:	75 a9                	jne    8101d1 <malloc+0xba>
  810228:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  81022f:	00 00 08 
				return 0;	/* out of address space */
  810232:	b8 00 00 00 00       	mov    $0x0,%eax
  810237:	e9 b3 00 00 00       	jmp    8102ef <malloc+0x1d8>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  81023c:	8d be 00 10 00 00    	lea    0x1000(%esi),%edi
  810242:	39 df                	cmp    %ebx,%edi
  810244:	19 c0                	sbb    %eax,%eax
  810246:	25 00 02 00 00       	and    $0x200,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  81024b:	83 ec 04             	sub    $0x4,%esp
  81024e:	83 c8 07             	or     $0x7,%eax
  810251:	50                   	push   %eax
  810252:	03 15 d4 b1 b3 00    	add    0xb3b1d4,%edx
  810258:	52                   	push   %edx
  810259:	6a 00                	push   $0x0
  81025b:	e8 59 eb ff ff       	call   80edb9 <sys_page_alloc>
  810260:	83 c4 10             	add    $0x10,%esp
  810263:	85 c0                	test   %eax,%eax
  810265:	78 20                	js     810287 <malloc+0x170>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  810267:	89 fe                	mov    %edi,%esi
  810269:	eb 3a                	jmp    8102a5 <malloc+0x18e>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
				sys_page_unmap(0, mptr + i);
  81026b:	83 ec 08             	sub    $0x8,%esp
  81026e:	89 f0                	mov    %esi,%eax
  810270:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810276:	50                   	push   %eax
  810277:	6a 00                	push   $0x0
  810279:	e8 c0 eb ff ff       	call   80ee3e <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  81027e:	81 ee 00 10 00 00    	sub    $0x1000,%esi
  810284:	83 c4 10             	add    $0x10,%esp
  810287:	85 f6                	test   %esi,%esi
  810289:	79 e0                	jns    81026b <malloc+0x154>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  81028b:	b8 00 00 00 00       	mov    $0x0,%eax
  810290:	eb 5d                	jmp    8102ef <malloc+0x1d8>
  810292:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  810296:	74 08                	je     8102a0 <malloc+0x189>
  810298:	8b 45 e0             	mov    -0x20(%ebp),%eax
  81029b:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  8102a0:	be 00 00 00 00       	mov    $0x0,%esi
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  8102a5:	89 f2                	mov    %esi,%edx
  8102a7:	39 f3                	cmp    %esi,%ebx
  8102a9:	77 91                	ja     81023c <malloc+0x125>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  8102ab:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  8102b0:	c7 44 30 fc 02 00 00 	movl   $0x2,-0x4(%eax,%esi,1)
  8102b7:	00 
	v = mptr;
	mptr += n;
  8102b8:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8102bb:	01 c2                	add    %eax,%edx
  8102bd:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
	return v;
  8102c3:	eb 2a                	jmp    8102ef <malloc+0x1d8>
		mptr = mbegin;

	n = ROUNDUP(n, 4);

	if (n >= MAXMALLOC)
		return 0;
  8102c5:	b8 00 00 00 00       	mov    $0x0,%eax
  8102ca:	eb 23                	jmp    8102ef <malloc+0x1d8>
  8102cc:	b8 00 00 00 00       	mov    $0x0,%eax
  8102d1:	eb 1c                	jmp    8102ef <malloc+0x1d8>
  8102d3:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
  8102d9:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  8102dd:	89 c6                	mov    %eax,%esi
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  8102df:	3d 00 00 00 10       	cmp    $0x10000000,%eax
  8102e4:	0f 85 e7 fe ff ff    	jne    8101d1 <malloc+0xba>
  8102ea:	e9 2a ff ff ff       	jmp    810219 <malloc+0x102>
	ref = (uint32_t*) (mptr + i - 4);
	*ref = 2;	/* reference for mptr, reference for returned block */
	v = mptr;
	mptr += n;
	return v;
}
  8102ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8102f2:	5b                   	pop    %ebx
  8102f3:	5e                   	pop    %esi
  8102f4:	5f                   	pop    %edi
  8102f5:	5d                   	pop    %ebp
  8102f6:	c3                   	ret    

008102f7 <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  8102f7:	55                   	push   %ebp
  8102f8:	89 e5                	mov    %esp,%ebp
  8102fa:	56                   	push   %esi
  8102fb:	53                   	push   %ebx
  8102fc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  8102ff:	83 ec 0c             	sub    $0xc,%esp
  810302:	ff 75 08             	pushl  0x8(%ebp)
  810305:	e8 f9 f0 ff ff       	call   80f403 <fd2data>
  81030a:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  81030c:	83 c4 08             	add    $0x8,%esp
  81030f:	68 03 37 81 00       	push   $0x813703
  810314:	53                   	push   %ebx
  810315:	e8 9c e6 ff ff       	call   80e9b6 <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  81031a:	8b 46 04             	mov    0x4(%esi),%eax
  81031d:	2b 06                	sub    (%esi),%eax
  81031f:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  810325:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  81032c:	00 00 00 
	stat->st_dev = &devpipe;
  81032f:	c7 83 88 00 00 00 24 	movl   $0x814324,0x88(%ebx)
  810336:	43 81 00 
	return 0;
}
  810339:	b8 00 00 00 00       	mov    $0x0,%eax
  81033e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810341:	5b                   	pop    %ebx
  810342:	5e                   	pop    %esi
  810343:	5d                   	pop    %ebp
  810344:	c3                   	ret    

00810345 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  810345:	55                   	push   %ebp
  810346:	89 e5                	mov    %esp,%ebp
  810348:	53                   	push   %ebx
  810349:	83 ec 0c             	sub    $0xc,%esp
  81034c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  81034f:	53                   	push   %ebx
  810350:	6a 00                	push   $0x0
  810352:	e8 e7 ea ff ff       	call   80ee3e <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  810357:	89 1c 24             	mov    %ebx,(%esp)
  81035a:	e8 a4 f0 ff ff       	call   80f403 <fd2data>
  81035f:	83 c4 08             	add    $0x8,%esp
  810362:	50                   	push   %eax
  810363:	6a 00                	push   $0x0
  810365:	e8 d4 ea ff ff       	call   80ee3e <sys_page_unmap>
}
  81036a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81036d:	c9                   	leave  
  81036e:	c3                   	ret    

0081036f <_pipeisclosed>:
	return r;
}

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  81036f:	55                   	push   %ebp
  810370:	89 e5                	mov    %esp,%ebp
  810372:	57                   	push   %edi
  810373:	56                   	push   %esi
  810374:	53                   	push   %ebx
  810375:	83 ec 1c             	sub    $0x1c,%esp
  810378:	89 45 e0             	mov    %eax,-0x20(%ebp)
  81037b:	89 d7                	mov    %edx,%edi
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  81037d:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810382:	8b 70 58             	mov    0x58(%eax),%esi
		ret = pageref(fd) == pageref(p);
  810385:	83 ec 0c             	sub    $0xc,%esp
  810388:	ff 75 e0             	pushl  -0x20(%ebp)
  81038b:	e8 d9 04 00 00       	call   810869 <pageref>
  810390:	89 c3                	mov    %eax,%ebx
  810392:	89 3c 24             	mov    %edi,(%esp)
  810395:	e8 cf 04 00 00       	call   810869 <pageref>
  81039a:	83 c4 10             	add    $0x10,%esp
  81039d:	39 c3                	cmp    %eax,%ebx
  81039f:	0f 94 c1             	sete   %cl
  8103a2:	0f b6 c9             	movzbl %cl,%ecx
  8103a5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		nn = thisenv->env_runs;
  8103a8:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  8103ae:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  8103b1:	39 ce                	cmp    %ecx,%esi
  8103b3:	74 1b                	je     8103d0 <_pipeisclosed+0x61>
			return ret;
		if (n != nn && ret == 1)
  8103b5:	39 c3                	cmp    %eax,%ebx
  8103b7:	75 c4                	jne    81037d <_pipeisclosed+0xe>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  8103b9:	8b 42 58             	mov    0x58(%edx),%eax
  8103bc:	ff 75 e4             	pushl  -0x1c(%ebp)
  8103bf:	50                   	push   %eax
  8103c0:	56                   	push   %esi
  8103c1:	68 0a 37 81 00       	push   $0x81370a
  8103c6:	e8 66 e0 ff ff       	call   80e431 <cprintf>
  8103cb:	83 c4 10             	add    $0x10,%esp
  8103ce:	eb ad                	jmp    81037d <_pipeisclosed+0xe>
	}
}
  8103d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8103d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8103d6:	5b                   	pop    %ebx
  8103d7:	5e                   	pop    %esi
  8103d8:	5f                   	pop    %edi
  8103d9:	5d                   	pop    %ebp
  8103da:	c3                   	ret    

008103db <devpipe_write>:
	return i;
}

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  8103db:	55                   	push   %ebp
  8103dc:	89 e5                	mov    %esp,%ebp
  8103de:	57                   	push   %edi
  8103df:	56                   	push   %esi
  8103e0:	53                   	push   %ebx
  8103e1:	83 ec 28             	sub    $0x28,%esp
  8103e4:	8b 75 08             	mov    0x8(%ebp),%esi
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  8103e7:	56                   	push   %esi
  8103e8:	e8 16 f0 ff ff       	call   80f403 <fd2data>
  8103ed:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8103ef:	83 c4 10             	add    $0x10,%esp
  8103f2:	bf 00 00 00 00       	mov    $0x0,%edi
  8103f7:	eb 4b                	jmp    810444 <devpipe_write+0x69>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  8103f9:	89 da                	mov    %ebx,%edx
  8103fb:	89 f0                	mov    %esi,%eax
  8103fd:	e8 6d ff ff ff       	call   81036f <_pipeisclosed>
  810402:	85 c0                	test   %eax,%eax
  810404:	75 48                	jne    81044e <devpipe_write+0x73>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  810406:	e8 8f e9 ff ff       	call   80ed9a <sys_yield>
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  81040b:	8b 43 04             	mov    0x4(%ebx),%eax
  81040e:	8b 0b                	mov    (%ebx),%ecx
  810410:	8d 51 20             	lea    0x20(%ecx),%edx
  810413:	39 d0                	cmp    %edx,%eax
  810415:	73 e2                	jae    8103f9 <devpipe_write+0x1e>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  810417:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  81041a:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  81041e:	88 4d e7             	mov    %cl,-0x19(%ebp)
  810421:	89 c2                	mov    %eax,%edx
  810423:	c1 fa 1f             	sar    $0x1f,%edx
  810426:	89 d1                	mov    %edx,%ecx
  810428:	c1 e9 1b             	shr    $0x1b,%ecx
  81042b:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  81042e:	83 e2 1f             	and    $0x1f,%edx
  810431:	29 ca                	sub    %ecx,%edx
  810433:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  810437:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  81043b:	83 c0 01             	add    $0x1,%eax
  81043e:	89 43 04             	mov    %eax,0x4(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  810441:	83 c7 01             	add    $0x1,%edi
  810444:	3b 7d 10             	cmp    0x10(%ebp),%edi
  810447:	75 c2                	jne    81040b <devpipe_write+0x30>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  810449:	8b 45 10             	mov    0x10(%ebp),%eax
  81044c:	eb 05                	jmp    810453 <devpipe_write+0x78>
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
				return 0;
  81044e:	b8 00 00 00 00       	mov    $0x0,%eax
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
}
  810453:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810456:	5b                   	pop    %ebx
  810457:	5e                   	pop    %esi
  810458:	5f                   	pop    %edi
  810459:	5d                   	pop    %ebp
  81045a:	c3                   	ret    

0081045b <devpipe_read>:
	return _pipeisclosed(fd, p);
}

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  81045b:	55                   	push   %ebp
  81045c:	89 e5                	mov    %esp,%ebp
  81045e:	57                   	push   %edi
  81045f:	56                   	push   %esi
  810460:	53                   	push   %ebx
  810461:	83 ec 18             	sub    $0x18,%esp
  810464:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  810467:	57                   	push   %edi
  810468:	e8 96 ef ff ff       	call   80f403 <fd2data>
  81046d:	89 c6                	mov    %eax,%esi
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  81046f:	83 c4 10             	add    $0x10,%esp
  810472:	bb 00 00 00 00       	mov    $0x0,%ebx
  810477:	eb 3d                	jmp    8104b6 <devpipe_read+0x5b>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  810479:	85 db                	test   %ebx,%ebx
  81047b:	74 04                	je     810481 <devpipe_read+0x26>
				return i;
  81047d:	89 d8                	mov    %ebx,%eax
  81047f:	eb 44                	jmp    8104c5 <devpipe_read+0x6a>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  810481:	89 f2                	mov    %esi,%edx
  810483:	89 f8                	mov    %edi,%eax
  810485:	e8 e5 fe ff ff       	call   81036f <_pipeisclosed>
  81048a:	85 c0                	test   %eax,%eax
  81048c:	75 32                	jne    8104c0 <devpipe_read+0x65>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  81048e:	e8 07 e9 ff ff       	call   80ed9a <sys_yield>
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  810493:	8b 06                	mov    (%esi),%eax
  810495:	3b 46 04             	cmp    0x4(%esi),%eax
  810498:	74 df                	je     810479 <devpipe_read+0x1e>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  81049a:	99                   	cltd   
  81049b:	c1 ea 1b             	shr    $0x1b,%edx
  81049e:	01 d0                	add    %edx,%eax
  8104a0:	83 e0 1f             	and    $0x1f,%eax
  8104a3:	29 d0                	sub    %edx,%eax
  8104a5:	0f b6 44 06 08       	movzbl 0x8(%esi,%eax,1),%eax
  8104aa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8104ad:	88 04 19             	mov    %al,(%ecx,%ebx,1)
		p->p_rpos++;
  8104b0:	83 06 01             	addl   $0x1,(%esi)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8104b3:	83 c3 01             	add    $0x1,%ebx
  8104b6:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  8104b9:	75 d8                	jne    810493 <devpipe_read+0x38>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  8104bb:	8b 45 10             	mov    0x10(%ebp),%eax
  8104be:	eb 05                	jmp    8104c5 <devpipe_read+0x6a>
			// if we got any data, return it
			if (i > 0)
				return i;
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
				return 0;
  8104c0:	b8 00 00 00 00       	mov    $0x0,%eax
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
}
  8104c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8104c8:	5b                   	pop    %ebx
  8104c9:	5e                   	pop    %esi
  8104ca:	5f                   	pop    %edi
  8104cb:	5d                   	pop    %ebp
  8104cc:	c3                   	ret    

008104cd <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  8104cd:	55                   	push   %ebp
  8104ce:	89 e5                	mov    %esp,%ebp
  8104d0:	56                   	push   %esi
  8104d1:	53                   	push   %ebx
  8104d2:	83 ec 1c             	sub    $0x1c,%esp
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  8104d5:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8104d8:	50                   	push   %eax
  8104d9:	e8 3c ef ff ff       	call   80f41a <fd_alloc>
  8104de:	83 c4 10             	add    $0x10,%esp
  8104e1:	89 c2                	mov    %eax,%edx
  8104e3:	85 c0                	test   %eax,%eax
  8104e5:	0f 88 2c 01 00 00    	js     810617 <pipe+0x14a>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8104eb:	83 ec 04             	sub    $0x4,%esp
  8104ee:	68 07 04 00 00       	push   $0x407
  8104f3:	ff 75 f4             	pushl  -0xc(%ebp)
  8104f6:	6a 00                	push   $0x0
  8104f8:	e8 bc e8 ff ff       	call   80edb9 <sys_page_alloc>
  8104fd:	83 c4 10             	add    $0x10,%esp
  810500:	89 c2                	mov    %eax,%edx
  810502:	85 c0                	test   %eax,%eax
  810504:	0f 88 0d 01 00 00    	js     810617 <pipe+0x14a>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  81050a:	83 ec 0c             	sub    $0xc,%esp
  81050d:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810510:	50                   	push   %eax
  810511:	e8 04 ef ff ff       	call   80f41a <fd_alloc>
  810516:	89 c3                	mov    %eax,%ebx
  810518:	83 c4 10             	add    $0x10,%esp
  81051b:	85 c0                	test   %eax,%eax
  81051d:	0f 88 e2 00 00 00    	js     810605 <pipe+0x138>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810523:	83 ec 04             	sub    $0x4,%esp
  810526:	68 07 04 00 00       	push   $0x407
  81052b:	ff 75 f0             	pushl  -0x10(%ebp)
  81052e:	6a 00                	push   $0x0
  810530:	e8 84 e8 ff ff       	call   80edb9 <sys_page_alloc>
  810535:	89 c3                	mov    %eax,%ebx
  810537:	83 c4 10             	add    $0x10,%esp
  81053a:	85 c0                	test   %eax,%eax
  81053c:	0f 88 c3 00 00 00    	js     810605 <pipe+0x138>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  810542:	83 ec 0c             	sub    $0xc,%esp
  810545:	ff 75 f4             	pushl  -0xc(%ebp)
  810548:	e8 b6 ee ff ff       	call   80f403 <fd2data>
  81054d:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  81054f:	83 c4 0c             	add    $0xc,%esp
  810552:	68 07 04 00 00       	push   $0x407
  810557:	50                   	push   %eax
  810558:	6a 00                	push   $0x0
  81055a:	e8 5a e8 ff ff       	call   80edb9 <sys_page_alloc>
  81055f:	89 c3                	mov    %eax,%ebx
  810561:	83 c4 10             	add    $0x10,%esp
  810564:	85 c0                	test   %eax,%eax
  810566:	0f 88 89 00 00 00    	js     8105f5 <pipe+0x128>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  81056c:	83 ec 0c             	sub    $0xc,%esp
  81056f:	ff 75 f0             	pushl  -0x10(%ebp)
  810572:	e8 8c ee ff ff       	call   80f403 <fd2data>
  810577:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  81057e:	50                   	push   %eax
  81057f:	6a 00                	push   $0x0
  810581:	56                   	push   %esi
  810582:	6a 00                	push   $0x0
  810584:	e8 73 e8 ff ff       	call   80edfc <sys_page_map>
  810589:	89 c3                	mov    %eax,%ebx
  81058b:	83 c4 20             	add    $0x20,%esp
  81058e:	85 c0                	test   %eax,%eax
  810590:	78 55                	js     8105e7 <pipe+0x11a>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  810592:	8b 15 24 43 81 00    	mov    0x814324,%edx
  810598:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81059b:	89 10                	mov    %edx,(%eax)
	fd0->fd_omode = O_RDONLY;
  81059d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8105a0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	fd1->fd_dev_id = devpipe.dev_id;
  8105a7:	8b 15 24 43 81 00    	mov    0x814324,%edx
  8105ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8105b0:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  8105b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8105b5:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  8105bc:	83 ec 0c             	sub    $0xc,%esp
  8105bf:	ff 75 f4             	pushl  -0xc(%ebp)
  8105c2:	e8 2c ee ff ff       	call   80f3f3 <fd2num>
  8105c7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8105ca:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  8105cc:	83 c4 04             	add    $0x4,%esp
  8105cf:	ff 75 f0             	pushl  -0x10(%ebp)
  8105d2:	e8 1c ee ff ff       	call   80f3f3 <fd2num>
  8105d7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8105da:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  8105dd:	83 c4 10             	add    $0x10,%esp
  8105e0:	ba 00 00 00 00       	mov    $0x0,%edx
  8105e5:	eb 30                	jmp    810617 <pipe+0x14a>

    err3:
	sys_page_unmap(0, va);
  8105e7:	83 ec 08             	sub    $0x8,%esp
  8105ea:	56                   	push   %esi
  8105eb:	6a 00                	push   $0x0
  8105ed:	e8 4c e8 ff ff       	call   80ee3e <sys_page_unmap>
  8105f2:	83 c4 10             	add    $0x10,%esp
    err2:
	sys_page_unmap(0, fd1);
  8105f5:	83 ec 08             	sub    $0x8,%esp
  8105f8:	ff 75 f0             	pushl  -0x10(%ebp)
  8105fb:	6a 00                	push   $0x0
  8105fd:	e8 3c e8 ff ff       	call   80ee3e <sys_page_unmap>
  810602:	83 c4 10             	add    $0x10,%esp
    err1:
	sys_page_unmap(0, fd0);
  810605:	83 ec 08             	sub    $0x8,%esp
  810608:	ff 75 f4             	pushl  -0xc(%ebp)
  81060b:	6a 00                	push   $0x0
  81060d:	e8 2c e8 ff ff       	call   80ee3e <sys_page_unmap>
  810612:	83 c4 10             	add    $0x10,%esp
  810615:	89 da                	mov    %ebx,%edx
    err:
	return r;
}
  810617:	89 d0                	mov    %edx,%eax
  810619:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81061c:	5b                   	pop    %ebx
  81061d:	5e                   	pop    %esi
  81061e:	5d                   	pop    %ebp
  81061f:	c3                   	ret    

00810620 <pipeisclosed>:
	}
}

int
pipeisclosed(int fdnum)
{
  810620:	55                   	push   %ebp
  810621:	89 e5                	mov    %esp,%ebp
  810623:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810626:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810629:	50                   	push   %eax
  81062a:	ff 75 08             	pushl  0x8(%ebp)
  81062d:	e8 37 ee ff ff       	call   80f469 <fd_lookup>
  810632:	83 c4 10             	add    $0x10,%esp
  810635:	85 c0                	test   %eax,%eax
  810637:	78 18                	js     810651 <pipeisclosed+0x31>
		return r;
	p = (struct Pipe*) fd2data(fd);
  810639:	83 ec 0c             	sub    $0xc,%esp
  81063c:	ff 75 f4             	pushl  -0xc(%ebp)
  81063f:	e8 bf ed ff ff       	call   80f403 <fd2data>
	return _pipeisclosed(fd, p);
  810644:	89 c2                	mov    %eax,%edx
  810646:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810649:	e8 21 fd ff ff       	call   81036f <_pipeisclosed>
  81064e:	83 c4 10             	add    $0x10,%esp
}
  810651:	c9                   	leave  
  810652:	c3                   	ret    

00810653 <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  810653:	55                   	push   %ebp
  810654:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  810656:	b8 00 00 00 00       	mov    $0x0,%eax
  81065b:	5d                   	pop    %ebp
  81065c:	c3                   	ret    

0081065d <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  81065d:	55                   	push   %ebp
  81065e:	89 e5                	mov    %esp,%ebp
  810660:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  810663:	68 22 37 81 00       	push   $0x813722
  810668:	ff 75 0c             	pushl  0xc(%ebp)
  81066b:	e8 46 e3 ff ff       	call   80e9b6 <strcpy>
	return 0;
}
  810670:	b8 00 00 00 00       	mov    $0x0,%eax
  810675:	c9                   	leave  
  810676:	c3                   	ret    

00810677 <devcons_write>:
	return 1;
}

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  810677:	55                   	push   %ebp
  810678:	89 e5                	mov    %esp,%ebp
  81067a:	57                   	push   %edi
  81067b:	56                   	push   %esi
  81067c:	53                   	push   %ebx
  81067d:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  810683:	be 00 00 00 00       	mov    $0x0,%esi
		m = n - tot;
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  810688:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  81068e:	eb 2d                	jmp    8106bd <devcons_write+0x46>
		m = n - tot;
  810690:	8b 5d 10             	mov    0x10(%ebp),%ebx
  810693:	29 f3                	sub    %esi,%ebx
		if (m > sizeof(buf) - 1)
  810695:	83 fb 7f             	cmp    $0x7f,%ebx
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
		m = n - tot;
  810698:	ba 7f 00 00 00       	mov    $0x7f,%edx
  81069d:	0f 47 da             	cmova  %edx,%ebx
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  8106a0:	83 ec 04             	sub    $0x4,%esp
  8106a3:	53                   	push   %ebx
  8106a4:	03 45 0c             	add    0xc(%ebp),%eax
  8106a7:	50                   	push   %eax
  8106a8:	57                   	push   %edi
  8106a9:	e8 9a e4 ff ff       	call   80eb48 <memmove>
		sys_cputs(buf, m);
  8106ae:	83 c4 08             	add    $0x8,%esp
  8106b1:	53                   	push   %ebx
  8106b2:	57                   	push   %edi
  8106b3:	e8 45 e6 ff ff       	call   80ecfd <sys_cputs>
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8106b8:	01 de                	add    %ebx,%esi
  8106ba:	83 c4 10             	add    $0x10,%esp
  8106bd:	89 f0                	mov    %esi,%eax
  8106bf:	3b 75 10             	cmp    0x10(%ebp),%esi
  8106c2:	72 cc                	jb     810690 <devcons_write+0x19>
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
}
  8106c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8106c7:	5b                   	pop    %ebx
  8106c8:	5e                   	pop    %esi
  8106c9:	5f                   	pop    %edi
  8106ca:	5d                   	pop    %ebp
  8106cb:	c3                   	ret    

008106cc <devcons_read>:
	return fd2num(fd);
}

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  8106cc:	55                   	push   %ebp
  8106cd:	89 e5                	mov    %esp,%ebp
  8106cf:	83 ec 08             	sub    $0x8,%esp
  8106d2:	b8 00 00 00 00       	mov    $0x0,%eax
	int c;

	if (n == 0)
  8106d7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8106db:	74 2a                	je     810707 <devcons_read+0x3b>
  8106dd:	eb 05                	jmp    8106e4 <devcons_read+0x18>
		return 0;

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  8106df:	e8 b6 e6 ff ff       	call   80ed9a <sys_yield>
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  8106e4:	e8 32 e6 ff ff       	call   80ed1b <sys_cgetc>
  8106e9:	85 c0                	test   %eax,%eax
  8106eb:	74 f2                	je     8106df <devcons_read+0x13>
		sys_yield();
	if (c < 0)
  8106ed:	85 c0                	test   %eax,%eax
  8106ef:	78 16                	js     810707 <devcons_read+0x3b>
		return c;
	if (c == 0x04)	// ctl-d is eof
  8106f1:	83 f8 04             	cmp    $0x4,%eax
  8106f4:	74 0c                	je     810702 <devcons_read+0x36>
		return 0;
	*(char*)vbuf = c;
  8106f6:	8b 55 0c             	mov    0xc(%ebp),%edx
  8106f9:	88 02                	mov    %al,(%edx)
	return 1;
  8106fb:	b8 01 00 00 00       	mov    $0x1,%eax
  810700:	eb 05                	jmp    810707 <devcons_read+0x3b>
	while ((c = sys_cgetc()) == 0)
		sys_yield();
	if (c < 0)
		return c;
	if (c == 0x04)	// ctl-d is eof
		return 0;
  810702:	b8 00 00 00 00       	mov    $0x0,%eax
	*(char*)vbuf = c;
	return 1;
}
  810707:	c9                   	leave  
  810708:	c3                   	ret    

00810709 <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  810709:	55                   	push   %ebp
  81070a:	89 e5                	mov    %esp,%ebp
  81070c:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  81070f:	8b 45 08             	mov    0x8(%ebp),%eax
  810712:	88 45 f7             	mov    %al,-0x9(%ebp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  810715:	6a 01                	push   $0x1
  810717:	8d 45 f7             	lea    -0x9(%ebp),%eax
  81071a:	50                   	push   %eax
  81071b:	e8 dd e5 ff ff       	call   80ecfd <sys_cputs>
}
  810720:	83 c4 10             	add    $0x10,%esp
  810723:	c9                   	leave  
  810724:	c3                   	ret    

00810725 <getchar>:

int
getchar(void)
{
  810725:	55                   	push   %ebp
  810726:	89 e5                	mov    %esp,%ebp
  810728:	83 ec 1c             	sub    $0x1c,%esp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  81072b:	6a 01                	push   $0x1
  81072d:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810730:	50                   	push   %eax
  810731:	6a 00                	push   $0x0
  810733:	e8 97 ef ff ff       	call   80f6cf <read>
	if (r < 0)
  810738:	83 c4 10             	add    $0x10,%esp
  81073b:	85 c0                	test   %eax,%eax
  81073d:	78 0f                	js     81074e <getchar+0x29>
		return r;
	if (r < 1)
  81073f:	85 c0                	test   %eax,%eax
  810741:	7e 06                	jle    810749 <getchar+0x24>
		return -E_EOF;
	return c;
  810743:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  810747:	eb 05                	jmp    81074e <getchar+0x29>
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
	if (r < 0)
		return r;
	if (r < 1)
		return -E_EOF;
  810749:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	return c;
}
  81074e:	c9                   	leave  
  81074f:	c3                   	ret    

00810750 <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  810750:	55                   	push   %ebp
  810751:	89 e5                	mov    %esp,%ebp
  810753:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810756:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810759:	50                   	push   %eax
  81075a:	ff 75 08             	pushl  0x8(%ebp)
  81075d:	e8 07 ed ff ff       	call   80f469 <fd_lookup>
  810762:	83 c4 10             	add    $0x10,%esp
  810765:	85 c0                	test   %eax,%eax
  810767:	78 11                	js     81077a <iscons+0x2a>
		return r;
	return fd->fd_dev_id == devcons.dev_id;
  810769:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81076c:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810772:	39 10                	cmp    %edx,(%eax)
  810774:	0f 94 c0             	sete   %al
  810777:	0f b6 c0             	movzbl %al,%eax
}
  81077a:	c9                   	leave  
  81077b:	c3                   	ret    

0081077c <opencons>:

int
opencons(void)
{
  81077c:	55                   	push   %ebp
  81077d:	89 e5                	mov    %esp,%ebp
  81077f:	83 ec 24             	sub    $0x24,%esp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  810782:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810785:	50                   	push   %eax
  810786:	e8 8f ec ff ff       	call   80f41a <fd_alloc>
  81078b:	83 c4 10             	add    $0x10,%esp
		return r;
  81078e:	89 c2                	mov    %eax,%edx
opencons(void)
{
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  810790:	85 c0                	test   %eax,%eax
  810792:	78 3e                	js     8107d2 <opencons+0x56>
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  810794:	83 ec 04             	sub    $0x4,%esp
  810797:	68 07 04 00 00       	push   $0x407
  81079c:	ff 75 f4             	pushl  -0xc(%ebp)
  81079f:	6a 00                	push   $0x0
  8107a1:	e8 13 e6 ff ff       	call   80edb9 <sys_page_alloc>
  8107a6:	83 c4 10             	add    $0x10,%esp
		return r;
  8107a9:	89 c2                	mov    %eax,%edx
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  8107ab:	85 c0                	test   %eax,%eax
  8107ad:	78 23                	js     8107d2 <opencons+0x56>
		return r;
	fd->fd_dev_id = devcons.dev_id;
  8107af:	8b 15 40 43 81 00    	mov    0x814340,%edx
  8107b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8107b8:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  8107ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8107bd:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  8107c4:	83 ec 0c             	sub    $0xc,%esp
  8107c7:	50                   	push   %eax
  8107c8:	e8 26 ec ff ff       	call   80f3f3 <fd2num>
  8107cd:	89 c2                	mov    %eax,%edx
  8107cf:	83 c4 10             	add    $0x10,%esp
}
  8107d2:	89 d0                	mov    %edx,%eax
  8107d4:	c9                   	leave  
  8107d5:	c3                   	ret    

008107d6 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  8107d6:	55                   	push   %ebp
  8107d7:	89 e5                	mov    %esp,%ebp
  8107d9:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  8107dc:	83 3d 00 e0 b3 00 00 	cmpl   $0x0,0xb3e000
  8107e3:	75 2c                	jne    810811 <set_pgfault_handler+0x3b>
		// First time through!
		// LAB 4: Your code here.
        
        if (sys_page_alloc(0, (void*)(UXSTACKTOP-PGSIZE), PTE_W|PTE_U|PTE_P) < 0) 
  8107e5:	83 ec 04             	sub    $0x4,%esp
  8107e8:	6a 07                	push   $0x7
  8107ea:	68 00 f0 bf ee       	push   $0xeebff000
  8107ef:	6a 00                	push   $0x0
  8107f1:	e8 c3 e5 ff ff       	call   80edb9 <sys_page_alloc>
  8107f6:	83 c4 10             	add    $0x10,%esp
  8107f9:	85 c0                	test   %eax,%eax
  8107fb:	79 14                	jns    810811 <set_pgfault_handler+0x3b>
            panic("sys_page_alloc failed\n");
  8107fd:	83 ec 04             	sub    $0x4,%esp
  810800:	68 2e 37 81 00       	push   $0x81372e
  810805:	6a 22                	push   $0x22
  810807:	68 45 37 81 00       	push   $0x813745
  81080c:	e8 47 db ff ff       	call   80e358 <_panic>
    }        
    // Save handler pointer for assembly to call.
    _pgfault_handler = handler;
  810811:	8b 45 08             	mov    0x8(%ebp),%eax
  810814:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
    if (sys_env_set_pgfault_upcall(0, _pgfault_upcall) < 0)
  810819:	83 ec 08             	sub    $0x8,%esp
  81081c:	68 45 08 81 00       	push   $0x810845
  810821:	6a 00                	push   $0x0
  810823:	e8 dc e6 ff ff       	call   80ef04 <sys_env_set_pgfault_upcall>
  810828:	83 c4 10             	add    $0x10,%esp
  81082b:	85 c0                	test   %eax,%eax
  81082d:	79 14                	jns    810843 <set_pgfault_handler+0x6d>
    	panic("sys_env_set_pgfault_upcall failed\n");
  81082f:	83 ec 04             	sub    $0x4,%esp
  810832:	68 54 37 81 00       	push   $0x813754
  810837:	6a 27                	push   $0x27
  810839:	68 45 37 81 00       	push   $0x813745
  81083e:	e8 15 db ff ff       	call   80e358 <_panic>
    
}
  810843:	c9                   	leave  
  810844:	c3                   	ret    

00810845 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  810845:	54                   	push   %esp
	movl _pgfault_handler, %eax
  810846:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
	call *%eax
  81084b:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  81084d:	83 c4 04             	add    $0x4,%esp
	// registers are available for intermediate calculations.  You
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
	movl 0x28(%esp), %edx // trap-time eip
  810850:	8b 54 24 28          	mov    0x28(%esp),%edx
    subl $0x4, 0x30(%esp) 
  810854:	83 6c 24 30 04       	subl   $0x4,0x30(%esp)
    movl 0x30(%esp), %eax // trap-time esp-4
  810859:	8b 44 24 30          	mov    0x30(%esp),%eax
    movl %edx, (%eax)
  81085d:	89 10                	mov    %edx,(%eax)
   

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	addl $0x8, %esp
  81085f:	83 c4 08             	add    $0x8,%esp
	popal
  810862:	61                   	popa   

	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	addl $0x04, %esp
  810863:	83 c4 04             	add    $0x4,%esp
	popfl
  810866:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popl %esp
  810867:	5c                   	pop    %esp
	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	ret
  810868:	c3                   	ret    

00810869 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  810869:	55                   	push   %ebp
  81086a:	89 e5                	mov    %esp,%ebp
  81086c:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  81086f:	89 d0                	mov    %edx,%eax
  810871:	c1 e8 16             	shr    $0x16,%eax
  810874:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  81087b:	b8 00 00 00 00       	mov    $0x0,%eax
int
pageref(void *v)
{
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  810880:	f6 c1 01             	test   $0x1,%cl
  810883:	74 1d                	je     8108a2 <pageref+0x39>
		return 0;
	pte = uvpt[PGNUM(v)];
  810885:	c1 ea 0c             	shr    $0xc,%edx
  810888:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  81088f:	f6 c2 01             	test   $0x1,%dl
  810892:	74 0e                	je     8108a2 <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  810894:	c1 ea 0c             	shr    $0xc,%edx
  810897:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  81089e:	ef 
  81089f:	0f b7 c0             	movzwl %ax,%eax
}
  8108a2:	5d                   	pop    %ebp
  8108a3:	c3                   	ret    
  8108a4:	66 90                	xchg   %ax,%ax
  8108a6:	66 90                	xchg   %ax,%ax
  8108a8:	66 90                	xchg   %ax,%ax
  8108aa:	66 90                	xchg   %ax,%ax
  8108ac:	66 90                	xchg   %ax,%ax
  8108ae:	66 90                	xchg   %ax,%ax

008108b0 <__udivdi3>:
  8108b0:	55                   	push   %ebp
  8108b1:	57                   	push   %edi
  8108b2:	56                   	push   %esi
  8108b3:	53                   	push   %ebx
  8108b4:	83 ec 1c             	sub    $0x1c,%esp
  8108b7:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  8108bb:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  8108bf:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  8108c3:	8b 7c 24 38          	mov    0x38(%esp),%edi
  8108c7:	85 f6                	test   %esi,%esi
  8108c9:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8108cd:	89 ca                	mov    %ecx,%edx
  8108cf:	89 f8                	mov    %edi,%eax
  8108d1:	75 3d                	jne    810910 <__udivdi3+0x60>
  8108d3:	39 cf                	cmp    %ecx,%edi
  8108d5:	0f 87 c5 00 00 00    	ja     8109a0 <__udivdi3+0xf0>
  8108db:	85 ff                	test   %edi,%edi
  8108dd:	89 fd                	mov    %edi,%ebp
  8108df:	75 0b                	jne    8108ec <__udivdi3+0x3c>
  8108e1:	b8 01 00 00 00       	mov    $0x1,%eax
  8108e6:	31 d2                	xor    %edx,%edx
  8108e8:	f7 f7                	div    %edi
  8108ea:	89 c5                	mov    %eax,%ebp
  8108ec:	89 c8                	mov    %ecx,%eax
  8108ee:	31 d2                	xor    %edx,%edx
  8108f0:	f7 f5                	div    %ebp
  8108f2:	89 c1                	mov    %eax,%ecx
  8108f4:	89 d8                	mov    %ebx,%eax
  8108f6:	89 cf                	mov    %ecx,%edi
  8108f8:	f7 f5                	div    %ebp
  8108fa:	89 c3                	mov    %eax,%ebx
  8108fc:	89 d8                	mov    %ebx,%eax
  8108fe:	89 fa                	mov    %edi,%edx
  810900:	83 c4 1c             	add    $0x1c,%esp
  810903:	5b                   	pop    %ebx
  810904:	5e                   	pop    %esi
  810905:	5f                   	pop    %edi
  810906:	5d                   	pop    %ebp
  810907:	c3                   	ret    
  810908:	90                   	nop
  810909:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810910:	39 ce                	cmp    %ecx,%esi
  810912:	77 74                	ja     810988 <__udivdi3+0xd8>
  810914:	0f bd fe             	bsr    %esi,%edi
  810917:	83 f7 1f             	xor    $0x1f,%edi
  81091a:	0f 84 98 00 00 00    	je     8109b8 <__udivdi3+0x108>
  810920:	bb 20 00 00 00       	mov    $0x20,%ebx
  810925:	89 f9                	mov    %edi,%ecx
  810927:	89 c5                	mov    %eax,%ebp
  810929:	29 fb                	sub    %edi,%ebx
  81092b:	d3 e6                	shl    %cl,%esi
  81092d:	89 d9                	mov    %ebx,%ecx
  81092f:	d3 ed                	shr    %cl,%ebp
  810931:	89 f9                	mov    %edi,%ecx
  810933:	d3 e0                	shl    %cl,%eax
  810935:	09 ee                	or     %ebp,%esi
  810937:	89 d9                	mov    %ebx,%ecx
  810939:	89 44 24 0c          	mov    %eax,0xc(%esp)
  81093d:	89 d5                	mov    %edx,%ebp
  81093f:	8b 44 24 08          	mov    0x8(%esp),%eax
  810943:	d3 ed                	shr    %cl,%ebp
  810945:	89 f9                	mov    %edi,%ecx
  810947:	d3 e2                	shl    %cl,%edx
  810949:	89 d9                	mov    %ebx,%ecx
  81094b:	d3 e8                	shr    %cl,%eax
  81094d:	09 c2                	or     %eax,%edx
  81094f:	89 d0                	mov    %edx,%eax
  810951:	89 ea                	mov    %ebp,%edx
  810953:	f7 f6                	div    %esi
  810955:	89 d5                	mov    %edx,%ebp
  810957:	89 c3                	mov    %eax,%ebx
  810959:	f7 64 24 0c          	mull   0xc(%esp)
  81095d:	39 d5                	cmp    %edx,%ebp
  81095f:	72 10                	jb     810971 <__udivdi3+0xc1>
  810961:	8b 74 24 08          	mov    0x8(%esp),%esi
  810965:	89 f9                	mov    %edi,%ecx
  810967:	d3 e6                	shl    %cl,%esi
  810969:	39 c6                	cmp    %eax,%esi
  81096b:	73 07                	jae    810974 <__udivdi3+0xc4>
  81096d:	39 d5                	cmp    %edx,%ebp
  81096f:	75 03                	jne    810974 <__udivdi3+0xc4>
  810971:	83 eb 01             	sub    $0x1,%ebx
  810974:	31 ff                	xor    %edi,%edi
  810976:	89 d8                	mov    %ebx,%eax
  810978:	89 fa                	mov    %edi,%edx
  81097a:	83 c4 1c             	add    $0x1c,%esp
  81097d:	5b                   	pop    %ebx
  81097e:	5e                   	pop    %esi
  81097f:	5f                   	pop    %edi
  810980:	5d                   	pop    %ebp
  810981:	c3                   	ret    
  810982:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810988:	31 ff                	xor    %edi,%edi
  81098a:	31 db                	xor    %ebx,%ebx
  81098c:	89 d8                	mov    %ebx,%eax
  81098e:	89 fa                	mov    %edi,%edx
  810990:	83 c4 1c             	add    $0x1c,%esp
  810993:	5b                   	pop    %ebx
  810994:	5e                   	pop    %esi
  810995:	5f                   	pop    %edi
  810996:	5d                   	pop    %ebp
  810997:	c3                   	ret    
  810998:	90                   	nop
  810999:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8109a0:	89 d8                	mov    %ebx,%eax
  8109a2:	f7 f7                	div    %edi
  8109a4:	31 ff                	xor    %edi,%edi
  8109a6:	89 c3                	mov    %eax,%ebx
  8109a8:	89 d8                	mov    %ebx,%eax
  8109aa:	89 fa                	mov    %edi,%edx
  8109ac:	83 c4 1c             	add    $0x1c,%esp
  8109af:	5b                   	pop    %ebx
  8109b0:	5e                   	pop    %esi
  8109b1:	5f                   	pop    %edi
  8109b2:	5d                   	pop    %ebp
  8109b3:	c3                   	ret    
  8109b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8109b8:	39 ce                	cmp    %ecx,%esi
  8109ba:	72 0c                	jb     8109c8 <__udivdi3+0x118>
  8109bc:	31 db                	xor    %ebx,%ebx
  8109be:	3b 44 24 08          	cmp    0x8(%esp),%eax
  8109c2:	0f 87 34 ff ff ff    	ja     8108fc <__udivdi3+0x4c>
  8109c8:	bb 01 00 00 00       	mov    $0x1,%ebx
  8109cd:	e9 2a ff ff ff       	jmp    8108fc <__udivdi3+0x4c>
  8109d2:	66 90                	xchg   %ax,%ax
  8109d4:	66 90                	xchg   %ax,%ax
  8109d6:	66 90                	xchg   %ax,%ax
  8109d8:	66 90                	xchg   %ax,%ax
  8109da:	66 90                	xchg   %ax,%ax
  8109dc:	66 90                	xchg   %ax,%ax
  8109de:	66 90                	xchg   %ax,%ax

008109e0 <__umoddi3>:
  8109e0:	55                   	push   %ebp
  8109e1:	57                   	push   %edi
  8109e2:	56                   	push   %esi
  8109e3:	53                   	push   %ebx
  8109e4:	83 ec 1c             	sub    $0x1c,%esp
  8109e7:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  8109eb:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  8109ef:	8b 74 24 34          	mov    0x34(%esp),%esi
  8109f3:	8b 7c 24 38          	mov    0x38(%esp),%edi
  8109f7:	85 d2                	test   %edx,%edx
  8109f9:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  8109fd:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810a01:	89 f3                	mov    %esi,%ebx
  810a03:	89 3c 24             	mov    %edi,(%esp)
  810a06:	89 74 24 04          	mov    %esi,0x4(%esp)
  810a0a:	75 1c                	jne    810a28 <__umoddi3+0x48>
  810a0c:	39 f7                	cmp    %esi,%edi
  810a0e:	76 50                	jbe    810a60 <__umoddi3+0x80>
  810a10:	89 c8                	mov    %ecx,%eax
  810a12:	89 f2                	mov    %esi,%edx
  810a14:	f7 f7                	div    %edi
  810a16:	89 d0                	mov    %edx,%eax
  810a18:	31 d2                	xor    %edx,%edx
  810a1a:	83 c4 1c             	add    $0x1c,%esp
  810a1d:	5b                   	pop    %ebx
  810a1e:	5e                   	pop    %esi
  810a1f:	5f                   	pop    %edi
  810a20:	5d                   	pop    %ebp
  810a21:	c3                   	ret    
  810a22:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810a28:	39 f2                	cmp    %esi,%edx
  810a2a:	89 d0                	mov    %edx,%eax
  810a2c:	77 52                	ja     810a80 <__umoddi3+0xa0>
  810a2e:	0f bd ea             	bsr    %edx,%ebp
  810a31:	83 f5 1f             	xor    $0x1f,%ebp
  810a34:	75 5a                	jne    810a90 <__umoddi3+0xb0>
  810a36:	3b 54 24 04          	cmp    0x4(%esp),%edx
  810a3a:	0f 82 e0 00 00 00    	jb     810b20 <__umoddi3+0x140>
  810a40:	39 0c 24             	cmp    %ecx,(%esp)
  810a43:	0f 86 d7 00 00 00    	jbe    810b20 <__umoddi3+0x140>
  810a49:	8b 44 24 08          	mov    0x8(%esp),%eax
  810a4d:	8b 54 24 04          	mov    0x4(%esp),%edx
  810a51:	83 c4 1c             	add    $0x1c,%esp
  810a54:	5b                   	pop    %ebx
  810a55:	5e                   	pop    %esi
  810a56:	5f                   	pop    %edi
  810a57:	5d                   	pop    %ebp
  810a58:	c3                   	ret    
  810a59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810a60:	85 ff                	test   %edi,%edi
  810a62:	89 fd                	mov    %edi,%ebp
  810a64:	75 0b                	jne    810a71 <__umoddi3+0x91>
  810a66:	b8 01 00 00 00       	mov    $0x1,%eax
  810a6b:	31 d2                	xor    %edx,%edx
  810a6d:	f7 f7                	div    %edi
  810a6f:	89 c5                	mov    %eax,%ebp
  810a71:	89 f0                	mov    %esi,%eax
  810a73:	31 d2                	xor    %edx,%edx
  810a75:	f7 f5                	div    %ebp
  810a77:	89 c8                	mov    %ecx,%eax
  810a79:	f7 f5                	div    %ebp
  810a7b:	89 d0                	mov    %edx,%eax
  810a7d:	eb 99                	jmp    810a18 <__umoddi3+0x38>
  810a7f:	90                   	nop
  810a80:	89 c8                	mov    %ecx,%eax
  810a82:	89 f2                	mov    %esi,%edx
  810a84:	83 c4 1c             	add    $0x1c,%esp
  810a87:	5b                   	pop    %ebx
  810a88:	5e                   	pop    %esi
  810a89:	5f                   	pop    %edi
  810a8a:	5d                   	pop    %ebp
  810a8b:	c3                   	ret    
  810a8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810a90:	8b 34 24             	mov    (%esp),%esi
  810a93:	bf 20 00 00 00       	mov    $0x20,%edi
  810a98:	89 e9                	mov    %ebp,%ecx
  810a9a:	29 ef                	sub    %ebp,%edi
  810a9c:	d3 e0                	shl    %cl,%eax
  810a9e:	89 f9                	mov    %edi,%ecx
  810aa0:	89 f2                	mov    %esi,%edx
  810aa2:	d3 ea                	shr    %cl,%edx
  810aa4:	89 e9                	mov    %ebp,%ecx
  810aa6:	09 c2                	or     %eax,%edx
  810aa8:	89 d8                	mov    %ebx,%eax
  810aaa:	89 14 24             	mov    %edx,(%esp)
  810aad:	89 f2                	mov    %esi,%edx
  810aaf:	d3 e2                	shl    %cl,%edx
  810ab1:	89 f9                	mov    %edi,%ecx
  810ab3:	89 54 24 04          	mov    %edx,0x4(%esp)
  810ab7:	8b 54 24 0c          	mov    0xc(%esp),%edx
  810abb:	d3 e8                	shr    %cl,%eax
  810abd:	89 e9                	mov    %ebp,%ecx
  810abf:	89 c6                	mov    %eax,%esi
  810ac1:	d3 e3                	shl    %cl,%ebx
  810ac3:	89 f9                	mov    %edi,%ecx
  810ac5:	89 d0                	mov    %edx,%eax
  810ac7:	d3 e8                	shr    %cl,%eax
  810ac9:	89 e9                	mov    %ebp,%ecx
  810acb:	09 d8                	or     %ebx,%eax
  810acd:	89 d3                	mov    %edx,%ebx
  810acf:	89 f2                	mov    %esi,%edx
  810ad1:	f7 34 24             	divl   (%esp)
  810ad4:	89 d6                	mov    %edx,%esi
  810ad6:	d3 e3                	shl    %cl,%ebx
  810ad8:	f7 64 24 04          	mull   0x4(%esp)
  810adc:	39 d6                	cmp    %edx,%esi
  810ade:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810ae2:	89 d1                	mov    %edx,%ecx
  810ae4:	89 c3                	mov    %eax,%ebx
  810ae6:	72 08                	jb     810af0 <__umoddi3+0x110>
  810ae8:	75 11                	jne    810afb <__umoddi3+0x11b>
  810aea:	39 44 24 08          	cmp    %eax,0x8(%esp)
  810aee:	73 0b                	jae    810afb <__umoddi3+0x11b>
  810af0:	2b 44 24 04          	sub    0x4(%esp),%eax
  810af4:	1b 14 24             	sbb    (%esp),%edx
  810af7:	89 d1                	mov    %edx,%ecx
  810af9:	89 c3                	mov    %eax,%ebx
  810afb:	8b 54 24 08          	mov    0x8(%esp),%edx
  810aff:	29 da                	sub    %ebx,%edx
  810b01:	19 ce                	sbb    %ecx,%esi
  810b03:	89 f9                	mov    %edi,%ecx
  810b05:	89 f0                	mov    %esi,%eax
  810b07:	d3 e0                	shl    %cl,%eax
  810b09:	89 e9                	mov    %ebp,%ecx
  810b0b:	d3 ea                	shr    %cl,%edx
  810b0d:	89 e9                	mov    %ebp,%ecx
  810b0f:	d3 ee                	shr    %cl,%esi
  810b11:	09 d0                	or     %edx,%eax
  810b13:	89 f2                	mov    %esi,%edx
  810b15:	83 c4 1c             	add    $0x1c,%esp
  810b18:	5b                   	pop    %ebx
  810b19:	5e                   	pop    %esi
  810b1a:	5f                   	pop    %edi
  810b1b:	5d                   	pop    %ebp
  810b1c:	c3                   	ret    
  810b1d:	8d 76 00             	lea    0x0(%esi),%esi
  810b20:	29 f9                	sub    %edi,%ecx
  810b22:	19 d6                	sbb    %edx,%esi
  810b24:	89 74 24 04          	mov    %esi,0x4(%esp)
  810b28:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810b2c:	e9 18 ff ff ff       	jmp    810a49 <__umoddi3+0x69>
